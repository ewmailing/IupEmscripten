{"version":3,"file":"BUILD/hello.html","sources":["../../iup.c","../../iup_array.c","../../iup_attrib.c","../../iup_backgroundbox.c","../../iup_box.c","../../iup_button.c","../../iup_callback.c","../../iup_canvas.c","../../iup_cbox.c","../../iup_childtree.c","../../iup_class.c","../../iup_classattrib.c","../../iup_classbase.c","../../iup_colordlg.c","../../iup_detachbox.c","../../iup_dialog.c","../../iup_dlglist.c","../../iup_expander.c","../../iup_filedlg.c","../../iup_fill.c","../../iup_flatbutton.c","../../iup_focus.c","../../iup_font.c","../../iup_fontdlg.c","../../iup_frame.c","../../iup_func.c","../../iup_globalattrib.c","../../iup_gridbox.c","../../iup_hbox.c","../../iup_image.c","../../iup_key.c","../../iup_label.c","../../iup_layout.c","../../iup_link.c","../../iup_list.c","../../iup_mask.c","../../iup_maskmatch.c","../../iup_maskparse.c","../../iup_menu.c","../../iup_messagedlg.c","../../iup_names.c","../../iup_normalizer.c","../../iup_object.c","../../iup_open.c","../../iup_predialogs.c","../../iup_progressbar.c","../../iup_progressdlg.c","../../iup_radio.c","../../iup_register.c","../../iup_sbox.c","../../iup_scrollbox.c","../../iup_show.c","../../iup_spin.c","../../iup_split.c","../../iup_str.c","../../iup_strmessage.c","../../iup_table.c","../../iup_tabs.c","../../iup_text.c","../../iup_timer.c","../../iup_toggle.c","../../iup_tree.c","../../iup_user.c","../../iup_val.c","../../iup_vbox.c","../../iup_zbox.c","../iupemscripten_button.c","../iupemscripten_canvas.c","../iupemscripten_clipboard.c","../iupemscripten_colordlg.c","../iupemscripten_common.c","../iupemscripten_dialog.c","../iupemscripten_dragdrop.c","../iupemscripten_draw.c","../iupemscripten_filedlg.c","../iupemscripten_focus.c","../iupemscripten_font.c","../iupemscripten_fontdlg.c","../iupemscripten_frame.c","../iupemscripten_globalattrib.c","../iupemscripten_help.c","../iupemscripten_image.c","../iupemscripten_info.c","../iupemscripten_label.c","../iupemscripten_list.c","../iupemscripten_loop.c","../iupemscripten_menu.c","../iupemscripten_messagedlg.c","../iupemscripten_open.c","../iupemscripten_progressbar.c","../iupemscripten_tabs.c","../iupemscripten_text.c","../iupemscripten_timer.c","../iupemscripten_tips.c","../iupemscripten_toggle.c","../iupemscripten_tree.c","../iupemscripten_val.c","main_c.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8EA;;;;;AAQA;;;;;;;;;;;AC5DA;AAA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A;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAnFA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAcA;;AAZA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AAGA;;;;;;;;;;AAmHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAMA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AAEA;AAAA;AAAA;A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;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AA9BA;AAAA;AAAA;AAAA;;AAkCA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAQA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAQA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;AACA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;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A;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AAtGA;AAAA;AAAA;AAAA;;;;;ACzhBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AC5GA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;;;AAEA;;;;AAIA;AAAA;AAAA;AACA;AAAA;;AACA;;;AAEA;;;;;;AAIA;AAAA;;;;;;;;;AAsEA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;AAKA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAEA;AAAA;AAEA;AAAA;;;;;;;;;;AAhGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;;;AACA;;AACA;AAAA;;AACA;;;AACA;AAAA;AAEA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAsXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAnXA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAFA;AAAA;AAEA;AAAA;;;;;;;;;AAmVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvVA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAiHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmEA;AAAA;;;AAjEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;;;;AAIA;;;;AAIA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAC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AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAhBA;AAAA;AAGA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA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","sourcesContent":["/** \\file\n * \\brief miscelaneous functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n/*! \\mainpage IUP\n *\n * \\section intro Introduction\n *\n * Internal SDK documentation of the IUP library, automatically generated using Doxygen (<A HREF=\"http://www.doxygen.org/\">http://www.doxygen.org/</A>).\n *\n * \\section codestd Code Standards\n *\n * \\subsection func Function Names (prefix format)\n *  - IupFunc - User API, implemented in the core\n *  - iupFunc - Internal Core API, implemented in the core, used in the core or in driver\n *  - iupxxxFunc - Windows Internal API, implemented in driver xxx, used in driver xxx\n *  - iupdrvFunc - Driver API, implemented in driver, used in the core or driver\n *  - xxxFunc - Driver xxx local functions\n * \n * \\subsection glob Global Variables (lower case format)\n *  - iupxxx_var\n *                    \n * \\subsection loc Local Variables (lower case format, using module name)\n *  - iyyy_var\n *                    \n * \\subsection fil File Names\n *  - iupyyy.h - public headers\n *  - iup_yyy.h/c - core\n *  - iupxxx_yyy.h/c - driver\n *   \n * \\subsection strc Structures\n *  - Iyyy\n *   \n * \\subsection com File Comments (at start)\n *  - Check an existent file for example.\n *    \n * \\subsection def Defines\n *  - __IUPXXX_H   (for include file, same file name, upper case, \"__\" prefix and replace \".\" by \"_\")\n *  - IUP_XXX      (for global enumerations)\n *  - IXXX_YYY     (for local enumerations)\n *  - iupXXX       (for macros, complement with Function Names rules)\n *   \n * \\subsection doc Documentation\n *  - In the header, using Doxygen commands.\n *  - Check an existent header for example.\n *\n */\n\n/** \\defgroup util Utilities\n */\n\n/** \\defgroup cpi Control SDK\n * \\par\n * <H3><A HREF=\"../en/cpi.html\">Control Creation Guide</A></H3>\n */\n\n#include <stdlib.h>\n\n#include \"iup.h\"\n\n/* This appears only here to avoid changing the iup.h header for bug fixes */\n#define IUP_VERSION_FIX \"\"\n#define IUP_VERSION_FIX_NUMBER 0\n/* #define IUP_VERSION_FIX_DATE \"AAAA/MM/DD\" */\n\nconst char iup_ident[] = \n  \"$IUP: \" IUP_VERSION IUP_VERSION_FIX \" \" IUP_COPYRIGHT \" $\\n\"\n  \"$URL: www.tecgraf.puc-rio.br/iup $\\n\";\n\n/* Using this, if you look for the string TECVER, you will find also the library version. */\nconst char *iup_tecver = \"TECVERID.str:Iup:LIB:\" IUP_VERSION IUP_VERSION_FIX;\n\nchar* IupVersion(void)\n{\n  (void)iup_tecver;\n  (void)iup_ident;\n  return IUP_VERSION IUP_VERSION_FIX;\n}\n\nchar* IupVersionDate(void)\n{\n#ifdef IUP_VERSION_FIX_DATE\n  return IUP_VERSION_FIX_DATE;\n#else\n  return IUP_VERSION_DATE;\n#endif\n}\n \nint IupVersionNumber(void)\n{\n  return IUP_VERSION_NUMBER+IUP_VERSION_FIX_NUMBER;\n}\n","/** \\file\n * \\brief Simple expandable array\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup_array.h\"\n#include \"iup_assert.h\"\n\n\nstruct _Iarray\n{\n  void* data;\n  int count;\n  int max_count;\n  int elem_size;\n  int start_count;\n};\n\nIarray* iupArrayCreate(int start_count, int elem_size)\n{\n  Iarray* iarray = (Iarray*)malloc(sizeof(Iarray));\n  iarray->count = 0;\n  iarray->elem_size = elem_size;\n  iarray->max_count = start_count;\n  iarray->start_count = start_count;\n  iarray->data = malloc(elem_size*start_count);\n  iupASSERT(iarray->data!=NULL);\n  if (!iarray->data)\n  {\n    free(iarray);\n    return NULL;\n  }\n  memset(iarray->data, 0, elem_size*start_count);\n  return iarray;\n}\n\nvoid iupArrayDestroy(Iarray* iarray)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return;\n  if (iarray->data) \n  {\n    memset(iarray->data, 0, iarray->elem_size*iarray->max_count);\n    free(iarray->data);\n  }\n  free(iarray);\n}\n\nvoid* iupArrayGetData(Iarray* iarray)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return NULL;\n  return iarray->data;\n}\n\nvoid* iupArrayInc(Iarray* iarray)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return NULL;\n  if (iarray->count >= iarray->max_count)\n  {\n    int old_count = iarray->max_count;\n    iarray->max_count += iarray->start_count;\n    iarray->data = realloc(iarray->data, iarray->elem_size*iarray->max_count);\n    iupASSERT(iarray->data!=NULL);\n    if (!iarray->data)\n      return NULL;\n    memset((unsigned char*)iarray->data + iarray->elem_size*old_count, 0, iarray->elem_size*(iarray->max_count-old_count));\n  }\n  iarray->count++;\n  return iarray->data;\n}\n\nvoid* iupArrayAdd(Iarray* iarray, int add_count)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return NULL;\n  if (iarray->count+add_count > iarray->max_count)\n  {\n    int old_count = iarray->max_count;\n    iarray->max_count += add_count;\n    iarray->data = realloc(iarray->data, iarray->elem_size*iarray->max_count);\n    iupASSERT(iarray->data!=NULL);\n    if (!iarray->data)\n      return NULL;\n    memset((unsigned char*)iarray->data + iarray->elem_size*old_count, 0, iarray->elem_size*(iarray->max_count-old_count));\n  }\n  iarray->count += add_count;\n  return iarray->data;\n}\n\nvoid* iupArrayInsert(Iarray* iarray, int index, int insert_count)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return NULL;\n  if (index < 0 || index > iarray->count)\n    return NULL;\n  iupArrayAdd(iarray, insert_count);\n  if (index < iarray->count)  /* if equal, insert at the end, no need to move data */\n    memmove((unsigned char*)iarray->data + iarray->elem_size*(index + insert_count), \n            (unsigned char*)iarray->data + iarray->elem_size*index, \n            iarray->elem_size*(iarray->count - insert_count - index));\n  /* clear new data */\n  memset((unsigned char*)iarray->data + iarray->elem_size*index, 0, iarray->elem_size*insert_count);\n  return iarray->data;\n}\n\nvoid iupArrayRemove(Iarray* iarray, int index, int remove_count)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return;\n  if (index < 0 || index+remove_count > iarray->count)\n    return;\n  if (index+remove_count < iarray->count)  /* if equal, remove at the end, no need to move data */\n    memmove((unsigned char*)iarray->data + iarray->elem_size*index, \n            (unsigned char*)iarray->data + iarray->elem_size*(index + remove_count), \n            iarray->elem_size*(iarray->count - remove_count - index));\n  /* clear old data */\n  memset((unsigned char*)iarray->data + iarray->elem_size*(iarray->count - remove_count), 0, iarray->elem_size*remove_count);\n  iarray->count -= remove_count;\n}\n\nint iupArrayCount(Iarray* iarray)\n{\n  iupASSERT(iarray!=NULL);\n  if (!iarray)\n    return 0;\n  return iarray->count;\n}\n","/** \\file\n * \\brief attributes environment management\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <limits.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_childtree.h\"\n#include \"iup_str.h\"\n#include \"iup_ledlex.h\"\n#include \"iup_attrib.h\"\n#include \"iup_assert.h\"\n\n\n#define iupATTRIB_LANGUAGE_STRING(_v)  (_v && _v[0] == '_' && _v[1] == '@') \n#define iupATTRIB_LANGUAGE_SHIFT 2\n\n#define iupATTRIB_GET_LANGUAGE_STRING(_v, _s)                              \\\n  {                                                                        \\\n    char* new_value = IupGetLanguageString(_v+iupATTRIB_LANGUAGE_SHIFT);   \\\n    if (new_value != _v+iupATTRIB_LANGUAGE_SHIFT)                          \\\n    {                                                                      \\\n      _v = new_value;                                                      \\\n      _s = 0;  /* no need to store it again, already stored internally */  \\\n    }                                                                      \\\n  }\n\n\nint IupGetAllAttributes(Ihandle* ih, char** names, int n)\n{\n  char *name;\n  int i = 0;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return 0;\n\n  if (!names || !n)\n    return iupTableCount(ih->attrib);\n\n  name = iupTableFirst(ih->attrib);\n  while (name)\n  {\n    if (!iupATTRIB_ISINTERNAL(name))\n    {\n      names[i] = name;\n      i++;\n\n      if (i == n)\n        break;\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n\n  return i;\n}\n\nchar* IupGetAttributes(Ihandle *ih)\n{\n  char *buffer;\n  char *name, *value;\n  char sb[128];\n  int size;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  buffer = iupStrGetLargeMem(&size);\n  buffer[0] = 0;\n\n  name = iupTableFirst(ih->attrib);\n  while (name && size)\n  {\n    if (!iupATTRIB_ISINTERNAL(name))\n    {\n      if (buffer[0] != 0)\n        { strcat(buffer,\",\"); size--; }\n\n      value = iupTableGetCurr(ih->attrib);\n      if (iupAttribIsNotString(ih, name))\n      {\n        sprintf(sb, \"%p\", (void*) value);\n        value = sb;\n      }\n\n      strcat(buffer, name);  size -= strlen(name);\n      strcat(buffer,\"=\\\"\");  size--;\n      strcat(buffer, value);  size -= strlen(value);\n      strcat(buffer,\"\\\"\");  size--;\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n\n  return buffer;\n}\n\nvoid iupAttribUpdateFromParent(Ihandle* ih)\n{\n  Iclass* ic = ih->iclass;\n  char *name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    /* if inheritable and NOT defined at the element */\n    if (iupClassObjectCurAttribIsInherit(ic) && !iupAttribGet(ih, name))\n    {\n      /* check in the parent tree if the attribute is defined */\n      Ihandle* parent = ih->parent;\n      while (parent)\n      {\n        char* value = iupTableGet(parent->attrib, name);\n        if (value)\n        {\n          int inherit;\n          /* set on the class */\n          iupClassObjectSetAttribute(ih, name, value, &inherit);\n          break;\n        }\n        parent = parent->parent;\n      }\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n}\n\nstatic int iAttribIsInherit(Ihandle* ih, const  char* name)\n{\n  int inherit;\n  char *def_value;\n  iupClassObjectGetAttributeInfo(ih, name, &def_value, &inherit);\n  return inherit;\n}\n\nstatic void iAttribNotifyChildren(Ihandle *ih, const char* name, const char *value)\n{\n  int inherit;\n  Ihandle* child = ih->firstchild;\n  while (child)\n  {\n    if (!iupTableGet(child->attrib, name))\n    {\n      /* set only if an inheritable attribute at the child */\n      if (iAttribIsInherit(child, name))\n      {\n        /* set on the class */\n        iupClassObjectSetAttribute(child, name, value, &inherit);\n\n        iAttribNotifyChildren(child, name, value);\n      }\n    }\n\n    child = child->brother;\n  }\n}\n\nvoid iupAttribUpdateChildren(Ihandle* ih)\n{\n  char *name = iupTableFirst(ih->attrib);\n  while (name)\n  {\n    if (!iupATTRIB_ISINTERNAL(name) && iAttribIsInherit(ih, name))\n    {\n      /* retrieve from the table */\n      char* value = iupTableGet(ih->attrib, name);\n      iAttribNotifyChildren(ih, name, value);\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n}\n\nvoid iupAttribUpdate(Ihandle* ih)\n{\n  char** name_array;\n  char *name, *value;\n  int count, i = 0, inherit, store;\n\n  count = iupTableCount(ih->attrib);\n  if (!count)\n    return;\n\n  name_array = (char**)malloc(count * sizeof(char*));\n\n  /* store the names before updating so we can add or remove attributes during the update */\n  name = iupTableFirst(ih->attrib);\n  while (name)\n  {\n    if (!iupATTRIB_ISINTERNAL(name))\n    {\n      name_array[i] = name;\n      i++;\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n  count = i;\n\n  /* for all defined attributes updates the native system */\n  for (i = 0; i < count; i++)\n  {\n    name = name_array[i];\n\n    /* retrieve from the table */\n    value = iupTableGet(ih->attrib, name);\n\n    /* set on the class */\n    store = iupClassObjectSetAttribute(ih, name, value, &inherit);\n\n    if (inherit)\n      iAttribNotifyChildren(ih, name, value);\n\n    if (store == 0)\n      iupTableRemove(ih->attrib, name); /* remove from the table acording to the class SetAttribute */\n  }\n\n  free(name_array);\n}\n\nvoid IupSetAttributeId(Ihandle *ih, const char* name, int id, const char *value)\n{\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupClassObjectSetAttributeId(ih, name, id, value)!=0) /* store strings and pointers */\n    iupAttribSetId(ih, name, id, value);\n}\n\nvoid IupSetStrAttributeId(Ihandle *ih, const char* name, int id, const char *value)\n{\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupStoreAttributeId(Ihandle *ih, const char* name, int id, const char *value)\n{\n  int store = 1;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupATTRIB_LANGUAGE_STRING(value))\n    iupATTRIB_GET_LANGUAGE_STRING(value, store);\n\n  if (iupClassObjectSetAttributeId(ih, name, id, value)==1) /* store only strings */\n  {\n    if (store)\n      iupAttribSetStrId(ih, name, id, value);\n    else\n      iupAttribSetId(ih, name, id, value);\n  }\n}\n\nchar* IupGetAttributeId(Ihandle *ih, const char* name, int id)\n{\n  char *value;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  value = iupClassObjectGetAttributeId(ih, name, id);\n  if (!value)\n    value = iupAttribGetId(ih, name, id);\n\n  return value;\n}\n\nvoid IupSetAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value)\n{\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupClassObjectSetAttributeId2(ih, name, lin, col, value)!=0) /* store strings and pointers */\n    iupAttribSetId2(ih, name, lin, col, value);\n}\n\nvoid IupSetStrAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value)\n{\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupStoreAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value)\n{\n  int store = 1;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupATTRIB_LANGUAGE_STRING(value))\n    iupATTRIB_GET_LANGUAGE_STRING(value, store);\n\n  if (iupClassObjectSetAttributeId2(ih, name, lin, col, value)==1) /* store only strings */\n  {\n    if (store)\n      iupAttribSetStrId2(ih, name, lin, col, value);\n    else\n      iupAttribSetId2(ih, name, lin, col, value);\n  }\n}\n\nchar* IupGetAttributeId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char *value;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  value = iupClassObjectGetAttributeId2(ih, name, lin, col);\n  if (!value)\n    value = iupAttribGetId2(ih, name, lin, col);\n\n  return value;\n}\n\nint IupGetIntId(Ihandle *ih, const char* name, int id)\n{\n  int i = 0;\n  char *value = IupGetAttributeId(ih, name, id);\n  if (value)\n  {\n    if (!iupStrToInt(value, &i))\n    {\n      if (iupStrBoolean(value))\n        i = 1;\n    }\n  }\n  return i;\n}\n\nfloat IupGetFloatId(Ihandle *ih, const char* name, int id)\n{\n  float f = 0;\n  iupStrToFloat(IupGetAttributeId(ih, name, id), &f);\n  return f;\n}\n\ndouble IupGetDoubleId(Ihandle *ih, const char* name, int id)\n{\n  double f = 0;\n  iupStrToDouble(IupGetAttributeId(ih, name, id), &f);\n  return f;\n}\n\nvoid IupGetRGBId(Ihandle *ih, const char* name, int id, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n  iupStrToRGB(IupGetAttributeId(ih, name, id), r, g, b);\n}\n\nvoid IupSetStrfId(Ihandle *ih, const char* name, int id, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupSetfAttributeId(Ihandle *ih, const char* name, int id, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupSetIntId(Ihandle* ih, const char* name, int id, int num)\n{\n  char value[20];  /* +4,294,967,296 */\n  sprintf(value, \"%d\", num);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupSetFloatId(Ihandle* ih, const char* name, int id, float num)\n{\n  char value[80];\n  sprintf(value, IUP_FLOAT2STR, num);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupSetDoubleId(Ihandle* ih, const char* name, int id, double num)\n{\n  char value[80];\n  sprintf(value, IUP_DOUBLE2STR, num);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nvoid IupSetRGBId(Ihandle *ih, const char* name, int id, unsigned char r, unsigned char g, unsigned char b)\n{\n  char value[60];\n  sprintf(value, \"%d %d %d\", (int)r, (int)g, (int)b);\n  IupStoreAttributeId(ih, name, id, value);\n}\n\nint IupGetIntId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  int i = 0;\n  char *value = IupGetAttributeId2(ih, name, lin, col);\n  if (value)\n  {\n    if (!iupStrToInt(value, &i))\n    {\n      if (iupStrBoolean(value))\n        i = 1;\n    }\n  }\n  return i;\n}\n\nfloat IupGetFloatId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  float f = 0;\n  iupStrToFloat(IupGetAttributeId2(ih, name, lin, col), &f);\n  return f;\n}\n\ndouble IupGetDoubleId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  double f = 0;\n  iupStrToDouble(IupGetAttributeId2(ih, name, lin, col), &f);\n  return f;\n}\n\nvoid IupGetRGBId2(Ihandle *ih, const char* name, int lin, int col, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n  iupStrToRGB(IupGetAttributeId2(ih, name, lin, col), r, g, b);\n}\n\nvoid IupSetStrfId2(Ihandle* ih, const char* name, int lin, int col, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetfAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetIntId2(Ihandle* ih, const char* name, int lin, int col, int num)\n{\n  char value[20];  /* +4,294,967,296 */\n  sprintf(value, \"%d\", num);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetFloatId2(Ihandle* ih, const char* name, int lin, int col, float num)\n{\n  char value[80];\n  sprintf(value, IUP_FLOAT2STR, num);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetDoubleId2(Ihandle* ih, const char* name, int lin, int col, double num)\n{\n  char value[80];\n  sprintf(value, IUP_DOUBLE2STR, num);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetRGBId2(Ihandle *ih, const char* name, int lin, int col, unsigned char r, unsigned char g, unsigned char b)\n{\n  char value[60];\n  sprintf(value, \"%d %d %d\", (int)r, (int)g, (int)b);\n  IupStoreAttributeId2(ih, name, lin, col, value);\n}\n\nvoid IupSetAttribute(Ihandle *ih, const char* name, const char *value)\n{\n  int inherit;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  if (!ih)\n  {\n    IupSetGlobal(name, value);\n    return;\n  }\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupATTRIB_ISINTERNAL(name))\n    iupAttribSet(ih, name, value);\n  else\n  {\n    if (iupClassObjectSetAttribute(ih, name, value, &inherit)!=0) /* store strings and pointers */\n      iupAttribSet(ih, name, value);\n\n    if (inherit)\n      iAttribNotifyChildren(ih, name, value);\n  }\n}\n\nvoid IupSetStrAttribute(Ihandle *ih, const char* name, const char *value)\n{\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupStoreAttribute(Ihandle *ih, const char* name, const char *value)\n{\n  int inherit;\n\n  if (!name)\n    return;\n\n  if (!ih)\n  {\n    IupStoreGlobal(name, value);\n    return;\n  }\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (iupATTRIB_ISINTERNAL(name))\n    iupAttribSetStr(ih, name, value);\n  else\n  {\n    int store = 1;\n\n    if (iupATTRIB_LANGUAGE_STRING(value))\n      iupATTRIB_GET_LANGUAGE_STRING(value, store);\n\n    if (iupClassObjectSetAttribute(ih, name, value, &inherit)==1) /* store only strings */\n    {\n      if (store)\n        iupAttribSetStr(ih, name, value);\n      else\n        iupAttribSet(ih, name, value);\n    }\n\n    if (inherit)\n      iAttribNotifyChildren(ih, name, value);\n  }\n}\n\nstatic void iAttribResetChildren(Ihandle *ih, const char* name)\n{\n  Ihandle* child = ih->firstchild;\n  while (child)\n  {\n    /* set only if an inheritable attribute at the child */\n    if (iAttribIsInherit(child, name))\n    {\n      iupAttribSet(child, name, NULL);\n\n      iAttribResetChildren(child, name);\n    }\n\n    child = child->brother;\n  }\n}\n\nvoid IupResetAttribute(Ihandle *ih, const char* name)\n{\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  iupAttribSet(ih, name, NULL);\n\n  if (iAttribIsInherit(ih, name))\n    iAttribResetChildren(ih, name);\n}\n\nchar* IupGetAttribute(Ihandle *ih, const char* name)\n{\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  if (!ih)\n    return IupGetGlobal(name);\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  if (iupATTRIB_ISINTERNAL(name))\n    return iupAttribGet(ih, name);\n  else\n  {\n    int inherit;\n    char *value, *def_value;\n\n    value = iupClassObjectGetAttribute(ih, name, &def_value, &inherit);\n\n    if (!value)\n      value = iupAttribGet(ih, name);\n\n    if (!value && inherit)\n    {\n      while (!value)\n      {\n        ih = ih->parent;\n        if (!ih)\n          break;\n\n        value = iupAttribGet(ih, name);\n      }\n    }\n\n    if (!value)\n      value = def_value;\n\n    return value;\n  }\n}\n\nfloat IupGetFloat(Ihandle *ih, const char* name)\n{\n  float f = 0;\n  iupStrToFloat(IupGetAttribute(ih, name), &f);\n  return f;\n}\n\ndouble IupGetDouble(Ihandle *ih, const char* name)\n{\n  double f = 0;\n  iupStrToDouble(IupGetAttribute(ih, name), &f);\n  return f;\n}\n\nint IupGetInt(Ihandle *ih, const char* name)\n{\n  int i = 0;\n  char *value = IupGetAttribute(ih, name);\n  if (value)\n  {\n    if (!iupStrToInt(value, &i))\n    {\n      if (iupStrBoolean(value))\n        i = 1;\n    }\n  }\n  return i;\n}\n\nint IupGetInt2(Ihandle *ih, const char* name)\n{\n  int i1 = 0, i2 = 0;\n  char *value = IupGetAttribute(ih, name);\n  if (value)\n  {\n    char sep = 'x';\n    if (strchr(value, ':')!=NULL)\n      sep = ':';\n    else if (strchr(value, ',')!=NULL)\n      sep = ',';\n\n    iupStrToIntInt(value, &i1, &i2, sep);\n  }\n  return i2;\n}\n\nint IupGetIntInt(Ihandle *ih, const char* name, int *i1, int *i2)\n{\n  int _i1 = 0, _i2 = 0;\n  char *value = IupGetAttribute(ih, name);\n  if (value)\n  {\n    int count;\n\n    char sep = 'x';\n    if (strchr(value, ':')!=NULL)\n      sep = ':';\n    else if (strchr(value, ',')!=NULL)\n      sep = ',';\n\n    count = iupStrToIntInt(value, &_i1, &_i2, sep);\n    if (i1) *i1 = _i1;\n    if (i2) *i2 = _i2;\n    return count;\n  }\n  return 0;\n}\n\nvoid IupGetRGB(Ihandle *ih, const char* name, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n  iupStrToRGB(IupGetAttribute(ih, name), r, g, b);\n}\n\nvoid IupSetStrf(Ihandle *ih, const char* name, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupSetfAttribute(Ihandle *ih, const char* name, const char* f, ...)\n{\n  int size;\n  char* value = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupSetInt(Ihandle* ih, const char* name, int num)\n{\n  char value[20];  /* +4,294,967,296 */\n  sprintf(value, \"%d\", num);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupSetFloat(Ihandle* ih, const char* name, float num)\n{\n  char value[80];\n  sprintf(value, IUP_FLOAT2STR, num);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupSetDouble(Ihandle* ih, const char* name, double num)\n{\n  char value[80];\n  sprintf(value, IUP_DOUBLE2STR, num);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid IupSetRGB(Ihandle *ih, const char* name, unsigned char r, unsigned char g, unsigned char b)\n{\n  char value[60];\n  sprintf(value, \"%d %d %d\", (int)r, (int)g, (int)b);\n  IupStoreAttribute(ih, name, value);\n}\n\nvoid iupAttribSetHandleName(Ihandle *ih)\n{\n  char str_name[100];\n  sprintf(str_name, \"_IUP_NAME(%p)\", ih);\n  IupSetHandle(str_name, ih);\n}\n\nchar* iupAttribGetHandleName(Ihandle *ih)\n{\n  char str_name[100];\n  sprintf(str_name, \"_IUP_NAME(%p)\", ih);\n  if (IupGetHandle(str_name)==ih)\n    return iupStrReturnStr(str_name);\n  else\n    return NULL;\n}\n\nvoid IupSetAttributeHandle(Ihandle* ih, const char* name, Ihandle* ih_named)\n{\n  char* handle_name;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  iupASSERT(ih_named!=NULL);\n  if (!ih_named)\n    return;\n\n  handle_name = IupGetName(ih_named);\n  if (!handle_name)\n  {\n    iupAttribSetHandleName(ih_named);\n    handle_name = IupGetName(ih_named);\n  }\n\n  IupStoreAttribute(ih, name, handle_name);\n}\n\nIhandle* IupGetAttributeHandle(Ihandle *ih, const char* name)\n{\n  char* handle_name;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  handle_name = IupGetAttribute(ih, name);\n  return IupGetHandle(handle_name);\n}\n\nIhandle* IupSetAtt(const char* handle_name, Ihandle* ih, const char* name, ...)\n{\n  const char *attr, *val;\n  va_list arg;\n  va_start (arg, name);\n  attr = name;\n  while (attr)\n  {\n    val = va_arg(arg, const char*);\n    IupSetAttribute(ih, attr, val);\n    attr = va_arg(arg, const char*);\n  }\n  va_end(arg);\n  if (handle_name) IupSetHandle(handle_name, ih);\n  return ih;\n}\n\nvoid iupAttribSetClassObject(Ihandle* ih, const char* name, const char* value)\n{\n  int inherit;\n  iupClassObjectSetAttribute(ih, name, value, &inherit);\n}\n\nvoid iupAttribSetClassObjectId(Ihandle* ih, const char* name, int id, const char* value)\n{\n  iupClassObjectSetAttributeId(ih, name, id, value);\n}\n\nvoid iupAttribSetClassObjectId2(Ihandle* ih, const char* name, int lin, int col, const char* value)\n{\n  iupClassObjectSetAttributeId2(ih, name, lin, col, value);\n}\n\nchar* iupAttribGetClassObject(Ihandle* ih, const char* name)\n{\n  int inherit;\n  char *def_value;\n  return iupClassObjectGetAttribute(ih, name, &def_value, &inherit);\n}\n\nchar* iupAttribGetClassObjectId(Ihandle* ih, const char* name, int id)\n{\n  return iupClassObjectGetAttributeId(ih, name, id);\n}\n\nchar* iupAttribGetClassObjectId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  return iupClassObjectGetAttributeId2(ih, name, lin, col);\n}\n\nvoid iupAttribSet(Ihandle* ih, const char* name, const char* value)\n{\n  if (!value)\n    iupTableRemove(ih->attrib, name);\n  else\n    iupTableSet(ih->attrib, name, (void*)value, IUPTABLE_POINTER);\n}\n\nvoid iupAttribSetStr(Ihandle* ih, const char* name, const char* value)\n{\n  if (!value)\n    iupTableRemove(ih->attrib, name);\n  else\n  {\n    int store = 1;\n\n    if (iupATTRIB_LANGUAGE_STRING(value))\n      iupATTRIB_GET_LANGUAGE_STRING(value, store);\n\n    if (store)\n      iupTableSet(ih->attrib, name, (void*)value, IUPTABLE_STRING);\n    else\n      iupTableSet(ih->attrib, name, (void*)value, IUPTABLE_POINTER);\n  }\n}\n\nvoid iupAttribSetStrf(Ihandle *ih, const char* name, const char* f, ...)\n{\n  char* value = iupStrGetMemory(1024);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(value, 1024, f, arglist);\n  va_end(arglist);\n  iupAttribSetStr(ih, name, value);\n}\n\nvoid iupAttribSetInt(Ihandle *ih, const char* name, int num)\n{\n  char value[20];  /* +4,294,967,296 */\n  sprintf(value, \"%d\", num);\n  iupAttribSetStr(ih, name, value);\n}\n\nvoid iupAttribSetFloat(Ihandle *ih, const char* name, float num)\n{\n  char value[80];\n  sprintf(value, IUP_FLOAT2STR, num);\n  iupAttribSetStr(ih, name, value);\n}\n\nvoid iupAttribSetDouble(Ihandle *ih, const char* name, double num)\n{\n  char value[80];\n  sprintf(value, IUP_DOUBLE2STR, num);\n  iupAttribSetStr(ih, name, value);\n}\n\nvoid iupAttribSetId(Ihandle *ih, const char* name, int id, const char* value)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  iupAttribSet(ih, nameid, value);\n}\n\nvoid iupAttribSetStrId(Ihandle *ih, const char* name, int id, const char* value)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  iupAttribSetStr(ih, nameid, value);\n}\n\nstatic void iAttribSetNameId2(char* nameid, const char* name, int lin, int col)\n{\n  if (lin==IUP_INVALID_ID)\n    sprintf(nameid, \"%s*:%d\", name, col);\n  else if (col==IUP_INVALID_ID)\n    sprintf(nameid, \"%s%d:*\", name, lin);\n  else\n    sprintf(nameid, \"%s%d:%d\", name, lin, col);\n}\n\nvoid iupAttribSetId2(Ihandle *ih, const char* name, int lin, int col, const char* value)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  iupAttribSet(ih, nameid, value);\n}\n\nvoid iupAttribSetStrId2(Ihandle *ih, const char* name, int lin, int col, const char* value)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  iupAttribSetStr(ih, nameid, value);\n}\n\nvoid iupAttribSetIntId(Ihandle *ih, const char* name, int id, int num)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  iupAttribSetInt(ih, nameid, num);\n}\n\nvoid iupAttribSetIntId2(Ihandle *ih, const char* name, int lin, int col, int num)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  iupAttribSetInt(ih, nameid, num);\n}\n\nvoid iupAttribSetFloatId(Ihandle *ih, const char* name, int id, float num)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  iupAttribSetFloat(ih, nameid, num);\n}\n\nvoid iupAttribSetDoubleId(Ihandle *ih, const char* name, int id, double num)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  iupAttribSetDouble(ih, nameid, num);\n}\n\nvoid iupAttribSetFloatId2(Ihandle *ih, const char* name, int lin, int col, float num)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  iupAttribSetFloat(ih, nameid, num);\n}\n\nvoid iupAttribSetDoubleId2(Ihandle *ih, const char* name, int lin, int col, double num)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  iupAttribSetDouble(ih, nameid, num);\n}\n\nchar* iupAttribGetId(Ihandle* ih, const char* name, int id)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  return iupAttribGet(ih, nameid);\n}\n\nint iupAttribGetIntId(Ihandle* ih, const char* name, int id)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  return iupAttribGetInt(ih, nameid);\n}\n\nint iupAttribGetBooleanId(Ihandle* ih, const char* name, int id)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  return iupAttribGetBoolean(ih, nameid);\n}\n\nfloat iupAttribGetFloatId(Ihandle* ih, const char* name, int id)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  return iupAttribGetFloat(ih, nameid);\n}\n\ndouble iupAttribGetDoubleId(Ihandle* ih, const char* name, int id)\n{\n  char nameid[100];\n  sprintf(nameid, \"%s%d\", name, id);\n  return iupAttribGetDouble(ih, nameid);\n}\n\nchar* iupAttribGetId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  return iupAttribGet(ih, nameid);\n}\n\nint iupAttribGetIntId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  return iupAttribGetInt(ih, nameid);\n}\n\nint iupAttribGetBooleanId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  return iupAttribGetBoolean(ih, nameid);\n}\n\nfloat iupAttribGetFloatId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  return iupAttribGetFloat(ih, nameid);\n}\n\ndouble iupAttribGetDoubleId2(Ihandle* ih, const char* name, int lin, int col)\n{\n  char nameid[100];\n  iAttribSetNameId2(nameid, name, lin, col);\n  return iupAttribGetDouble(ih, nameid);\n}\n\nint iupAttribGetBoolean(Ihandle* ih, const char* name)\n{\n  char *value = iupAttribGetStr(ih, name);\n  if (value)\n  {\n    if (iupStrBoolean(value))\n      return 1;\n  }\n  return 0;\n}\n\nint iupAttribGetInt(Ihandle* ih, const char* name)\n{\n  int i = 0;\n  char *value = iupAttribGetStr(ih, name);\n  if (value)\n  {\n    if (!iupStrToInt(value, &i))\n    {\n      if (iupStrBoolean(value))\n        i = 1;\n    }\n  }\n  return i;\n}\n\nfloat iupAttribGetFloat(Ihandle* ih, const char* name)\n{\n  float f = 0;\n  char *value = iupAttribGetStr(ih, name);\n  if (value)\n    iupStrToFloat(value, &f);\n  return f;\n}\n\ndouble iupAttribGetDouble(Ihandle* ih, const char* name)\n{\n  double f = 0;\n  char *value = iupAttribGetStr(ih, name);\n  if (value)\n    iupStrToDouble(value, &f);\n  return f;\n}\n\nchar* iupAttribGet(Ihandle* ih, const char* name)\n{\n  if (!ih || !name)\n    return NULL;\n  return iupTableGet(ih->attrib, name);\n}\n\nchar* iupAttribGetStr(Ihandle* ih, const char* name)\n{\n  char* value;\n  if (!ih || !name)\n    return NULL;\n\n  value = iupTableGet(ih->attrib, name);\n\n  if (!value && !iupATTRIB_ISINTERNAL(name))\n  {\n    int inherit;\n    char *def_value;\n    iupClassObjectGetAttributeInfo(ih, name, &def_value, &inherit);\n\n    if (inherit)\n    {\n      while (!value)\n      {\n        ih = ih->parent;\n        if (!ih)\n          break;\n\n        value = iupAttribGet(ih, name);\n      }\n    }\n\n    if (!value)\n      value = def_value;\n  }\n\n  return value;\n}\n\nchar* iupAttribGetLocal(Ihandle* ih, const char* name)\n{\n  char* value;\n  if (!ih || !name)\n    return NULL;\n\n  value = iupTableGet(ih->attrib, name);\n\n  if (!value && !iupATTRIB_ISINTERNAL(name))\n  {\n    int inherit;\n    char *def_value;\n    value = iupClassObjectGetAttribute(ih, name, &def_value, &inherit);\n\n    if (!value)\n      value = def_value;\n  }\n\n  return value;\n}\n\nchar* iupAttribGetInherit(Ihandle* ih, const char* name)\n{\n  char* value;\n  if (!ih || !name)\n    return NULL;\n\n  value = iupAttribGet(ih, name);   /* Check on the element first */\n  while (!value)\n  {\n    ih = ih->parent;   /* iheritance here independs on the attribute */\n    if (!ih)\n      return NULL;\n\n    value = iupAttribGet(ih, name);\n  }\n  return value;\n}\n\nchar* iupAttribGetInheritNativeParent(Ihandle* ih, const char* name)\n{\n  char* value;\n  if (!ih || !name)\n    return NULL;\n\n  value = NULL;    /* Do NOT check on the element first */\n  while (!value)\n  {\n    ih = iupChildTreeGetNativeParent(ih);\n    if (!ih)\n      return NULL;\n\n    value = iupAttribGet(ih, name);\n  }\n\n  return value;\n}\n\nstatic const char* env_str = NULL;\nstatic void iAttribCapture(char* env_buffer, char* dlm)\n{\n  int i=0;\n  int c;\n  do\n  {\n    c = *env_str; ++env_str;\n    if (i < 256)\n      env_buffer[i++] = (char) c;\n  } while (c && !strchr(dlm,c));\n  env_buffer[i-1]='\\0';                                /* discard delimiter */\n}\n\nstatic void iAttribSkipComment(void)\n{\n  int c;\n  do\n  {\n    c = *env_str; ++env_str;\n  } while ((c > 0) && (c != '\\n'));\n}\n\nstatic int iAttribToken(char* env_buffer)\n{\n  for (;;)\n  {\n    int c = *env_str; ++env_str;\n    switch (c)\n    {\n    case 0:\n      return IUPLEX_TK_END;\n\n    case '#':          /* Skip comment */\n    case '%':          /* Skip comment */\n      iAttribSkipComment();\n      continue;\n\n    case ' ':          /* ignore whitespace */\n    case '\\t':\n    case '\\n':\n    case '\\r':\n    case '\\f':\n    case '\\v':\n      continue;\n\n    case '=':          /* attribuicao */\n      return IUPLEX_TK_SET;\n\n    case ',':\n      return IUPLEX_TK_COMMA;\n\n    case '\\\"':          /* string */\n      iAttribCapture(env_buffer, \"\\\"\");\n      return IUPLEX_TK_NAME;\n\n    default:\n      if (c > 32)          /* identifier */\n      {\n        --env_str;                     /* unget first character of env_buffer */\n        iAttribCapture(env_buffer, \"=, \\t\\n\\r\\f\\v\"); /* get env_buffer until delimiter */\n        --env_str;                     /* unget delimiter */\n        return IUPLEX_TK_NAME;\n      }\n    }\n  }\n}\n\nstatic void iAttribParse(Ihandle *ih, const char* str)\n{\n  char env_buffer[256];\n  char* name=NULL;\n  char* value=NULL;\n  char state = 'a';               /* get attribute */\n  int end = 0;\n\n  env_str = str;\n\n  for (;;)\n  {\n    switch (iAttribToken(env_buffer))\n    {\n    case IUPLEX_TK_END:           /* same as IUPLEX_TK_COMMA */\n      end = 1;\n    case IUPLEX_TK_COMMA:\n      if (name)\n      {\n        IupStoreAttribute(ih, name, value);\n        free(name);\n      }\n      if (end)\n        return;\n      name = value = NULL;\n      state = 'a';\n      break;\n\n    case IUPLEX_TK_SET:\n      state = 'v';                /* get value */\n      break;\n\n    case IUPLEX_TK_NAME:\n      if (state == 'a')\n        name = iupStrDup(env_buffer);\n      else\n        value = env_buffer;\n      break;\n    }\n  }\n}\n\nIhandle* IupSetAttributes(Ihandle *ih, const char* str)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return ih;\n  if (str)\n    iAttribParse(ih, str);\n  return ih;\n}\n\nint iupAttribIsNotString(Ihandle* ih, const char* name)\n{\n  return iupClassObjectAttribIsNotString(ih, name);\n}\n\nint iupAttribIsIhandle(Ihandle* ih, const char* name)\n{\n  return iupClassObjectAttribIsIhandle(ih, name);\n}\n\ntypedef int (*Iconvertxytopos)(Ihandle* ih, int x, int y);\n\nint IupConvertXYToPos(Ihandle* ih, int x, int y)\n{\n  Iconvertxytopos drvConvertXYToPos;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return -1;\n\n  if (!ih->handle)\n    return -1;\n\n  drvConvertXYToPos = (Iconvertxytopos)IupGetCallback(ih, \"_IUP_XY2POS_CB\");\n  if (drvConvertXYToPos)\n    return drvConvertXYToPos(ih, x, y);\n\n  return -1;\n}\n","/** \\file\n * \\brief IupBackgroundBox control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_register.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_drv.h\"\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\nstatic char* iBackgroundBoxGetBgColorAttrib(Ihandle* ih)\n{\n  if (iupAttribGet(ih, \"BGCOLOR\"))\n    return NULL;  /* get from the hash table */\n  else\n    return iupBaseNativeParentGetBgColorAttrib(ih);\n}\n\nstatic int iBackgroundBoxSetBgColorAttrib(Ihandle* ih, const char* value)\n{\n  (void)value;\n  IupUpdate(ih); /* post a redraw */\n  return 1;  /* save on the hash table */\n}\n\nstatic int iBackgroundBoxGetBorder(Ihandle* ih)\n{\n  if (iupAttribGetBoolean(ih, \"BORDER\"))\n    return 1;\n  else\n    return 0;\n}\n\nstatic char* iBackgroundBoxGetClientOffsetAttrib(Ihandle* ih)\n{\n  int dx = 0, dy = 0;\n  if (iupAttribGetBoolean(ih, \"BORDER\"))\n  {\n    dx = 1;\n    dy = 1;\n  }\n  return iupStrReturnIntInt(dx, dy, 'x');\n}\n\nstatic void iBackgroundBoxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  if (ih->firstchild)\n  {\n    int border = iBackgroundBoxGetBorder(ih);\n\n    iupBaseComputeNaturalSize(ih->firstchild);\n\n    *children_expand = ih->firstchild->expand;\n    *w = ih->firstchild->naturalwidth + 2*border;\n    *h = ih->firstchild->naturalheight + 2*border;\n  }\n}\n\nstatic void iBackgroundBoxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  if (ih->firstchild)\n  {\n    int border = iBackgroundBoxGetBorder(ih);\n    int width  = (ih->currentwidth  > border ? ih->currentwidth  - border : 0);\n    int height = (ih->currentheight > border ? ih->currentheight - border : 0);\n    iupBaseSetCurrentSize(ih->firstchild, width, height, shrink);\n  }\n}\n\nstatic void iBackgroundBoxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild)\n  {\n    char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n    /* Native container, position is reset */\n    x = 0;\n    y = 0;\n\n    if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n}\n\nstatic int iBackgroundBoxCreateMethod(Ihandle* ih, void** params)\n{\n  IupSetAttribute(ih, \"CANFOCUS\", \"NO\");\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (iparams[0]) IupAppend(ih, iparams[0]);\n  }\n\n  return IUP_NOERROR;\n}\n\nIclass* iupBackgroundBoxNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"canvas\"));\n\n  ic->name   = \"backgroundbox\";\n  ic->format = \"h\";   /* one Ihandle* */\n  ic->nativetype = IUP_TYPECANVAS;\n  ic->childtype  = IUP_CHILDMANY+1;  /* 1 child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupBackgroundBoxNewClass;\n  ic->Create  = iBackgroundBoxCreateMethod;\n\n  ic->ComputeNaturalSize = iBackgroundBoxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iBackgroundBoxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iBackgroundBoxSetChildrenPositionMethod;\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iBackgroundBoxGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n  {\n    IattribGetFunc drawsize_get = NULL;\n    iupClassRegisterGetAttribute(ic, \"DRAWSIZE\", &drawsize_get, NULL, NULL, NULL, NULL);\n    iupClassRegisterAttribute(ic, \"CLIENTSIZE\", drawsize_get, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  }\n\n  /* Native Container */\n  iupClassRegisterAttribute(ic, \"CHILDOFFSET\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  /* replace IupCanvas behavior */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", iBackgroundBoxGetBgColorAttrib, iBackgroundBoxSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_NO_SAVE | IUPAF_DEFAULT);\n  iupClassRegisterReplaceAttribDef  (ic, \"BORDER\", \"NO\", NULL);\n  iupClassRegisterReplaceAttribFlags(ic, \"BORDER\", IUPAF_NO_INHERIT);\n  iupClassRegisterReplaceAttribDef  (ic, \"SCROLLBAR\", \"NO\", NULL);\n\n  return ic;\n}\n\nIhandle* IupBackgroundBox(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"backgroundbox\", children);\n}\n","/** \\file\n * \\brief Base for box Controls.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_box.h\"\n#include \"iup_normalizer.h\"\n\n\nstatic char* iBoxGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  width -= 2*ih->data->margin_x;\n  height -= 2*ih->data->margin_y;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iBoxSetCGapAttrib(Ihandle* ih, const char* value)\n{\n  int cgap;\n  iupStrToInt(value, &cgap);\n  if (IupClassMatch(ih, \"vbox\"))\n  {\n    int charheight;\n    iupdrvFontGetCharSize(ih, NULL, &charheight);\n    ih->data->gap = iupHEIGHT2RASTER(cgap, charheight);\n  }\n  else\n  {\n    int charwidth;\n    iupdrvFontGetCharSize(ih, &charwidth, NULL);\n    ih->data->gap = iupWIDTH2RASTER(cgap, charwidth);\n  }\n  return 0;\n}\n\nstatic char* iBoxGetCGapAttrib(Ihandle* ih)\n{\n  if (IupClassMatch(ih, \"vbox\"))\n  {\n    int charheight;\n    iupdrvFontGetCharSize(ih, NULL, &charheight);\n    return iupStrReturnInt(iupRASTER2HEIGHT(ih->data->gap, charheight));\n  }\n  else\n  {\n    int charwidth;\n    iupdrvFontGetCharSize(ih, &charwidth, NULL);\n    return iupStrReturnInt(iupRASTER2WIDTH(ih->data->gap, charwidth));\n  }\n}\n\nstatic int iBoxSetGapAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->gap);\n  return 0;\n}\n\nstatic char* iBoxGetGapAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->gap);\n}\n\nstatic int iBoxSetHomogeneousAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->is_homogeneous = 1;\n  else\n    ih->data->is_homogeneous = 0;\n  return 0;\n}\n\nstatic char* iBoxGetHomogeneousAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_homogeneous); \n}\n\nstatic int iBoxSetExpandChildrenAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n  {\n    if (IupClassMatch(ih, \"vbox\"))\n      ih->data->expand_children = IUP_EXPAND_WIDTH;    /* in vert. box, expand horizontally */\n    else\n      ih->data->expand_children = IUP_EXPAND_HEIGHT;   /* in horiz. box, expand vertically */\n  }\n  else\n    ih->data->expand_children = 0;\n  return 0;\n}\n\nstatic char* iBoxGetExpandChildrenAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->expand_children); \n}\n\nstatic int iBoxSetNormalizeSizeAttrib(Ihandle* ih, const char* value)\n{\n  ih->data->normalize_size = iupNormalizeGetNormalizeSize(value);\n  return 0;\n}\n\nstatic char* iBoxGetNormalizeSizeAttrib(Ihandle* ih)\n{\n  return iupNormalizeGetNormalizeSizeStr(ih->data->normalize_size);\n}\n\nstatic int iBoxSetCMarginAttrib(Ihandle* ih, const char* value)\n{\n  int cmargin_x=-1, cmargin_y=-1;\n  int charwidth, charheight;\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  iupStrToIntInt(value, &cmargin_x, &cmargin_y, 'x');\n  if (cmargin_x!=-1)\n    ih->data->margin_x = iupWIDTH2RASTER(cmargin_x, charwidth);\n  if (cmargin_y!=-1)\n    ih->data->margin_y = iupHEIGHT2RASTER(cmargin_y, charheight);\n  return 0;\n}\n\nstatic char* iBoxGetCMarginAttrib(Ihandle* ih)\n{\n  int charwidth, charheight;\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  return iupStrReturnIntInt(iupRASTER2WIDTH(ih->data->margin_x, charwidth), iupRASTER2HEIGHT(ih->data->margin_y, charheight), 'x');\n}\n\nstatic int iBoxSetMarginAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToIntInt(value, &ih->data->margin_x, &ih->data->margin_y, 'x');\n  return 0;\n}\n\nstatic char* iBoxGetMarginAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->margin_x, ih->data->margin_y, 'x');\n}\n\nstatic int iBoxUpdateAttribFromFont(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"CMARGIN\");\n  if (!value)\n    value = iupAttribGet(ih, \"NCMARGIN\");\n  if (value)\n    iBoxSetCMarginAttrib(ih, value);\n\n  value = iupAttribGet(ih, \"CGAP\");\n  if (!value)\n    value = iupAttribGet(ih, \"NCGAP\");\n  if (value)\n    iBoxSetCGapAttrib(ih, value);\n\n  return 0;\n}\n\n\n/******************************************************************************/\n\nstatic int iBoxCreateMethod(Ihandle* ih, void** params)\n{\n  ih->data = iupALLOCCTRLDATA();\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams)\n    {\n      IupAppend(ih, *iparams);\n      iparams++;\n    }\n  }\n\n  IupSetCallback(ih, \"UPDATEATTRIBFROMFONT\", iBoxUpdateAttribFromFont);\n\n  return IUP_NOERROR;\n}\n\nIclass* iupBoxNewClassBase(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupBoxNewClassBase;\n  ic->Create = iBoxCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iBoxGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* boxes only */\n  iupClassRegisterAttribute(ic, \"GAP\", iBoxGetGapAttrib, iBoxSetGapAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CGAP\", iBoxGetCGapAttrib, iBoxSetCGapAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"NGAP\", iBoxGetGapAttrib, iBoxSetGapAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NCGAP\", iBoxGetCGapAttrib, iBoxSetCGapAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MARGIN\", iBoxGetMarginAttrib, iBoxSetMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CMARGIN\", iBoxGetCMarginAttrib, iBoxSetCMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"NMARGIN\", iBoxGetMarginAttrib, iBoxSetMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NCMARGIN\", iBoxGetCMarginAttrib, iBoxSetCMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"EXPANDCHILDREN\", iBoxGetExpandChildrenAttrib, iBoxSetExpandChildrenAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HOMOGENEOUS\", iBoxGetHomogeneousAttrib, iBoxSetHomogeneousAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NORMALIZESIZE\", iBoxGetNormalizeSizeAttrib, iBoxSetNormalizeSizeAttrib, IUPAF_SAMEASSYSTEM, \"NONE\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Button Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_button.h\"\n#include \"iup_image.h\"\n\n\nchar* iupButtonGetPaddingAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n}\n\nstatic int iButtonSetImagePositionAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)  /* set only before map */\n  {\n    if (iupStrEqualNoCase(value, \"RIGHT\"))\n      ih->data->img_position = IUP_IMGPOS_RIGHT;\n    else if (iupStrEqualNoCase(value, \"BOTTOM\"))\n      ih->data->img_position = IUP_IMGPOS_BOTTOM;\n    else if (iupStrEqualNoCase(value, \"TOP\"))\n      ih->data->img_position = IUP_IMGPOS_TOP;\n    else /* \"LEFT\" */\n      ih->data->img_position = IUP_IMGPOS_LEFT;\n  }\n  return 0;\n}\n\nstatic char* iButtonGetImagePositionAttrib(Ihandle *ih)\n{\n  char* img_pos2str[4] = {\"LEFT\", \"RIGHT\", \"TOP\", \"BOTTOM\"};\n  return iupStrReturnStr(img_pos2str[ih->data->img_position]);\n}\n\nstatic int iButtonSetFocusOnClickAttrib(Ihandle* ih, const char* value)\n{\n  iupAttribSet(ih, \"CANFOCUS\", value);\n  return 1;\n}\n\nstatic int iButtonSetSpacingAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)  /* set only before map */\n    iupStrToInt(value, &ih->data->spacing);\n  return 0;\n}\n\nstatic char* iButtonGetSpacingAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->data->spacing);\n}\n\n\n/*****************************************************************************************/\n\n\nstatic int iButtonCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n    if (params[1]) iupAttribSetStr(ih, \"ACTION\", (char*)(params[1]));\n  }\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->spacing = 2;\n\n  /* used only by the Windows driver */\n  ih->data->horiz_alignment = IUP_ALIGN_ACENTER;\n  ih->data->vert_alignment = IUP_ALIGN_ACENTER;\n  return IUP_NOERROR;\n}\n\nstatic void iButtonComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0, \n      type = ih->data->type;\n  (void)children_expand; /* unset if not a container */\n\n  if (!ih->handle)\n  {\n    /* if not mapped must initialize the internal values */\n    char* value = iupAttribGet(ih, \"IMAGE\");\n    if (value)\n    {\n      char* title = iupAttribGet(ih, \"TITLE\");\n      type = IUP_BUTTON_IMAGE;\n      if (title && *title!=0)\n        type |= IUP_BUTTON_TEXT;\n    }\n    else\n      type = IUP_BUTTON_TEXT;\n  }\n\n  if (type & IUP_BUTTON_IMAGE)\n  {\n    iupImageGetInfo(iupAttribGet(ih, \"IMAGE\"), &natural_w, &natural_h, NULL);\n\n    if (type & IUP_BUTTON_TEXT)\n    {\n      int text_w, text_h;\n      /* must use IupGetAttribute to check from the native implementation */\n      char* title = IupGetAttribute(ih, \"TITLE\");\n      iupdrvFontGetMultiLineStringSize(ih, title, &text_w, &text_h);\n\n      if (ih->data->img_position == IUP_IMGPOS_RIGHT ||\n          ih->data->img_position == IUP_IMGPOS_LEFT)\n      {\n        natural_w += text_w + ih->data->spacing;\n        natural_h = iupMAX(natural_h, text_h);\n      }\n      else\n      {\n        natural_w = iupMAX(natural_w, text_w);\n        natural_h += text_h + ih->data->spacing;\n      }\n    }\n  }\n  else /* IUP_BUTTON_TEXT only */\n  {\n    /* must use IupGetAttribute to check from the native implementation */\n    char* title = IupGetAttribute(ih, \"TITLE\");\n    char* str = iupStrProcessMnemonic(title, NULL, 0);   /* remove & */\n    iupdrvFontGetMultiLineStringSize(ih, str, &natural_w, &natural_h);\n    if (str && str!=title) free(str);\n  }\n\n  /* if IMPRESS is set, do NOT compute the borders space */\n  if (!((type == IUP_BUTTON_IMAGE) &&\n        iupAttribGet(ih, \"IMPRESS\") && \n        !iupAttribGetBoolean(ih, \"IMPRESSBORDER\")))\n    iupdrvButtonAddBorders(&natural_w, &natural_h);\n\n  natural_w += 2*ih->data->horiz_padding;\n  natural_h += 2*ih->data->vert_padding;\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupButton(const char* title, const char* action)\n{\n  void *params[3];\n  params[0] = (void*)title;\n  params[1] = (void*)action;\n  params[2] = NULL;\n  return IupCreatev(\"button\", params);\n}\n\nIclass* iupButtonNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"button\";\n  ic->format = \"sa\"; /* one string, and one ACTION callback name */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupButtonNewClass;\n  ic->Create = iButtonCreateMethod;\n  ic->ComputeNaturalSize = iButtonComputeNaturalSizeMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"ACTION\", \"\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* IupButton only */\n  iupClassRegisterAttribute(ic, \"SPACING\", iButtonGetSpacingAttrib, iButtonSetSpacingAttrib, IUPAF_SAMEASSYSTEM, \"2\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEPOSITION\", iButtonGetImagePositionAttrib, iButtonSetImagePositionAttrib, IUPAF_SAMEASSYSTEM, \"LEFT\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMPRESSBORDER\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FLAT\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"FOCUSONCLICK\", NULL, iButtonSetFocusOnClickAttrib, \"YES\", NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvButtonInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief get/set callback\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h> \n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_assert.h\"\n\n  \nchar* iupGetCallbackName(Ihandle *ih, const char *name)\n{\n  void* value;\n  Icallback func = (Icallback)iupTableGetFunc(ih->attrib, name, &value);\n\n  if (!func && value)\n  {\n    /* if not a IUPTABLE_FUNCPOINTER then it is an old fashion name */\n    func = IupGetFunction((const char*)value);\n    if (func)\n      return value;\n  }\n  return NULL;\n}\n\nIcallback IupGetCallback(Ihandle *ih, const char *name)\n{\n  Icallback func = NULL;\n  void* value;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  iupASSERT(name!=NULL);\n  if (!name) \n    return NULL;\n\n  func = (Icallback)iupTableGetFunc(ih->attrib, name, &value);\n\n  if (!func && value)\n  {\n    /* if not a IUPTABLE_FUNCPOINTER then it is an old fashion name */\n    func = IupGetFunction((const char*)value);\n  }\n\n  return func;\n}\n\nIcallback IupSetCallback(Ihandle *ih, const char *name, Icallback func)\n{\n  Icallback old_func = NULL;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  iupASSERT(name!=NULL);\n  if (!name) \n    return NULL;\n\n  if (!func)\n    iupTableRemove(ih->attrib, name);\n  else\n  {\n    void* value;\n    old_func = (Icallback)iupTableGetFunc(ih->attrib, name, &value);\n    if (!old_func && value)\n      old_func = IupGetFunction((const char*)value);\n\n    iupTableSetFunc(ih->attrib, name, (Ifunc)func);\n  }\n\n  return old_func;\n}\n\nIhandle* IupSetCallbacks(Ihandle* ih, const char *name, Icallback func, ...)\n{\n  va_list arglist;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  IupSetCallback(ih, name, func);\n\n  va_start(arglist, func);\n\n  name=va_arg(arglist, const char*);\n  while (name)\n  {\n    func=va_arg(arglist, Icallback);\n    IupSetCallback(ih, name, func);\n\n    name=va_arg(arglist, const char*);\n  } \n\n  va_end (arglist);\n  return ih;\n}\n","/** \\file\n * \\brief Canvas Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_canvas.h\"\n\n\nvoid iupCanvasCalcScrollIntPos(double min, double max, double page, double pos, \n                                 int imin,   int imax,  int *ipage,  int *ipos)\n{\n  double range = max-min;\n  int irange = imax-imin;\n  double ratio = ((double)irange)/range;\n\n  *ipage = (int)(page*ratio);\n  if (*ipage > irange) *ipage = irange;\n  if (*ipage < 1) *ipage = 1;\n\n  if (ipos)\n  {\n    *ipos = (int)((pos-min)*ratio) + imin;\n    if (*ipos < imin) *ipos = imin;\n    if (*ipos > (imax - *ipage)) *ipos = imax - *ipage;\n  }\n}\n\nvoid iupCanvasCalcScrollRealPos(double min, double max, double *pos, \n                                 int imin,   int imax,  int ipage,  int *ipos)\n{\n  double range = max-min;\n  int irange = imax-imin;\n  double ratio = ((double)irange)/range;\n\n  if (*ipos < imin) *ipos = imin;\n  if (*ipos > (imax - ipage)) *ipos = imax - ipage;\n\n  *pos = min + ((double)(*ipos-imin))/ratio;\n}\n\nchar* iupCanvasGetPosXAttrib(Ihandle* ih)\n{\n  return iupStrReturnFloat(ih->data->posx);\n}\n\nchar* iupCanvasGetPosYAttrib(Ihandle* ih)\n{\n  return iupStrReturnFloat(ih->data->posy);\n}\n\nstatic int iCanvasCreateMethod(Ihandle* ih, void** params)\n{\n  if (params && params[0])\n  {\n    char* action = (char*)params[0];\n    iupAttribSetStr(ih, \"ACTION\", action);\n  }\n\n  ih->data = iupALLOCCTRLDATA();\n\n  /* default EXPAND is YES */\n  ih->expand = IUP_EXPAND_BOTH;\n  \n  return IUP_NOERROR;\n}\n\nstatic void iCanvasComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, natural_h = 0;\n  (void)children_expand; /* unset if not a container */\n\n  /* canvas natural size is 1 character */\n  iupdrvFontGetCharSize(ih, &natural_w, &natural_h);\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupCanvas(const char* action)\n{\n  void *params[2];\n  params[0] = (void*)action;\n  params[1] = NULL;\n  return IupCreatev(\"canvas\", params);\n}\n\nIclass* iupCanvasNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"canvas\";\n  ic->format = \"a\"; /* one ACTION callback name */\n  ic->nativetype = IUP_TYPECANVAS;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupCanvasNewClass;\n  ic->Create = iCanvasCreateMethod;\n  ic->ComputeNaturalSize = iCanvasComputeNaturalSizeMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"RESIZE_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"FOCUS_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"WOM_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"MOTION_CB\", \"iis\");\n  iupClassRegisterCallback(ic, \"KEYPRESS_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"ACTION\", \"ff\");\n  iupClassRegisterCallback(ic, \"SCROLL_CB\", \"iff\");\n  iupClassRegisterCallback(ic, \"WHEEL_CB\", \"fiis\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Change the default to YES */\n  iupClassRegisterReplaceAttribDef(ic, \"EXPAND\", IUPAF_SAMEASSYSTEM, \"YES\");\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* IupCanvas only */\n  iupClassRegisterAttribute(ic, \"CURSOR\", NULL, iupdrvBaseSetCursorAttrib, IUPAF_SAMEASSYSTEM, \"ARROW\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"XMIN\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"XMAX\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"YMIN\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"YMAX\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LINEX\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LINEY\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"YAUTOHIDE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"XAUTOHIDE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"XHIDDEN\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"YHIDDEN\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BORDER\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"SCROLLBAR\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupdrvCanvasInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief cbox control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n\n\nstatic int iCboxCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams) \n    {\n      IupAppend(ih, *iparams);\n      iparams++;\n    }\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iCboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int children_naturalwidth, children_naturalheight;\n  int cx, cy;\n\n  /* calculate total children natural size (even for hidden children) */\n  children_naturalwidth = 0;\n  children_naturalheight = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    cx = iupAttribGetInt(child, \"CX\");\n    cy = iupAttribGetInt(child, \"CY\");\n\n    *children_expand |= child->expand;\n    children_naturalwidth = iupMAX(children_naturalwidth, cx+child->naturalwidth);\n    children_naturalheight = iupMAX(children_naturalheight, cy+child->naturalheight);\n  }\n\n  *w = children_naturalwidth;\n  *h = children_naturalheight;\n}\n\nstatic void iCboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    /* update children to their own natural size */\n    iupBaseSetCurrentSize(child, child->naturalwidth, child->naturalheight, shrink);\n  }\n}\n\nstatic void iCboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int cx, cy;\n  Ihandle* child;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    cx = iupAttribGetInt(child, \"CX\");\n    cy = iupAttribGetInt(child, \"CY\");\n\n    /* update child */\n    iupBaseSetPosition(child, x+cx, y+cy);\n  }\n}\n\n\n/******************************************************************************/\n\n\nIhandle *IupCboxv(Ihandle** children)\n{\n  return IupCreatev(\"cbox\", (void**)children);\n}\n\nIhandle *IupCbox (Ihandle * child,...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"cbox\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIclass* iupCboxNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"cbox\";\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupCboxNewClass;\n  ic->Create = iCboxCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n\n  ic->ComputeNaturalSize = iCboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iCboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iCboxSetChildrenPositionMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iupBaseGetCurrentSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Control tree hierarchy manager.  \n * implements also IupDestroy\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h> \n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_dlglist.h\"\n#include \"iup_childtree.h\"\n#include \"iup_class.h\"\n#include \"iup_attrib.h\" \n#include \"iup_assert.h\" \n#include \"iup_str.h\" \n#include \"iup_drv.h\" \n\n\nIhandle* IupGetDialog(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  for (ih = ih; ih->parent; ih = ih->parent)\n    ; /* empty*/\n\n  if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n    return ih;\n  else if (ih->iclass->nativetype == IUP_TYPEMENU)\n  {\n    Ihandle *dlg;\n    /* if ih is a menu then */\n    /* searches all the dialogs that may have been associated with the menu. */\n    for (dlg = iupDlgListFirst(); dlg; dlg = iupDlgListNext())\n    {\n      if (IupGetAttributeHandle(dlg, \"MENU\") == ih)\n        return dlg;\n    }\n  }\n\n  return NULL;\n}\n\nstatic void iChildDetach(Ihandle* parent, Ihandle* child)\n{\n  Ihandle *c, \n          *c_prev = NULL;\n\n  /* Removes the child entry inside the parent's child list */\n  for (c = parent->firstchild; c; c = c->brother)\n  {\n    if (c == child) /* Found the right child */\n    {\n      if (c_prev == NULL)\n        parent->firstchild = child->brother;\n      else\n        c_prev->brother = child->brother;\n        \n      child->brother = NULL;\n      child->parent = NULL;\n      return;\n    }\n\n    c_prev = c;\n  }\n}\n\nvoid IupDetach(Ihandle *child)\n{\n  Ihandle *parent, *top_parent;\n  int pos;\n\n  iupASSERT(iupObjectCheck(child));\n  if (!iupObjectCheck(child))\n    return;\n\n  IupUnmap(child);\n\n  /* Not valid if does NOT has a parent */\n  if (!child->parent)\n    return;\n\n  parent = child->parent;\n  top_parent = iupChildTreeGetNativeParent(child);\n\n  pos = IupGetChildPos(parent, child);\n\n  iChildDetach(parent, child);\n  iupClassObjectChildRemoved(parent, child, pos);\n\n  /* notify also internal parents up to the native parent \n     TODO: this is weird, do we still need it? */\n  while (parent && parent != top_parent)\n  {\n    parent = parent->parent;\n    if (parent)\n      iupClassObjectChildRemoved(parent, child, pos);\n  }\n}\n\n#ifdef IUP_ASSERT\nstatic int iChildFindRec(Ihandle* parent, Ihandle* child)\n{\n  Ihandle *c;\n\n  /* Finds the reference child entry inside the parent's child list */\n  for (c = parent->firstchild; c; c = c->brother)\n  {\n    if (c == child) /* Found the right child */\n      return 1;\n\n    if (iChildFindRec(c, child))\n      return 1;\n  }\n\n  return 0;\n}\n\nstatic int iChildTreeCheckInside(Ihandle* parent, Ihandle* child)\n{\n  /* top parent */\n  while (parent->parent)\n    parent = parent->parent;\n\n  return iChildFindRec(parent, child);\n}\n#endif\n\nstatic int iChildFind(Ihandle* parent, Ihandle* child)\n{\n  Ihandle *c;\n\n  /* Finds the reference child entry inside the parent's child list */\n  for (c = parent->firstchild; c; c = c->brother)\n  {\n    if (c == child) /* Found the right child */\n      return 1;\n  }\n\n  return 0;\n}\n\nstatic void iupChildTreeInsert(Ihandle* parent, Ihandle* ref_child, Ihandle* child)\n{\n  Ihandle *c, \n          *c_prev = NULL;\n\n  if (parent->firstchild == NULL)\n  {\n    parent->firstchild = child;\n    child->parent = parent;\n    return;\n  }\n\n  if (!ref_child)\n    ref_child = parent->firstchild;\n\n  /* Finds the reference child entry inside the parent's child list */\n  for (c = parent->firstchild; c; c = c->brother)\n  {\n    if (c == ref_child) /* Found the right child */\n    {\n      child->parent = parent;\n      child->brother = ref_child;\n\n      if (c_prev == NULL)\n        parent->firstchild = child;\n      else\n        c_prev->brother = child;\n\n      return;\n    }\n\n    c_prev = c;\n  }\n}\n\nstatic int iChildCount(Ihandle* ih)\n{\n  int num = 0;\n\n  ih = ih->firstchild;\n  while(ih)\n  {\n    num++;\n    ih = ih->brother;\n  }\n\n  return num;\n}\n\nIhandle* IupInsert(Ihandle* parent, Ihandle* ref_child, Ihandle* child)\n{\n  Ihandle* top_parent = parent;\n\n  /* ref_child can be NULL */\n\n  iupASSERT(iupObjectCheck(parent));\n  if (!iupObjectCheck(parent))\n    return NULL;\n\n  iupASSERT(iupObjectCheck(child));\n  if (!iupObjectCheck(child))\n    return NULL;\n\n#ifdef IUP_ASSERT\n  if (iChildTreeCheckInside(parent, child))\n  {\n    iupError(\"Duplicate Child Found!\\n(type(%s) - name(%s))\", child->iclass->name, IupGetName(child));\n    return NULL;\n  }\n#endif\n\n\n  /* this will return the actual parent */\n  parent = iupClassObjectGetInnerContainer(top_parent);\n  if (!parent)\n    return NULL;\n\n  if (parent->iclass->childtype == IUP_CHILDNONE)\n    return NULL;\n  if (parent->iclass->childtype > IUP_CHILDMANY && \n      iChildCount(parent) == parent->iclass->childtype-IUP_CHILDMANY)\n    return NULL;\n\n\n  /* if already at the parent box, allow to move even if mapped */\n  if (parent->iclass->nativetype == IUP_TYPEVOID &&\n      iChildFind(parent, child))\n  {\n    iChildDetach(parent, child);\n    iupChildTreeInsert(parent, ref_child, child);\n  }\n  else\n  {\n    /* Not valid if it is mapped */\n    if (child->handle)\n      return NULL;\n\n    iupChildTreeInsert(parent, ref_child, child);\n    iupClassObjectChildAdded(parent, child);\n    if (top_parent != parent)\n      iupClassObjectChildAdded(top_parent, child);\n  }\n\n  return parent;\n}\n\nvoid iupChildTreeAppend(Ihandle* parent, Ihandle* child)\n{\n  child->parent = parent;\n\n  if (parent->firstchild == NULL)\n    parent->firstchild = child;\n  else\n  {\n    Ihandle* c = parent->firstchild;\n    while (c->brother)\n      c = c->brother;\n    c->brother = child;\n  }\n}\n\nIhandle* IupAppend(Ihandle* parent, Ihandle* child)\n{\n  Ihandle* top_parent = parent;\n\n  iupASSERT(iupObjectCheck(parent));\n  if (!iupObjectCheck(parent))\n    return NULL;\n\n  iupASSERT(iupObjectCheck(child));\n  if (!iupObjectCheck(child))\n    return NULL;\n\n#ifdef IUP_ASSERT\n  if (iChildTreeCheckInside(parent, child))\n  {\n    iupError(\"Duplicate Child Found!\\n(type(%s) - name(%s))\", child->iclass->name, IupGetName(child));\n    return NULL;\n  }\n#endif\n\n  /* this will return the actual parent */\n  parent = iupClassObjectGetInnerContainer(top_parent);\n  if (!parent)\n    return NULL;\n\n  if (parent->iclass->childtype == IUP_CHILDNONE)\n    return NULL;\n  if (parent->iclass->childtype > IUP_CHILDMANY && \n      iChildCount(parent) == parent->iclass->childtype-IUP_CHILDMANY)\n    return NULL;\n\n\n  /* if already at the parent box, allow to move even if mapped */\n  if (parent->iclass->nativetype == IUP_TYPEVOID &&\n      iChildFind(parent, child))\n  {\n    iChildDetach(parent, child);\n    iupChildTreeAppend(parent, child);\n  }\n  else\n  {\n    /* Not valid if it is mapped */\n    if (child->handle)\n      return NULL;\n\n    iupChildTreeAppend(parent, child);\n    iupClassObjectChildAdded(parent, child);\n    if (top_parent != parent)\n      iupClassObjectChildAdded(top_parent, child);\n  }\n\n  return parent;\n}\n\nstatic void iChildReparent(Ihandle* child, Ihandle* new_parent)\n{\n  Ihandle *c;\n\n  /* Forward the reparent to all native children */\n\n  for (c = child->firstchild; c; c = c->brother)\n  {\n    if (c->iclass->nativetype != IUP_TYPEVOID)\n      iupdrvReparent(c);\n    else\n      iChildReparent(c, new_parent);\n  }\n}\n\nint IupReparent(Ihandle* child, Ihandle* parent, Ihandle* ref_child)\n{\n  Ihandle* top_parent = parent;\n  Ihandle* old_parent;\n  int pos;\n\n  iupASSERT(iupObjectCheck(parent));\n  if (!iupObjectCheck(parent))\n    return IUP_ERROR;\n\n  iupASSERT(iupObjectCheck(child));\n  if (!iupObjectCheck(child))\n    return IUP_ERROR;\n\n  if (ref_child)\n  {\n    /* can be NULL, but if not NULL must be a valid object */\n    iupASSERT(iupObjectCheck(ref_child));\n    if (!iupObjectCheck(ref_child))\n      return IUP_ERROR;\n  }\n\n  /* this will return the actual parent */\n  parent = iupClassObjectGetInnerContainer(top_parent);\n  if (!parent)\n    return IUP_ERROR;\n\n  if (parent->iclass->childtype == IUP_CHILDNONE)\n    return IUP_ERROR;\n  if (parent->iclass->childtype > IUP_CHILDMANY && \n      iChildCount(parent) == parent->iclass->childtype-IUP_CHILDMANY)\n    return IUP_ERROR;\n\n\n  /* both must be already mapped or both unmapped */\n  if ((!parent->handle &&  child->handle) ||\n      ( parent->handle && !child->handle))\n    return IUP_ERROR;\n\n\n  /* detach from old parent */\n  old_parent = child->parent;\n\n  pos = IupGetChildPos(old_parent, child);\n\n  iChildDetach(old_parent, child);\n  iupClassObjectChildRemoved(old_parent, child, pos);\n\n \n  /* attach to new parent */\n  if (ref_child)\n    iupChildTreeInsert(parent, ref_child, child);\n  else\n    iupChildTreeAppend(parent, child);\n  iupClassObjectChildAdded(parent, child);\n  if (top_parent != parent)\n    iupClassObjectChildAdded(top_parent, child);\n\n\n  /* no need to remap, just notify the native system */\n  if (child->handle && parent->handle)\n  {\n    if (child->iclass->nativetype != IUP_TYPEVOID)\n      iupdrvReparent(child);\n    else\n      iChildReparent(child, parent);\n  }\n\n  return IUP_NOERROR;\n}\n\nIhandle* IupGetChild(Ihandle* ih, int pos)\n{\n  int p;\n  Ihandle* child;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  for (p = 0, child = ih->firstchild; child; child = child->brother, p++)\n  {\n    if (p == pos)\n      return child;\n  }\n\n  return NULL;\n}\n\nint IupGetChildPos(Ihandle* ih, Ihandle* child)\n{\n  int pos;\n  Ihandle* c;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return -1;\n\n  for (pos = 0, c = ih->firstchild; c; c = c->brother, pos++)\n  {\n    if (c == child)\n      return pos;\n  }\n  return -1;\n}\n\nIhandle* iupChildTreeGetPrevBrother(Ihandle* ih)\n{\n  Ihandle *c, *prev = NULL;\n\n  for (c = ih->parent->firstchild; c; c = c->brother)\n  {\n    if (c == ih)\n      return prev;\n\n    prev = c;\n  }\n\n  return NULL;\n}\n\nint IupGetChildCount(Ihandle* ih)\n{\n  int count = 0;\n  Ihandle* child;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return -1;\n\n  for (child = ih->firstchild; child; child = child->brother)\n    count++;\n\n  return count;\n}\n\nIhandle* IupGetNextChild(Ihandle* ih, Ihandle* child)\n{\n  if (!child)\n  {\n    iupASSERT(iupObjectCheck(ih));\n    if (!iupObjectCheck(ih))\n      return NULL;\n\n    return ih->firstchild;\n  }\n  else\n  {\n    iupASSERT(iupObjectCheck(child));\n    if (!iupObjectCheck(child))\n      return NULL;\n\n    return child->brother;\n  }\n}\n\nIhandle* IupGetBrother(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  return ih->brother;\n}\n\nIhandle* IupGetParent(Ihandle *ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n    \n  return ih->parent;\n}\n\nint iupChildTreeIsChild(Ihandle* ih, Ihandle* child)\n{\n  Ihandle* parent;\n\n  if (ih == child)\n    return 1;\n\n  parent = child->parent;\n  while (parent)\n  {\n    if (parent == ih)\n      return 1;\n    parent = parent->parent;\n  }\n\n  return 0;\n}\n\nIhandle* iupChildTreeGetNativeParent(Ihandle* ih)\n{\n  Ihandle* parent = ih->parent;\n  while (parent && parent->iclass->nativetype == IUP_TYPEVOID)\n    parent = parent->parent;\n  return parent;\n}\n\nInativeHandle* iupChildTreeGetNativeParentHandle(Ihandle* ih)\n{\n  Ihandle* native_parent = iupChildTreeGetNativeParent(ih);\n  return (InativeHandle*)iupClassObjectGetInnerNativeContainerHandle(native_parent, ih);\n}\n","/** \\file\n * \\brief IUP Ihandle Class C Interface\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_str.h\"\n#include \"iup_attrib.h\"\n#include \"iup_assert.h\"\n\n\n\n/*****************************************************************\n                        Method Stubs\n*****************************************************************/\n\nstatic int iClassCreate(Iclass* ic, Ihandle* ih, void** params)\n{\n  int ret = IUP_NOERROR;\n  if (ic->parent)\n    ret = iClassCreate(ic->parent, ih, params);\n\n  if (ret == IUP_NOERROR && ic->Create)\n    ret = ic->Create(ih, params);\n\n  return ret;\n}\n\nstatic int iClassMap(Iclass* ic, Ihandle* ih)\n{\n  int ret = IUP_NOERROR;\n  if (ic->parent)\n    ret = iClassMap(ic->parent, ih);\n\n  if (ret == IUP_NOERROR && ic->Map)\n    ret = ic->Map(ih);\n\n  return ret;\n}\n\nstatic void iClassUnMap(Iclass* ic, Ihandle* ih)\n{\n  /* must be before the parent class */\n  if (ic->UnMap)\n    ic->UnMap(ih);\n\n  if (ic->parent)\n    iClassUnMap(ic->parent, ih);\n}\n\nstatic void iClassDestroy(Iclass* ic, Ihandle* ih)\n{\n  /* must destroy child class before the parent class */\n  if (ic->Destroy)\n    ic->Destroy(ih);\n\n  if (ic->parent)\n    iClassDestroy(ic->parent, ih);\n}\n\nstatic void iClassComputeNaturalSize(Iclass* ic, Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  if (ic->parent)\n    iClassComputeNaturalSize(ic->parent, ih, w, h, children_expand);\n\n  if (ic->ComputeNaturalSize)\n    ic->ComputeNaturalSize(ih, w, h, children_expand);\n}\n\nstatic void iClassSetChildrenCurrentSize(Iclass* ic, Ihandle* ih, int shrink)\n{\n  if (ic->parent)\n    iClassSetChildrenCurrentSize(ic->parent, ih, shrink);\n\n  if (ic->SetChildrenCurrentSize)\n    ic->SetChildrenCurrentSize(ih, shrink);\n}\n\nstatic void iClassSetChildrenPosition(Iclass* ic, Ihandle* ih, int x, int y)\n{\n  if (ic->parent)\n    iClassSetChildrenPosition(ic->parent, ih, x, y);\n\n  if (ic->SetChildrenPosition)\n    ic->SetChildrenPosition(ih, x, y);\n}\n\nstatic Ihandle* iClassGetInnerContainer(Iclass* ic, Ihandle* ih)\n{\n  Ihandle* ih_container = ih;\n\n  if (ic->parent)\n    ih_container = iClassGetInnerContainer(ic->parent, ih);\n\n  /* if the class implements the function it will ignore the result of the parent class */\n\n  if (ic->GetInnerContainer)\n    ih_container = ic->GetInnerContainer(ih);\n\n  return ih_container;\n}\n\nstatic void* iClassGetInnerNativeContainerHandle(Iclass* ic, Ihandle* ih, Ihandle* child)\n{\n  void* container_handle = ih->handle;\n\n  if (ic->parent)\n    container_handle = iClassGetInnerNativeContainerHandle(ic->parent, ih, child);\n\n  /* if the class implements the function it will ignore the result of the parent class */\n\n  if (ic->GetInnerNativeContainerHandle)\n    container_handle = ic->GetInnerNativeContainerHandle(ih, child);\n\n  return container_handle;\n}\n\nstatic void iClassObjectChildAdded(Iclass* ic, Ihandle* ih, Ihandle* child)\n{\n  if (ic->parent)\n    iClassObjectChildAdded(ic->parent, ih, child);\n\n  if (ic->ChildAdded)\n    ic->ChildAdded(ih, child);\n}\n\nstatic void iClassObjectChildRemoved(Iclass* ic, Ihandle* ih, Ihandle* child, int pos)\n{\n  if (ic->parent)\n    iClassObjectChildRemoved(ic->parent, ih, child, pos);\n\n  if (ic->ChildRemoved)\n    ic->ChildRemoved(ih, child, pos);\n}\n\nstatic void iClassLayoutUpdate(Iclass* ic, Ihandle *ih)\n{\n  if (ic->parent)\n    iClassLayoutUpdate(ic->parent, ih);\n\n  if (ic->LayoutUpdate)\n    ic->LayoutUpdate(ih);\n}\n\nstatic int iClassDlgPopup(Iclass* ic, Ihandle* ih, int x, int y)\n{\n  int ret = IUP_INVALID;  /* IUP_INVALID means it is not implemented */\n  if (ic->parent)\n    ret = iClassDlgPopup(ic->parent, ih, x, y);\n\n  if (ret != IUP_ERROR && ic->DlgPopup)\n    ret = ic->DlgPopup(ih, x, y);\n\n  return ret;\n}\n\nint iupClassObjectCreate(Ihandle* ih, void** params)\n{\n  return iClassCreate(ih->iclass, ih, params);\n}\n\nint iupClassObjectMap(Ihandle* ih)\n{\n  return iClassMap(ih->iclass, ih);\n}\n\nvoid iupClassObjectUnMap(Ihandle* ih)\n{\n  iClassUnMap(ih->iclass, ih);\n}\n\nvoid iupClassObjectDestroy(Ihandle* ih)\n{\n  iClassDestroy(ih->iclass, ih);\n}\n\nvoid iupClassObjectComputeNaturalSize(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  iClassComputeNaturalSize(ih->iclass, ih, w, h, children_expand);\n}\n\nvoid iupClassObjectSetChildrenCurrentSize(Ihandle* ih, int shrink)\n{\n  iClassSetChildrenCurrentSize(ih->iclass, ih, shrink);\n}\n\nvoid iupClassObjectSetChildrenPosition(Ihandle* ih, int x, int y)\n{\n  iClassSetChildrenPosition(ih->iclass, ih, x, y);\n}\n\nIhandle* iupClassObjectGetInnerContainer(Ihandle* ih)\n{\n  return iClassGetInnerContainer(ih->iclass, ih);\n}\n\nvoid* iupClassObjectGetInnerNativeContainerHandle(Ihandle* ih, Ihandle* child)\n{\n  return iClassGetInnerNativeContainerHandle(ih->iclass, ih, child);\n}\n\nvoid iupClassObjectChildAdded(Ihandle* ih, Ihandle* child)\n{\n  iClassObjectChildAdded(ih->iclass, ih, child);\n}\n\nvoid iupClassObjectChildRemoved(Ihandle* ih, Ihandle* child, int pos)\n{\n  iClassObjectChildRemoved(ih->iclass, ih, child, pos);\n}\n\nvoid iupClassObjectLayoutUpdate(Ihandle *ih)\n{\n  iClassLayoutUpdate(ih->iclass, ih);\n}\n\nint iupClassObjectDlgPopup(Ihandle* ih, int x, int y)\n{\n  return iClassDlgPopup(ih->iclass, ih, x, y);\n}\n\n\n/*****************************************************************\n                        Class Definition\n*****************************************************************/\n\n\nstatic void iClassReleaseAttribFuncTable(Iclass* ic)\n{\n  char* name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    void* afunc = iupTableGetCurr(ic->attrib_func);\n    free(afunc);\n\n    name = iupTableNext(ic->attrib_func);\n  }\n\n  iupTableDestroy(ic->attrib_func);\n}\n\nIclass* iupClassNew(Iclass* parent)\n{\n  Iclass* ic = malloc(sizeof(Iclass));\n  memset(ic, 0, sizeof(Iclass));\n\n  if (parent)\n  {\n    parent = parent->New();\n    ic->attrib_func = parent->attrib_func;\n    ic->parent = parent;\n  }\n  else\n    ic->attrib_func = iupTableCreate(IUPTABLE_STRINGINDEXED);\n\n  return ic;\n}\n\nvoid iupClassRelease(Iclass* ic)\n{\n  Iclass* parent;\n\n  /* must call Release only for the actual class */\n  if (ic->Release)\n    ic->Release(ic);\n\n  /* must free the pointer for all classes, \n     since a new instance is created when we inherit */\n  parent = ic->parent;\n  while (parent)\n  {\n    Iclass* ic_tmp = parent;\n    parent = parent->parent;\n    free(ic_tmp);\n  }\n\n  /* attributes functions table is released only once */\n  iClassReleaseAttribFuncTable(ic);\n\n  free(ic);\n}\n\nint iupClassMatch(Iclass* ic, const char* classname)\n{\n  while (ic)\n  {\n    if (iupStrEqualNoCase(ic->name, classname))\n      return 1;\n    ic = ic->parent;\n  }\n  return 0;\n}\n\n/*****************************************************************\n                        Main API\n*****************************************************************/\n\n\nchar* IupGetClassName(Ihandle *ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  return ih->iclass->name;\n}\n\nchar* IupGetClassType(Ihandle *ih)\n{\n  static char* type2str[] = {\"void\", \"control\", \"canvas\", \"dialog\", \"image\", \"menu\"};\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  return type2str[ih->iclass->nativetype];\n}\n\nint IupClassMatch(Ihandle* ih, const char* classname)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return 0;\n\n  return iupClassMatch(ih->iclass, classname);\n}\n","/** \\file\n * \\brief Ihandle Class Attribute Management\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_str.h\"\n#include \"iup_attrib.h\"\n#include \"iup_assert.h\"\n#include \"iup_register.h\"\n#include \"iup_globalattrib.h\"\n\n\ntypedef struct _IattribFunc\n{\n  IattribGetFunc get;\n  IattribSetFunc set;\n  const char* default_value;\n  const char* system_default;\n  int call_global_default;\n  int flags;\n} IattribFunc;\n\n\nint iupClassIsGlobalDefault(const char* name, int colors)\n{\n  if (!colors && iupStrEqual(name, \"DEFAULTFONT\"))\n    return 1;\n  if (iupStrEqual(name, \"DLGBGCOLOR\"))\n    return 1;\n  if (iupStrEqual(name, \"DLGFGCOLOR\"))\n    return 1;\n  if (iupStrEqual(name, \"TXTBGCOLOR\"))\n    return 1;\n  if (iupStrEqual(name, \"TXTFGCOLOR\"))\n    return 1;\n  if (iupStrEqual(name, \"LINKFGCOLOR\"))\n    return 1;\n  if (iupStrEqual(name, \"MENUBGCOLOR\"))\n    return 1;\n  return 0;\n}\n\n/* '*' is used in IupMatrix to indicate a full line or column\n   ':' is the regular separator for Lin:Col specification\n   '-' the minus sign, so we can specify negative values */\n#define IUP_CHECKIDSEP(_str) (*(_str) == '*' || *(_str) == ':' || *(_str) == '-')\n\nstatic const char* iClassFindId(const char* name)\n{\n  while(*name)\n  {\n    if (*name >= '0' && *name <= '9')\n      return name;\n    if (IUP_CHECKIDSEP(name))\n      return name;\n\n    name++;\n  }\n  return NULL;\n}\n\nstatic const char* iClassCutNameId(const char* name, const char* name_id)\n{\n  static char str[100];\n  int len = name_id - name;\n  if (len == 0)\n    return NULL;\n\n  memcpy(str, name, len);\n  str[len] = 0;\n  return str;\n}\n\n\nstatic char* iClassGetDefaultValue(IattribFunc* afunc)\n{\n  if (afunc->call_global_default)\n    return IupGetGlobal(afunc->default_value);\n  else\n    return (char*)afunc->default_value;\n}\n\nint iupClassObjectSetAttributeId2(Ihandle* ih, const char* name, int id1, int id2, const char* value)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id!=2)\n    return 1;  /* function not found, default to string */\n\n  if (name[0]==0)\n    name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                          translate them into IDVALUE. */\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc)\n  {         \n    if (afunc->flags & IUPAF_READONLY)\n    {\n      if (afunc->flags & IUPAF_NO_STRING)\n        return -1;  /* value is NOT a string, can NOT call iupAttribSetStr */\n      return 0;\n    }\n\n    if (afunc->set && \n        (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      /* id numbered attributes have default value NULL always */\n\n      if (afunc->flags & IUPAF_HAS_ID2)\n      {\n        IattribSetId2Func id2_set = (IattribSetId2Func)afunc->set;\n        return id2_set(ih, id1, id2, value);\n      }\n      else if (afunc->flags & IUPAF_HAS_ID)\n      {\n        IattribSetIdFunc id_set = (IattribSetIdFunc)afunc->set;\n        return id_set(ih, id1, value);  /* id2 is ignored */\n      }\n    }\n\n    if (afunc->flags & IUPAF_NO_STRING)\n      return -1; /* value is NOT a string, can NOT call iupAttribSetStr */\n  }\n\n  return 1;  /* function not found, default to string */\n}\n\nint iupClassObjectSetAttributeId(Ihandle* ih, const char* name, int id, const char * value)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id==0)\n    return 1;  /* function not found, default to string */\n\n  if (name[0]==0)\n    name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                          translate them into IDVALUE. */\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc && afunc->flags & IUPAF_HAS_ID)\n  {         \n    if (afunc->flags & IUPAF_READONLY)\n    {\n      if (afunc->flags & IUPAF_NO_STRING)\n        return -1;  /* value is NOT a string, can NOT call iupAttribSetStr */\n      return 0;\n    }\n\n    if (afunc->set && \n        !(afunc->flags & IUPAF_HAS_ID2) &&\n        (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      /* id numbered attributes have default value NULL always */\n      IattribSetIdFunc id_set = (IattribSetIdFunc)afunc->set;\n      return id_set(ih, id, value);\n    }\n\n    if (afunc->flags & IUPAF_NO_STRING)\n      return -1; /* value is NOT a string, can NOT call iupAttribSetStr */\n  }\n\n  return 1;  /* function not found, default to string */\n}\n\nint iupClassObjectSetAttribute(Ihandle* ih, const char* name, const char * value, int *inherit)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id!=0)\n  {\n    const char* name_id = iClassFindId(name);\n    if (name_id)\n    {\n      const char* partial_name = iClassCutNameId(name, name_id);\n      if (!partial_name)\n        partial_name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                                      translate them into IDVALUE. */\n      afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, partial_name);\n      if (afunc && afunc->flags & IUPAF_HAS_ID)\n      {         \n        *inherit = 0;       /* id numbered attributes are NON inheritable always */\n\n        if (afunc->flags & IUPAF_READONLY)\n        {\n          if (afunc->flags & IUPAF_NO_STRING)\n            return -1;  /* value is NOT a string, can NOT call iupAttribSetStr */\n          return 0;\n        }\n\n        if (afunc->set && (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n        {\n          if (afunc->flags & IUPAF_HAS_ID2)\n          {\n            IattribSetId2Func id2_set = (IattribSetId2Func)afunc->set;\n            int id1=IUP_INVALID_ID, id2=IUP_INVALID_ID;\n            iupStrToIntInt(name_id, &id1, &id2, ':');  /* ignore errors because of '*' ids */\n            return id2_set(ih, id1, id2, value);\n          }\n          else\n          {\n            IattribSetIdFunc id_set = (IattribSetIdFunc)afunc->set;\n            int id=IUP_INVALID_ID;\n            if (iupStrToInt(name_id, &id))\n              return id_set(ih, id, value);\n          }\n        }\n\n        if (afunc->flags & IUPAF_NO_STRING)\n          return -1; /* value is NOT a string, can NOT call iupAttribSetStr */\n\n        return 1; /* if the function exists, then must return here */\n      }\n    }\n  }\n\n  /* if not has_attrib_id, or not found an ID, or not found the partial name, check using the full name */\n\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  *inherit = 1; /* default is inheritable */\n  if (afunc)\n  {\n    *inherit = !(afunc->flags & IUPAF_NO_INHERIT) &&   /* is inheritable */\n               !(afunc->flags & IUPAF_NO_STRING);      /* is a string */\n\n    if (afunc->flags & IUPAF_READONLY)\n    {\n      if (afunc->flags & IUPAF_NO_STRING)\n        return -1;  /* value is NOT a string, can NOT call iupAttribSetStr */\n      return 0;\n    }\n\n    if (afunc->set && (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      int ret;\n      if (!value)\n      {\n        /* inheritable attributes when reset must check the parent value */\n        if (*inherit && ih->parent)   \n          value = iupAttribGetInherit(ih->parent, name); \n\n        if (!value)\n          value = iClassGetDefaultValue(afunc);\n      }\n\n      if (afunc->flags & IUPAF_HAS_ID2)\n      {\n        IattribSetId2Func id2_set = (IattribSetId2Func)afunc->set;\n        return id2_set(ih, IUP_INVALID_ID, IUP_INVALID_ID, value);  /* empty Id */\n      }\n      else if (afunc->flags & IUPAF_HAS_ID)\n      {\n        IattribSetIdFunc id_set = (IattribSetIdFunc)afunc->set;\n        return id_set(ih, IUP_INVALID_ID, value);  /* empty Id */\n      }\n      else\n        ret = afunc->set(ih, value);\n\n      if (ret == 1 && afunc->flags & IUPAF_NO_STRING)\n        return -1;  /* value is NOT a string, can NOT call iupAttribSetStr */\n\n      if (*inherit)\n        return 1;   /* inheritable attributes are always stored in the hash table, */\n      else          /* to indicate that they are set at the control.               */\n        return ret;\n    }\n  }\n\n  return 1;  /* function not found, default to string */\n}\n\nchar* iupClassObjectGetAttributeId2(Ihandle* ih, const char* name, int id1, int id2)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id!=2)\n    return NULL;\n\n  if (name[0]==0)\n    name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                          translate them into IDVALUE. */\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc)\n  {\n    if (afunc->flags & IUPAF_WRITEONLY)\n      return NULL;\n\n    if (afunc->get && \n        (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      if (afunc->flags & IUPAF_HAS_ID2)\n      {\n        IattribGetId2Func id2_get = (IattribGetId2Func)afunc->get;\n        return id2_get(ih, id1, id2);\n      }\n      else if (afunc->flags & IUPAF_HAS_ID)\n      {\n        IattribGetIdFunc id_get = (IattribGetIdFunc)afunc->get;\n        return id_get(ih, id1);  /* id2 is ignored */\n      }\n    }\n  }\n\n  return NULL;\n}\n\nchar* iupClassObjectGetAttributeId(Ihandle* ih, const char* name, int id)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id==0)\n    return NULL;\n\n  if (name[0]==0)\n    name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                          translate them into IDVALUE. */\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc && afunc->flags & IUPAF_HAS_ID)\n  {\n    if (afunc->flags & IUPAF_WRITEONLY)\n      return NULL;\n\n    if (afunc->get && \n        !(afunc->flags & IUPAF_HAS_ID2) &&\n        (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      IattribGetIdFunc id_get = (IattribGetIdFunc)afunc->get;\n      return id_get(ih, id);\n    }\n  }\n\n  return NULL;\n}\n\nchar* iupClassObjectGetAttribute(Ihandle* ih, const char* name, char* *def_value, int *inherit)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id!=0)\n  {\n    const char* name_id = iClassFindId(name);\n    if (name_id)\n    {\n      const char* partial_name = iClassCutNameId(name, name_id);\n      if (!partial_name)\n        partial_name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                                      translate them into IDVALUE. */\n      afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, partial_name);\n      if (afunc && afunc->flags & IUPAF_HAS_ID)\n      {\n        *def_value = NULL;  /* id numbered attributes have default value NULL always */\n        *inherit = 0;       /* id numbered attributes are NON inheritable always */\n\n        if (afunc->flags & IUPAF_WRITEONLY)\n          return NULL;\n\n        if (afunc->get && (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n        {\n          if (afunc->flags & IUPAF_HAS_ID2)\n          {\n            IattribGetId2Func id2_get = (IattribGetId2Func)afunc->get;\n            int id1=IUP_INVALID_ID, id2=IUP_INVALID_ID;\n            iupStrToIntInt(name_id, &id1, &id2, ':');\n            return id2_get(ih, id1, id2);\n          }\n          else\n          {\n            IattribGetIdFunc id_get = (IattribGetIdFunc)afunc->get;\n            int id=IUP_INVALID_ID;\n            if (iupStrToInt(name_id, &id))\n              return id_get(ih, id);\n          }\n        }\n        else\n          return NULL;      /* if the function exists, then must return here */\n      }\n    }\n  }\n\n  /* if not has_attrib_id, or not found an ID, or not found the partial name, check using the full name */\n\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  *def_value = NULL;\n  *inherit = 1; /* default is inheritable */\n  if (afunc)\n  {\n    *def_value = iClassGetDefaultValue(afunc);\n    *inherit = !(afunc->flags & IUPAF_NO_INHERIT) &&   /* is inheritable */\n               !(afunc->flags & IUPAF_NO_STRING);      /* is a string */\n\n    if (afunc->flags & IUPAF_WRITEONLY)\n      return NULL;\n\n    if (afunc->get && (ih->handle || afunc->flags & IUPAF_NOT_MAPPED))\n    {\n      if (afunc->flags & IUPAF_HAS_ID2)\n      {\n        IattribGetId2Func id2_get = (IattribGetId2Func)afunc->get;\n        return id2_get(ih, IUP_INVALID_ID, IUP_INVALID_ID);  /* empty Id */\n      }\n      else if (afunc->flags & IUPAF_HAS_ID)\n      {\n        IattribGetIdFunc id_get = (IattribGetIdFunc)afunc->get;\n        return id_get(ih, IUP_INVALID_ID);  /* empty Id */\n      }\n      else\n        return afunc->get(ih);\n    }\n  }\n  return NULL;\n}\n\nvoid iupClassObjectGetAttributeInfo(Ihandle* ih, const char* name, char* *def_value, int *inherit)\n{\n  IattribFunc* afunc;\n\n  if (ih->iclass->has_attrib_id!=0)\n  {\n    const char* name_id = iClassFindId(name);\n    if (name_id)\n    {\n      const char* partial_name = iClassCutNameId(name, name_id);\n      if (!partial_name)\n        partial_name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                                      translate them into IDVALUE. */\n      afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, partial_name);\n      if (afunc && afunc->flags & IUPAF_HAS_ID)\n      {\n        *def_value = NULL;  /* id numbered attributes have default value NULL always */\n        *inherit = 0;       /* id numbered attributes are NON inheritable always */\n         return;      /* if the function exists, then must return here */\n      }\n    }\n  }\n\n  /* if not has_attrib_id, or not found an ID, or not found the partial name, check using the full name */\n\n  afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  *def_value = NULL;\n  *inherit = 1; /* default is inheritable */\n  if (afunc)\n  {\n    *def_value = iClassGetDefaultValue(afunc);\n    *inherit = !(afunc->flags & IUPAF_NO_INHERIT) &&  /* is inheritable */\n               !(afunc->flags & IUPAF_NO_STRING);     /* is a string */\n  }\n}\n\nvoid iupClassGetAttribNameInfo(Iclass* ic, const char* name, char* *def_value, int *flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  *def_value = NULL;\n  *flags = 0;\n  if (afunc)\n  {\n    *flags = afunc->flags;\n    *def_value = iClassGetDefaultValue(afunc);\n  }\n}\n\nint iupClassObjectCurAttribIsInherit(Iclass* ic)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGetCurr(ic->attrib_func);\n  if (afunc && !(afunc->flags & IUPAF_NO_INHERIT))\n    return 1;\n  return 0;\n}\n\nint iupClassObjectAttribIsNotString(Ihandle* ih, const char* name)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc && (afunc->flags & IUPAF_NO_STRING || afunc->flags & IUPAF_CALLBACK || afunc->flags & IUPAF_IHANDLE))\n    return 1;\n  return 0;\n}\n\nint iupClassObjectAttribIsIhandle(Ihandle* ih, const char* name)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ih->iclass->attrib_func, name);\n  if (afunc && (afunc->flags & IUPAF_IHANDLE))\n    return 1;\n  return 0;\n}\n\nint iupClassAttribIsRegistered(Iclass* ic, const char* name)\n{\n  IattribFunc* afunc = NULL;\n\n  if (ic->has_attrib_id!=0)\n  {\n    const char* name_id = iClassFindId(name);\n    if (name_id)\n    {\n      const char* partial_name = iClassCutNameId(name, name_id);\n      if (!partial_name)\n        partial_name = \"IDVALUE\";  /* pure numbers are used as attributes in IupList and IupMatrix, \n                                      translate them into IDVALUE. */\n      afunc = (IattribFunc*)iupTableGet(ic->attrib_func, partial_name);\n    }\n  }\n\n  if (!afunc)\n    afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n\n  if (afunc)\n    return 1;\n\n  return 0;\n}\n\nvoid iupClassRegisterAttribute(Iclass* ic, const char* name, \n                               IattribGetFunc _get, IattribSetFunc _set, \n                               const char* _default_value, const char* _system_default, int _flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n    free(afunc);  /* overwrite a previous registration */\n\n  afunc = (IattribFunc*)malloc(sizeof(IattribFunc));\n  afunc->get = _get;\n  afunc->set = _set;\n  if (_default_value == IUPAF_SAMEASSYSTEM)\n    afunc->default_value = _system_default;\n  else\n    afunc->default_value = _default_value;\n  afunc->system_default = _system_default;\n  afunc->flags = _flags;\n\n  if (iupClassIsGlobalDefault(afunc->default_value, 0))\n    afunc->call_global_default = 1;\n  else\n    afunc->call_global_default = 0;\n\n  iupTableSet(ic->attrib_func, name, (void*)afunc, IUPTABLE_POINTER);\n}\n\nvoid iupClassRegisterAttributeId(Iclass* ic, const char* name, \n                               IattribGetIdFunc _get, IattribSetIdFunc _set, \n                               int _flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n    free(afunc);  /* overwrite a previous registration */\n\n  afunc = (IattribFunc*)malloc(sizeof(IattribFunc));\n  afunc->get = (IattribGetFunc)_get;\n  afunc->set = (IattribSetFunc)_set;\n  afunc->default_value = NULL;\n  afunc->system_default = NULL;\n  afunc->flags = _flags|IUPAF_HAS_ID|IUPAF_NO_INHERIT|IUPAF_NO_DEFAULTVALUE;\n  afunc->call_global_default = 0;\n\n  iupTableSet(ic->attrib_func, name, (void*)afunc, IUPTABLE_POINTER);\n}\n\nvoid iupClassRegisterAttributeId2(Iclass* ic, const char* name, \n                               IattribGetId2Func _get, IattribSetId2Func _set, \n                               int _flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n    free(afunc);  /* overwrite a previous registration */\n\n  afunc = (IattribFunc*)malloc(sizeof(IattribFunc));\n  afunc->get = (IattribGetFunc)_get;\n  afunc->set = (IattribSetFunc)_set;\n  afunc->default_value = NULL;\n  afunc->system_default = NULL;\n  afunc->flags = _flags|IUPAF_HAS_ID2|IUPAF_HAS_ID|IUPAF_NO_INHERIT|IUPAF_NO_DEFAULTVALUE;\n  afunc->call_global_default = 0;\n\n  iupTableSet(ic->attrib_func, name, (void*)afunc, IUPTABLE_POINTER);\n}\n\nvoid iupClassRegisterGetAttribute(Iclass* ic, const char* name, \n                                  IattribGetFunc *_get, IattribSetFunc *_set, \n                                  const char* *_default_value, const char* *_system_default, int *_flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n  {\n    if (_get) *_get = afunc->get;\n    if (_set) *_set = afunc->set;\n    if (_default_value) *_default_value = afunc->default_value;\n    if (_system_default) *_system_default = afunc->system_default;\n    if (_flags) *_flags = afunc->flags;\n  }\n}\n\nvoid iupClassRegisterReplaceAttribFunc(Iclass* ic, const char* name, IattribGetFunc _get, IattribSetFunc _set)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n  {\n    if (_get) afunc->get = _get;\n    if (_set) afunc->set = _set;\n  }\n}\n\nvoid iupClassRegisterReplaceAttribDef(Iclass* ic, const char* name, const char* _default_value, const char* _system_default)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n  {\n    if (_default_value == IUPAF_SAMEASSYSTEM)\n      afunc->default_value = _system_default;\n    else\n      afunc->default_value = _default_value;\n    afunc->system_default = _system_default;\n\n    if (iupClassIsGlobalDefault(afunc->default_value, 0))\n      afunc->call_global_default = 1;\n    else\n      afunc->call_global_default = 0;\n  }\n}\n\nvoid iupClassRegisterReplaceAttribFlags(Iclass* ic, const char* name, int _flags)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n    afunc->flags = _flags;\n}\n\nvoid iupClassRegisterCallback(Iclass* ic, const char* name, const char* format)\n{\n  /* Since attributes and callbacks do not conflict \n     we can use the same structure to store the callback format using the default_value. */\n  iupClassRegisterAttribute(ic, name, NULL, NULL, format, NULL, IUPAF_NO_INHERIT|IUPAF_CALLBACK);\n}\n\nchar* iupClassCallbackGetFormat(Iclass* ic, const char* name)\n{\n  IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc)\n    return (char*)afunc->default_value;\n  return NULL;\n}\n\nint IupGetClassAttributes(const char* classname, char** names, int n)\n{\n  Iclass* ic;\n  int i = 0;\n  char* name;\n  IattribFunc* afunc;\n\n  iupASSERT(classname!=NULL);\n  if (!classname)\n    return 0;\n\n  ic = iupRegisterFindClass(classname);\n  if (!ic)\n    return -1;\n\n  if (!names || !n)\n    return iupTableCount(ic->attrib_func);\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    afunc = (IattribFunc*)iupTableGetCurr(ic->attrib_func);\n\n    if (!(afunc->flags&IUPAF_CALLBACK))\n    {\n      names[i] = name;\n      i++;\n      if (i == n)\n        break;\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n\n  return i;\n}\n\nint IupGetClassCallbacks(const char* classname, char** names, int n)\n{\n  Iclass* ic;\n  int i = 0;\n  char* name;\n  IattribFunc* afunc;\n\n  iupASSERT(classname!=NULL);\n  if (!classname)\n    return 0;\n\n  ic = iupRegisterFindClass(classname);\n  if (!ic)\n    return -1;\n\n  if (!names || !n)\n    return iupTableCount(ic->attrib_func);\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    afunc = (IattribFunc*)iupTableGetCurr(ic->attrib_func);\n\n    if (afunc->flags&IUPAF_CALLBACK)\n    {\n      names[i] = name;\n      i++;\n      if (i == n)\n        break;\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n\n  return i;\n}\n\nvoid IupSetClassDefaultAttribute(const char* classname, const char *name, const char* default_value)\n{\n  Iclass* ic;\n  IattribFunc* afunc;\n\n  iupASSERT(classname!=NULL);\n  if (!classname)\n    return;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return;\n\n  ic = iupRegisterFindClass(name);\n  if (!ic)\n    return;\n\n  afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n  if (afunc && !(afunc->flags & IUPAF_NO_DEFAULTVALUE) &&   /* can has default */\n               !(afunc->flags & IUPAF_NO_STRING) &&     /* is a string */\n               !(afunc->flags & IUPAF_HAS_ID))\n  {\n    if (default_value == IUPAF_SAMEASSYSTEM)\n      afunc->default_value = afunc->system_default;\n    else\n      afunc->default_value = default_value;\n\n    if (iupClassIsGlobalDefault(afunc->default_value, 0))\n      afunc->call_global_default = 1;\n    else\n      afunc->call_global_default = 0;\n  }\n  else if (!afunc && default_value)\n    iupClassRegisterAttribute(ic, name, NULL, NULL, default_value, NULL, IUPAF_DEFAULT);\n}\n\nvoid IupSaveClassAttributes(Ihandle* ih)\n{\n  int has_attrib_id, start_id = 0;\n  Iclass* ic;\n  char *name;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  ic = ih->iclass;\n\n  has_attrib_id = ic->has_attrib_id;\n  if (iupClassMatch(ic, \"tree\") || /* tree can only set id attributes after map, so they can not be saved */\n      iupClassMatch(ic, \"cells\")) /* cells does not have any saveable id attributes */\n    has_attrib_id = 0;  \n\n  if (iupClassMatch(ic, \"list\"))\n    start_id = 1;\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n    if (afunc && !(afunc->flags & IUPAF_NO_STRING) &&  /* is a string */\n                 !(afunc->flags & IUPAF_READONLY) &&   /* not read-only */\n                 !(afunc->flags & IUPAF_WRITEONLY) &&  /* not write-only */\n                 !(afunc->flags & IUPAF_CALLBACK))     /* not a callback */\n    {\n      if ((afunc->flags&IUPAF_NO_SAVE) && iupBaseNoSaveCheck(ih, name))  /* can not be saved */\n      {\n        name = iupTableNext(ic->attrib_func);\n        continue;\n      }\n\n      if (!(afunc->flags & IUPAF_HAS_ID))     /* no ID */\n      {\n        int inherit;\n        char *def_value;\n        char *value = iupClassObjectGetAttribute(ih, name, &def_value, &inherit);\n        if (value && value[0])    /* NOT NULL and not empty */\n        {\n          if ((def_value && iupStrEqualNoCase(def_value, value)) ||  /* equal to the default value */\n              (!def_value && iupStrFalse(value)))   /* default=NULL and value=NO */\n          {\n            name = iupTableNext(ic->attrib_func);\n            continue;\n          }\n\n          if (!iupStrEqualNoCase(value, iupAttribGet(ih, name)))     /* NOT already stored */\n            iupAttribSetStr(ih, name, value);\n        }\n      }\n      else if (has_attrib_id)\n      {\n        char *value;\n\n        if (iupStrEqual(name, \"IDVALUE\"))\n          name = \"\";\n\n        if (afunc->flags&IUPAF_HAS_ID2)\n        {\n          int lin, col, \n              numcol = IupGetInt(ih, \"NUMCOL\")+1,\n              numlin = IupGetInt(ih, \"NUMLIN\")+1;\n          for (lin=0; lin<numlin; lin++)\n          {\n            for (col=0; col<numcol; col++)\n            {\n              value = iupClassObjectGetAttributeId2(ih, name, lin, col);\n              if (value && value[0])  /* NOT NULL and not empty */\n              {\n                if (!iupStrEqualNoCase(value, iupAttribGetId2(ih, name, lin, col)))     /* NOT already stored */\n                  iupAttribSetStrId2(ih, name, lin, col, value);\n              }\n            }\n          }\n        }\n        else\n        {\n          int id, count = IupGetInt(ih, \"COUNT\");\n          for (id=start_id; id<count+start_id; id++)\n          {\n            value = iupClassObjectGetAttributeId(ih, name, id);\n            if (value && value[0])  /* NOT NULL and not empty */\n            {\n              if (!iupStrEqualNoCase(value, iupAttribGetId(ih, name, id)))     /* NOT already stored */\n                iupAttribSetStrId(ih, name, id, value);\n            }\n          }\n        }\n      }\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n}\n\nvoid IupCopyClassAttributes(Ihandle* src_ih, Ihandle* dst_ih)\n{\n  int has_attrib_id, start_id = 0;\n  Iclass* ic;\n  char *name;\n\n  iupASSERT(iupObjectCheck(src_ih));\n  if (!iupObjectCheck(src_ih))\n    return;\n\n  iupASSERT(iupObjectCheck(dst_ih));\n  if (!iupObjectCheck(dst_ih))\n    return;\n\n  if (!IupClassMatch(dst_ih, src_ih->iclass->name))\n    return;\n\n  ic = src_ih->iclass;\n\n  has_attrib_id = ic->has_attrib_id;\n  if (iupClassMatch(ic, \"tree\") || /* tree can only set id attributes after map, so they can not be saved */\n      iupClassMatch(ic, \"cells\")) /* cells does not have any saveable id attributes */\n    has_attrib_id = 0;  \n\n  if (iupClassMatch(ic, \"list\"))\n    start_id = 1;\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n    if (afunc && !(afunc->flags & IUPAF_NO_STRING) &&  /* is a string */\n                 !(afunc->flags & IUPAF_READONLY) &&   /* not read-only */\n                 !(afunc->flags & IUPAF_WRITEONLY) &&  /* not write-only */\n                 !(afunc->flags & IUPAF_CALLBACK))     /* not a callback */\n    {\n      if ((afunc->flags&IUPAF_NO_SAVE) && iupBaseNoSaveCheck(src_ih, name))  /* can not be saved */\n      {\n        name = iupTableNext(ic->attrib_func);\n        continue;\n      }\n\n      if (!(afunc->flags & IUPAF_HAS_ID))     /* no ID */\n      {\n        char *value = IupGetAttribute(src_ih, name);\n        if (value && value[0])    /* NOT NULL and not empty */\n        {\n          if (!iupStrEqualNoCase(value, IupGetAttribute(dst_ih, name)))     /* NOT already equal */\n            IupStoreAttribute(dst_ih, name, value);\n        }\n      }\n      else if (has_attrib_id)\n      {\n        char *value;\n\n        if (iupStrEqual(name, \"IDVALUE\"))\n          name = \"\";\n\n        if (afunc->flags&IUPAF_HAS_ID2)\n        {\n          int lin, col, \n              numcol = IupGetInt(src_ih, \"NUMCOL\")+1,\n              numlin = IupGetInt(src_ih, \"NUMLIN\")+1;\n          for (lin=0; lin<numlin; lin++)\n          {\n            for (col=0; col<numcol; col++)\n            {\n              value = IupGetAttributeId2(src_ih, name, lin, col);\n              if (value && value[0])  /* NOT NULL and not empty */\n              {\n                if (!iupStrEqualNoCase(value, IupGetAttributeId2(dst_ih, name, lin, col)))     /* NOT already stored */\n                  IupStoreAttributeId2(dst_ih, name, lin, col, value);\n              }\n            }\n          }\n        }\n        else\n        {\n          int id, count = IupGetInt(src_ih, \"COUNT\");\n          for (id=start_id; id<count+start_id; id++)\n          {\n            value = IupGetAttributeId(src_ih, name, id);\n            if (value && value[0])  /* NOT NULL and not empty */\n            {\n              if (!iupStrEqualNoCase(value, IupGetAttributeId(dst_ih, name, id)))     /* NOT already stored */\n                IupStoreAttributeId(dst_ih, name, id, value);\n            }\n          }\n        }\n      }\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n\n\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    IattribFunc* afunc = (IattribFunc*)iupTableGet(ic->attrib_func, name);\n    if (afunc && !(afunc->flags & IUPAF_NO_STRING) &&   /* is a string */\n                 !(afunc->flags & IUPAF_READONLY) &&\n                 !(afunc->flags & IUPAF_WRITEONLY) &&\n                 !(afunc->flags & IUPAF_HAS_ID) &&\n                 !(afunc->flags & IUPAF_CALLBACK))\n    {\n      char *value = IupGetAttribute(src_ih, name);\n      if (value &&     /* NOT NULL */\n          !iupStrEqualNoCase(value, IupGetAttribute(dst_ih, name)))     /* NOT already stored */\n        IupStoreAttribute(dst_ih, name, value);\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n}\n\nvoid iupClassObjectEnsureDefaultAttributes(Ihandle* ih)\n{\n  Iclass* ic;\n  char *name;\n\n  ic = ih->iclass;\n\n  name = iupTableFirst(ic->attrib_func);\n  while (name)\n  {\n    IattribFunc* afunc = (IattribFunc*)iupTableGetCurr(ic->attrib_func);\n    if (afunc && afunc->set && \n        (afunc->default_value || afunc->system_default) &&\n        !(afunc->flags & IUPAF_NO_DEFAULTVALUE) &&   /* can has default */\n        !(afunc->flags & IUPAF_NO_STRING) &&       /* is a string */\n        !(afunc->flags & IUPAF_HAS_ID))\n    {\n      if ((!iupStrEqualNoCase(afunc->default_value, afunc->system_default)) || \n          (afunc->call_global_default && iupGlobalDefaultColorChanged(afunc->default_value)))\n      {\n        if ((!ih->handle && (afunc->flags & IUPAF_NOT_MAPPED)) ||\n            (ih->handle && !(afunc->flags & IUPAF_NOT_MAPPED)))\n        {\n          char* value = iupAttribGet(ih, name);\n          if (!value)  /* if set will be updated later */\n            afunc->set(ih, iClassGetDefaultValue(afunc));\n        }\n      }\n    }\n\n    name = iupTableNext(ic->attrib_func);\n  }\n}\n","/** \\file\n * \\brief Ihandle Class Base Functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_str.h\"\n#include \"iup_attrib.h\"\n#include \"iup_layout.h\"\n#include \"iup_assert.h\"\n\n\nvoid iupBaseCallValueChangedCb(Ihandle* ih)\n{\n  IFn vc_cb = (IFn)IupGetCallback(ih, \"VALUECHANGED_CB\");\n  if (vc_cb)\n    vc_cb(ih);\n}\n\nint iupBaseTypeVoidMapMethod(Ihandle* ih)\n{\n  ih->handle = (InativeHandle*)-1;  /* fake value just to indicate that it is already mapped */\n  return IUP_NOERROR;\n}\n\nchar* iupBaseGetWidAttrib(Ihandle *ih)\n{\n  return (char*)ih->handle;\n}\n\nvoid iupBaseUpdateAttribFromFont(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"SIZE\");\n  if (value)\n    iupBaseSetSizeAttrib(ih, value);\n\n  {\n    Icallback cb = IupGetCallback(ih, \"UPDATEATTRIBFROMFONT\");\n    if (cb)\n      cb(ih);\n  }\n}\n\nint iupBaseSetSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    /* if not specified, the value is 0 */\n    int w = 0, h = 0;\n    int charwidth, charheight;\n    iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n    iupStrToIntInt(value, &w, &h, 'x');\n    if (w < 0) w = 0;\n    if (h < 0) h = 0;\n\n    ih->userwidth = iupWIDTH2RASTER(w, charwidth);\n    ih->userheight = iupHEIGHT2RASTER(h, charheight);\n  }\n  return 1;  /* always save in the hash table, so when FONT is changed SIZE can be updated */\n}\n\nchar* iupBaseGetSizeAttrib(Ihandle* ih)\n{\n  int charwidth, charheight, width, height;\n\n  if (ih->handle)\n  {\n    width = ih->currentwidth;\n    height = ih->currentheight;\n  }\n  else\n  {\n    width = ih->userwidth;\n    height = ih->userheight;\n  }\n\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  if (charwidth == 0 || charheight == 0)\n    return NULL;  /* if font failed get from the hash table */\n\n  return iupStrReturnIntInt(iupRASTER2WIDTH(width, charwidth), iupRASTER2HEIGHT(height, charheight), 'x');\n}\n\nint iupBaseSetRasterSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    /* if not specified, the value is 0 */\n    int w = 0, h = 0;\n    iupStrToIntInt(value, &w, &h, 'x');\n    if (w < 0) w = 0;\n    if (h < 0) h = 0;\n    ih->userwidth = w;\n    ih->userheight = h;\n  }\n  iupAttribSet(ih, \"SIZE\", NULL); /* clear SIZE in hash table */\n  return 0;\n}\n\nchar* iupBaseGetClientOffsetAttrib(Ihandle* ih)\n{\n  (void)ih;\n  return \"0x0\";\n}\n\nchar* iupBaseGetCurrentSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  if (width == 0 && height == 0)\n    return NULL;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nchar* iupBaseGetRasterSizeAttrib(Ihandle* ih)\n{\n  int width, height;\n\n  if (ih->handle)\n  {\n    width = ih->currentwidth;\n    height = ih->currentheight;\n  }\n  else\n  {\n    width = ih->userwidth;\n    height = ih->userheight;\n  }\n\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n\n  if (width == 0 && height == 0)\n    return NULL;\n\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nchar* iupBaseGetCharSizeAttrib(Ihandle* ih)\n{\n  int charwidth, charheight;\n\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  if (charwidth == 0 || charheight == 0)\n    return NULL;\n\n  return iupStrReturnIntInt(charwidth, charheight, 'x');\n}\n\nstatic char* iBaseGetNaturalSizeAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->naturalwidth, ih->naturalheight, 'x');\n}\n\nstatic char* iBaseGetUserSizeAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->userwidth, ih->userheight, 'x');\n}\n\nstatic char* iBaseGetPositionAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->x, ih->y, ',');\n}\n\nstatic int iBaseSetPositionAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToIntInt(value, &ih->x, &ih->y, ',');\n  return 0;\n}\n\nstatic char* iBaseGetXAttrib(Ihandle *ih)\n{\n  int x = 0, y = 0;\n  iupdrvClientToScreen(ih, &x, &y);\n  iupdrvAddScreenOffset(&x, &y, -1);\n  return iupStrReturnInt(x);\n}\n\nstatic char* iBaseGetYAttrib(Ihandle *ih)\n{\n  int x = 0, y = 0;\n  iupdrvClientToScreen(ih, &x, &y);\n  iupdrvAddScreenOffset(&x, &y, -1);\n  return iupStrReturnInt(y);\n}\n\nstatic char* iBaseGetScreenPositionAttrib(Ihandle *ih)\n{\n  int x = 0, y = 0;\n  iupdrvClientToScreen(ih, &x, &y);\n  iupdrvAddScreenOffset(&x, &y, -1);\n  return iupStrReturnIntInt(x, y, ',');\n}\n\nchar* iupBaseGetActiveAttrib(Ihandle *ih)\n{\n  return iupStrReturnBoolean (iupdrvIsActive(ih)); \n}\n\nstatic int iBaseNativeParentIsActive(Ihandle* ih)\n{\n  if (!ih->parent)\n    return 1;\n\n  if (ih->parent->iclass->nativetype == IUP_TYPEVOID)\n    return iBaseNativeParentIsActive(ih->parent);\n  else \n    return iupdrvIsActive(ih->parent);\n}\n\nint iupBaseSetActiveAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n  {\n    if (iBaseNativeParentIsActive(ih))\n      iupdrvSetActive(ih, 1);\n  }\n  else\n    iupdrvSetActive(ih, 0);\n  return 0;\n}\n\nchar* iupBaseGetVisibleAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (iupdrvIsVisible(ih)); \n}\n\nint iupBaseSetVisibleAttrib(Ihandle* ih, const char* value)\n{\n  iupdrvSetVisible(ih, iupStrBoolean(value));\n  return 1;  /* must be 1 to mark when set at the element */\n}\n\nchar* iupBaseNativeParentGetBgColorAttrib(Ihandle* ih)\n{\n  /* Used only by those who need a transparent background */\n  char* color = iupAttribGetInheritNativeParent(ih, \"BGCOLOR\");\n  if (!color) color = iupAttribGetInheritNativeParent(ih, \"BACKGROUND\");\n  if (!color) color = IupGetGlobal(\"DLGBGCOLOR\");\n  return color;\n}\n\nchar* iupBaseNativeParentGetBgColor(Ihandle* ih)\n{\n  /* Used in SetBgColorAttrib */\n  char* color = iupAttribGetInheritNativeParent(ih, \"BGCOLOR\");\n  if (!color) color = IupGetGlobal(\"DLGBGCOLOR\");\n  return color;\n}\n\nint iupRound(double x)\n{\n  return iupROUND(x);\n}\n\nint iupBaseGetScrollbar(Ihandle* ih)\n{\n  int sb = IUP_SB_NONE;  /* NO scrollbar by default */\n  char* value = IupGetAttribute(ih, \"SCROLLBAR\");\n  if (value)\n  {\n    if (iupStrEqualNoCase(value, \"YES\"))\n      sb = IUP_SB_HORIZ | IUP_SB_VERT;\n    else if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n      sb = IUP_SB_HORIZ;\n    else if (iupStrEqualNoCase(value, \"VERTICAL\"))\n      sb = IUP_SB_VERT;\n  }\n  return sb;\n}\n\nstatic int iBaseSetNormalizerGroupAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* ih_normalizer = IupGetHandle(value);\n  if (!ih_normalizer)\n  {\n    ih_normalizer = IupNormalizer(NULL);\n    IupSetHandle(value, ih_normalizer);\n  }\n\n  IupSetAttribute(ih_normalizer, \"ADDCONTROL_HANDLE\", (char*)ih);\n  return 1;\n}\n\nstatic Ihandle* iBaseFindNamedChild(Ihandle* ih, const char* name)\n{\n  Ihandle* child = ih->firstchild;\n  while (child)\n  {\n    char* child_name = iupAttribGet(child, \"NAME\");\n    if (child_name && iupStrEqualNoCase(name, child_name))\n      return child;\n\n    if (child->firstchild)\n    {\n      Ihandle* c = iBaseFindNamedChild(child, name);\n      if (c) return c;\n    }\n\n    child = child->brother;\n  }\n  return NULL;\n}\n\nIhandle* IupGetDialogChild(Ihandle* ih, const char* name)\n{\n  Ihandle *child, *dialog;\n  char attrib[1024] = \"_IUP_DIALOG_CHILD_\";\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  if (!name)\n    return NULL;\n\n  dialog = IupGetDialog(ih);\n  if (dialog) ih = dialog;\n \n  strcat(attrib, name);\n  child = (Ihandle*)iupAttribGet(ih, attrib);\n  if (child) return child;\n\n  if (ih->firstchild)\n  {\n    child = iBaseFindNamedChild(ih, name);\n    if (child) return child;\n  }\n\n  ih = IupGetAttributeHandle(ih, \"MENU\");\n  if (ih)\n  {\n    child = iBaseFindNamedChild(ih, name);\n    if (child) return child;\n  }\n  return NULL;\n}\n\nint iupBaseSetNameAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    /* remove old name cache */\n    value = iupAttribGet(ih, \"NAME\");\n    if (value)\n    {\n      Ihandle* dialog;\n      char attrib[1024] = \"_IUP_DIALOG_CHILD_\";\n      strcat(attrib, value);\n      dialog = (Ihandle*)iupAttribGet(ih, attrib);\n      if (dialog)\n        iupAttribSet(dialog, attrib, NULL);\n    }\n  }\n  else\n  {\n    Ihandle* dialog = IupGetDialog(ih);\n    if (dialog)\n    {\n      char attrib[1024] = \"_IUP_DIALOG_CHILD_\";\n      strcat(attrib, value);\n      iupAttribSet(dialog, attrib, (char*)ih);\n      iupAttribSet(ih, attrib, (char*)dialog);\n    }\n  }\n  return 1;\n}\n\nstatic int iBaseSetFloatingAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"IGNORE\"))\n    ih->flags |= IUP_FLOATING_IGNORE|IUP_FLOATING;\n  else if (iupStrBoolean(value))\n    ih->flags |= IUP_FLOATING;\n  else\n    ih->flags &= ~(IUP_FLOATING_IGNORE|IUP_FLOATING);  /* clear both flags */\n  return 0;\n}\n\nstatic char* iBaseGetFloatingAttrib(Ihandle* ih)\n{\n  if (ih->flags & IUP_FLOATING_IGNORE)\n    return \"IGNORE\";\n  else \n    return iupStrReturnBoolean (ih->flags & IUP_FLOATING); \n}\n\nint iupBaseSetMaxSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (value)\n    ih->flags |= IUP_MAXSIZE;\n  else\n    ih->flags &= ~IUP_MAXSIZE;\n  return 1;\n}\n\nint iupBaseSetMinSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (value)\n    ih->flags |= IUP_MINSIZE;\n  else\n    ih->flags &= ~IUP_MINSIZE;\n  return 1;\n}\n\nstatic int iBaseSetExpandAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"YES\"))\n    ih->expand = IUP_EXPAND_BOTH;\n  else if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->expand = IUP_EXPAND_WIDTH;\n  else if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    ih->expand = IUP_EXPAND_HEIGHT;\n  else if (iupStrEqualNoCase(value, \"HORIZONTALFREE\"))\n    ih->expand = IUP_EXPAND_WFREE;\n  else if (iupStrEqualNoCase(value, \"VERTICALFREE\"))\n    ih->expand = IUP_EXPAND_HFREE;\n  else\n    ih->expand = IUP_EXPAND_NONE;\n  return 0;\n}\n\nstatic char* iBaseGetExpandAttrib(Ihandle* ih)\n{\n  if ((ih->expand & IUP_EXPAND_WIDTH) && (ih->expand & IUP_EXPAND_HEIGHT))\n    return \"YES\";\n  else if (ih->expand & IUP_EXPAND_WIDTH)\n    return \"HORIZONTAL\";\n  else if (ih->expand & IUP_EXPAND_HEIGHT)\n    return \"VERTICAL\";\n  else if (ih->expand & IUP_EXPAND_WFREE)\n    return \"HORIZONTALFREE\";\n  else if (ih->expand & IUP_EXPAND_HFREE)\n    return \"VERTICALFREE\";\n  else\n    return \"NO\";\n}\n\nvoid iupBaseContainerUpdateExpand(Ihandle* ih)\n{\n  char *expand = iupAttribGetInherit(ih, \"EXPAND\");\n  if (!expand)\n    ih->expand = IUP_EXPAND_BOTH;  /* default for containers is YES */\n  else\n  {\n    if (iupStrEqualNoCase(expand, \"NO\"))\n      ih->expand = IUP_EXPAND_NONE;\n    else if (iupStrEqualNoCase(expand, \"HORIZONTAL\"))\n      ih->expand = IUP_EXPAND_WIDTH;\n    else if (iupStrEqualNoCase(expand, \"VERTICAL\"))\n      ih->expand = IUP_EXPAND_HEIGHT;\n    else if (iupStrEqualNoCase(expand, \"HORIZONTALFREE\"))\n      ih->expand = IUP_EXPAND_WFREE;\n    else if (iupStrEqualNoCase(expand, \"VERTICALFREE\"))\n      ih->expand = IUP_EXPAND_HFREE;\n    else\n      ih->expand = IUP_EXPAND_BOTH;  /* default for containers is YES */\n  }\n}\n\n/* EXPAND is registered with IUP_NO_INHERIT because it is not inheritable,\n   but it is inheritable for containers. \n   So if you set at a container it will not affect its children,\n   but children that are containers will get the same value. */\nchar* iupBaseContainerGetExpandAttrib(Ihandle* ih)\n{\n  return iupAttribGetInherit(ih, \"EXPAND\");\n}\n\nvoid iupBaseRegisterCommonAttrib(Iclass* ic)\n{\n  iupClassRegisterAttribute(ic, \"WID\", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"NAME\", NULL, iupBaseSetNameAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FLOATING\", iBaseGetFloatingAttrib, iBaseSetFloatingAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iBaseGetExpandAttrib, iBaseSetExpandAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NORMALIZERGROUP\", NULL, iBaseSetNormalizerGroupAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPANDWEIGHT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* make sure everyone has the correct default value */\n  iupClassRegisterAttribute(ic, \"ACTIVE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n  if (ic->is_interactive)\n    iupClassRegisterAttribute(ic, \"CANFOCUS\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  else\n    iupClassRegisterAttribute(ic, \"CANFOCUS\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NO_INHERIT);\n\n  /* if not native container, must set at children,\n     native container will automatically hide its children. */\n  iupClassRegisterAttribute(ic, \"VISIBLE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_SAVE|IUPAF_DEFAULT);  /* let the attribute to be propagated to children */\n\n  iupClassRegisterAttribute(ic, \"SIZE\", iupBaseGetSizeAttrib, iupBaseSetSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iupBaseGetRasterSizeAttrib, iupBaseSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CHARSIZE\", iupBaseGetCharSizeAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NATURALSIZE\", iBaseGetNaturalSizeAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"USERSIZE\", iBaseGetUserSizeAttrib, iupBaseSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"POSITION\", iBaseGetPositionAttrib, iBaseSetPositionAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MINSIZE\", NULL, iupBaseSetMinSizeAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MAXSIZE\", NULL, iupBaseSetMaxSizeAttrib, IUPAF_SAMEASSYSTEM, \"65535x65535\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, iupdrvSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);  /* use inheritance to retrieve standard fonts */\n  iupClassRegisterAttribute(ic, \"FONT\", iupGetFontAttrib, iupSetFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"FONTSTYLE\", iupGetFontStyleAttrib, iupSetFontStyleAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FONTSIZE\",  iupGetFontSizeAttrib,  iupSetFontSizeAttrib,  NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FONTFACE\",  iupGetFontFaceAttrib,  iupSetFontFaceAttrib,  NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvBaseRegisterCommonAttrib(ic);\n}\n\nvoid iupBaseRegisterVisualAttrib(Iclass* ic)\n{\n  iupClassRegisterAttribute(ic, \"VISIBLE\", iupBaseGetVisibleAttrib, iupBaseSetVisibleAttrib, \"YES\", \"NO\", IUPAF_NO_SAVE|IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n\n  iupClassRegisterAttribute(ic, \"ZORDER\", NULL, iupdrvBaseSetZorderAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"X\", iBaseGetXAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"Y\", iBaseGetYAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCREENPOSITION\", iBaseGetScreenPositionAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"TIP\", NULL, iupdrvBaseSetTipAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TIPVISIBLE\", iupdrvBaseGetTipVisibleAttrib, iupdrvBaseSetTipVisibleAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TIPDELAY\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"5000\", IUPAF_NOT_MAPPED);          /* 5 seconds */\n  iupClassRegisterAttribute(ic, \"TIPBGCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"255 255 225\", IUPAF_NOT_MAPPED); /* Light Yellow */\n  iupClassRegisterAttribute(ic, \"TIPFGCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"0 0 0\", IUPAF_NOT_MAPPED);       /* black */\n  iupClassRegisterAttribute(ic, \"TIPRECT\", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_MAPPED);\n\n  iupdrvBaseRegisterVisualAttrib(ic);\n}\n\nvoid iupBaseRegisterCommonCallbacks(Iclass* ic)\n{\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"GETFOCUS_CB\", \"\");\n  iupClassRegisterCallback(ic, \"KILLFOCUS_CB\", \"\");\n  iupClassRegisterCallback(ic, \"ENTERWINDOW_CB\", \"\");\n  iupClassRegisterCallback(ic, \"LEAVEWINDOW_CB\", \"\");\n  iupClassRegisterCallback(ic, \"HELP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"K_ANY\", \"i\");\n}\n\nint iupBaseNoSaveCheck(Ihandle* ih, const char* name)\n{\n  if (iupStrEqual(name, \"BGCOLOR\") ||\n      iupStrEqual(name, \"VISIBLE\") ||\n      iupStrEqual(name, \"SIZE\"))\n  {\n    if (iupAttribGet(ih, name))  /* save if stored at the hash table */\n      return 0;  /* save the attribute */\n    else\n      return 1;\n  }\n  if (iupStrEqual(name, \"RASTERSIZE\"))\n  {\n    if (!iupAttribGet(ih, \"SIZE\") &&   /* save if SIZE is not set, and user size is set */\n        (ih->userwidth!=0 || ih->userheight!=0))\n      return 0;\n    else\n      return 1;\n  }\n  if (iupStrEqual(name, \"POSITION\"))\n  {\n    if (ih->flags&IUP_FLOATING &&   /* save only if floating is set */\n        (ih->x != 0 || ih->y != 0))\n      return 0;\n    else\n      return 1;\n  }\n\n  return 1; /* default is NOT to save */\n}\n","/** \\file\n * \\brief IupColorDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n\n\nIhandle* IupColorDlg(void)\n{\n  return IupCreate(\"colordlg\");\n}\n\nIclass* iupColorDlgNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"dialog\"));\n\n  ic->name = \"colordlg\";\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->is_interactive = 1;\n\n  ic->New = iupColorDlgNewClass;\n\n  /* reset not used native dialog methods */\n  ic->parent->LayoutUpdate = NULL;\n  ic->parent->SetChildrenPosition = NULL;\n  ic->parent->Map = NULL;\n  ic->parent->UnMap = NULL;\n\n  iupdrvColorDlgInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief IupDetachBox control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_childtree.h\"\n#include \"iup_draw.h\"\n\n\nenum { IDBOX_VERT, IDBOX_HORIZ };\n\nstruct _IcontrolData\n{\n  /* aux */\n  int is_holding;\n  Ihandle *old_parent, *old_brother;\n\n  /* attributes */\n  int layoutdrag, barsize, showgrip;\n  int orientation;     /* one of the types: IDBOX_VERT, IDBOX_HORIZ */\n};\n\n\n/*****************************************************************************\\\n|* Attributes                                                                *|\n\\*****************************************************************************/\n\nstatic char* iDetachBoxGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n\n  if (ih->data->orientation == IDBOX_VERT)\n    width -= ih->data->barsize;\n  else\n    height -= ih->data->barsize;\n\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iDetachBoxSetColorAttrib(Ihandle* ih, const char* value)\n{\n  (void)value;\n  IupUpdate(ih->firstchild);  /* only updates the bar */\n  return 1;  /* store value in hash table */\n}\n\nstatic int iDetachBoxSetOrientationAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle) /* only before map */\n    return 0;\n\n  if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->data->orientation = IDBOX_HORIZ;\n  else  /* Default = VERTICAL */\n    ih->data->orientation = IDBOX_VERT;\n\n  return 0;  /* do not store value in hash table */\n}\n\nstatic int iDetachBoxSetBarSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToInt(value, &ih->data->barsize) && ih->handle)\n    IupRefreshChildren(ih);  \n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iDetachBoxGetBarSizeAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->barsize);\n}\n\nstatic int iDetachBoxSetRestoreAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle *dlg = IupGetDialog(ih);\n\n  IupReparent(ih, ih->data->old_parent, ih->data->old_brother);\n\n  /* Restores and shows the bar handler when the element returns to its previous parent */\n  ih->data->barsize = 10;  /* default size */\n  IupShow(ih->firstchild);\n\n  /* Restores the cursor */\n  IupSetAttribute(ih->firstchild, \"CURSOR\", \"MOVE\");\n\n  IupRefresh(ih->data->old_parent);\n\n  /* Reset previous parent and brother */\n  ih->data->old_parent = NULL;\n  ih->data->old_brother = NULL;\n\n  IupDestroy(dlg);\n  (void)value;\n  return 0;\n}\n\nstatic int iDetachBoxSetDetachAttrib(Ihandle* ih, const char* value)\n{\n  IFnnii detachedCB = (IFnnii)IupGetCallback(ih, \"DETACHED_CB\");\n\n  /* Create new dialog */\n  Ihandle *new_parent = IupDialog(NULL);\n  Ihandle *old_dialog = IupGetDialog(ih);\n\n  /* Set new dialog as child of the current application */\n  IupSetAttributeHandle(new_parent, \"PARENTDIALOG\", old_dialog);\n\n  if (detachedCB)\n    detachedCB(ih, new_parent, 0, 0);\n\n  /* Save current parent and reference child */\n  ih->data->old_parent = ih->parent;\n  ih->data->old_brother = ih->brother;\n\n  IupMap(new_parent);\n\n  /* Sets the new parent */\n  IupReparent(ih, new_parent, NULL);\n\n  /* Hide canvas bar */\n  ih->data->barsize = 0;\n  IupHide(ih->firstchild);\n\n  /* Restores the cursor */\n  IupSetAttribute(ih->firstchild, \"CURSOR\", \"MOVE\");\n\n  /* Updates/redraws the layout of the dialog application */\n  IupRefresh(old_dialog);\n\n  IupSetAttribute(new_parent, \"RASTERSIZE\", NULL);\n  IupRefresh(new_parent);\n\n  /* Maps and shows the new dialog */\n  IupShow(new_parent);\n\n  (void)value;\n  return 0;\n}\n\nstatic int iDetachBoxSetShowGripAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->showgrip = 1;\n  else\n  {\n    ih->data->showgrip = 0;\n    iDetachBoxSetBarSizeAttrib(ih, \"5\");\n  }\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iDetachBoxGetShowGripAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->showgrip); \n}\n\nstatic char* iDetachBoxGetOldParentHandleAttrib(Ihandle* ih)\n{\n  return (char*)ih->data->old_parent;\n}\n\nstatic char* iDetachBoxGetOldBrotherHandleAttrib(Ihandle* ih)\n{\n  return (char*)ih->data->old_brother;\n}\n\n/*****************************************************************************\\\n|* Callbacks                                                                 *|\n\\*****************************************************************************/\n\nstatic int iDetachBoxK_Any_CB(Ihandle* ih, int key)\n{\n  if(ih->data->is_holding && key == K_ESC)  /* DRAG CANCEL */\n  {\n    ih->data->is_holding = 0;\n    /* Restore cursor */\n    IupSetAttribute(ih->firstchild, \"CURSOR\", \"MOVE\");\n  }\n\n  return IUP_DEFAULT;\n}\n\nstatic int iDetachBoxAction_CB(Ihandle* bar)\n{\n  Ihandle* ih = bar->parent;\n  IdrawCanvas* dc = iupDrawCreateCanvas(bar);\n\n  iupDrawParentBackground(dc);\n\n  if (ih->data->showgrip)\n  {\n    int i, w, h, x, y, count;\n    unsigned char r = 160, g = 160, b = 160, bg_r, bg_g, bg_b;\n    iupDrawGetSize(dc, &w, &h);\n\n    iupStrToRGB(IupGetAttribute(ih, \"COLOR\"), &r, &g, &b);\n    if (r+g+b > 3*190)\n      { bg_r = 100; bg_g = 100; bg_b = 100; }\n    else\n      { bg_r = 255; bg_g = 255; bg_b = 255; }\n\n    if (ih->data->orientation == IDBOX_VERT)\n    {\n      x = ih->data->barsize/2-1;\n      y = 2;\n      count = (h-2)/4;\n    }\n    else\n    {\n      x = 2;\n      y = ih->data->barsize/2-1;\n      count = (w-2)/4;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n      iupDrawRectangle(dc, x+1, y+1, x+2, y+2, bg_r, bg_g, bg_b, IUP_DRAW_FILL);\n      iupDrawRectangle(dc, x, y, x+1, y+1, r, g, b, IUP_DRAW_FILL);\n\n      if(i < count - 1)\n      {\n        iupDrawRectangle(dc, x+3, y+3, x+4, y+4, bg_r, bg_g, bg_b, IUP_DRAW_FILL);\n        iupDrawRectangle(dc, x+2, y+2, x+3, y+3, r, g, b, IUP_DRAW_FILL);\n      }\n\n      iupDrawRectangle(dc, x+5, y+1, x+6, y+2, bg_r, bg_g, bg_b, IUP_DRAW_FILL);\n      iupDrawRectangle(dc, x+4, y, x+5, y+1, r, g, b, IUP_DRAW_FILL);\n\n      if (ih->data->orientation == IDBOX_VERT)\n        y += 4;\n      else\n        x += 4;\n    }\n  }\n  else\n  {\n    int w, h, x, y;\n    unsigned char r = 160, g = 160, b = 160;\n    iupDrawGetSize(dc, &w, &h);\n\n    iupStrToRGB(IupGetAttribute(ih, \"COLOR\"), &r, &g, &b);\n\n    if (ih->data->orientation == IDBOX_VERT)\n    {\n      x = ih->data->barsize/2-1;\n      y = 2;\n    }\n    else\n    {\n      x = 2;\n      y = ih->data->barsize/2-1;\n    }\n\n    iupDrawRectangle(dc, x, y, x+w, y+h, r, g, b, IUP_DRAW_FILL);\n  }\n  \n  iupDrawFlush(dc);\n\n  iupDrawKillCanvas(dc);\n\n  return IUP_DEFAULT;\n}\n\nstatic int iDetachBoxButton_CB(Ihandle* bar, int button, int pressed, int x, int y, char* status)\n{\n  Ihandle* ih = bar->parent;\n  Ihandle* mainDlg = IupGetDialog(ih);\n\n  if (button != IUP_BUTTON1)\n    return IUP_DEFAULT;\n\n  if (!ih->data->is_holding && pressed)  /* DRAG BEGIN */\n  {\n    ih->data->is_holding = 1;\n    \n    /* Change cursor */\n    IupSetAttribute(bar, \"CURSOR\", \"IupDetachBoxCursor\");\n  }\n  else if (ih->data->is_holding && !pressed)  /* DRAG END */\n  {\n    Ihandle *new_parent;\n    IFnnii detachedCB = (IFnnii)IupGetCallback(ih, \"DETACHED_CB\");\n    int cur_x, cur_y;\n\n    ih->data->is_holding = 0;\n\n    iupStrToIntInt(IupGetGlobal(\"CURSORPOS\"), &cur_x, &cur_y, 'x');\n\n    /* Create new dialog */\n    new_parent = IupDialog(NULL);\n\n    /* Set new dialog as child of the current application */\n    IupSetAttributeHandle(new_parent, \"PARENTDIALOG\", mainDlg);\n\n    if (detachedCB)\n    {\n      int ret = detachedCB(ih, new_parent, cur_x, cur_y);\n      if (ret == IUP_IGNORE)\n      {\n        IupDestroy(new_parent);\n        return IUP_DEFAULT;\n      }\n    }\n\n    /* Save current parent and reference child */\n    ih->data->old_parent = ih->parent;\n    ih->data->old_brother = ih->brother;\n\n    IupMap(new_parent);\n\n    /* Sets the new parent */\n    IupReparent(ih, new_parent, NULL);\n\n    /* Restores the cursor */\n    IupSetAttribute(bar, \"CURSOR\", \"MOVE\");\n\n    /* Hide canvas bar */\n    ih->data->barsize = 0;\n    IupHide(bar);\n\n    /* Updates/redraws the layout of the dialog application */\n    IupRefresh(mainDlg);\n\n    IupSetAttribute(new_parent, \"RASTERSIZE\", NULL);\n    IupRefresh(new_parent);\n\n    /* Maps and shows the new dialog */\n    IupShowXY(new_parent, cur_x, cur_y);\n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iDetachBoxFocus_CB(Ihandle* bar, int focus)\n{\n  Ihandle* ih = bar->parent;\n\n  if (!ih || focus) /* use only kill focus */\n    return IUP_DEFAULT;\n\n  if (ih->data->is_holding)\n    ih->data->is_holding = 0;\n\n  return IUP_DEFAULT;\n}\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\nstatic void iDetachBoxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0;\n\n  /* bar */\n  if (ih->data->orientation == IDBOX_VERT)\n    natural_w += ih->data->barsize;\n  else\n    natural_h += ih->data->barsize;\n\n  if (ih->firstchild->brother)\n  {\n    Ihandle* child = ih->firstchild->brother;\n\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    if (ih->data->orientation == IDBOX_VERT)\n    {\n      natural_w += child->naturalwidth;\n      natural_h = iupMAX(natural_h, child->naturalheight);\n    }\n    else  /* IDBOX_HORIZ */\n    {\n      natural_w = iupMAX(natural_w, child->naturalwidth);\n      natural_h += child->naturalheight;\n    }\n\n    *children_expand |= child->expand;\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\nstatic void iDetachBoxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  /* bar */\n  if (ih->data->orientation == IDBOX_VERT)\n  {\n    ih->firstchild->currentwidth  = ih->data->barsize;\n    ih->firstchild->currentheight = ih->currentheight;\n  }\n  else  /* IDBOX_HORIZ */\n  {\n    ih->firstchild->currentwidth  = ih->currentwidth;\n    ih->firstchild->currentheight = ih->data->barsize;\n  }\n\n  /* child */\n  if (ih->firstchild->brother)\n  {\n    int width = ih->currentwidth;\n    int height = ih->currentheight;\n\n    if (ih->data->orientation == IDBOX_VERT)\n      width -= ih->data->barsize;\n    else\n      height -= ih->data->barsize;\n\n    if (width < 0) width = 0;\n    if (height < 0) height = 0;\n\n    iupBaseSetCurrentSize(ih->firstchild->brother, width, height, shrink);\n  }\n}\n\nstatic void iDetachBoxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  /* bar */\n  iupBaseSetPosition(ih->firstchild, x, y);\n\n  /* child */\n  if (ih->data->orientation == IDBOX_VERT)\n  {\n    x += ih->data->barsize;\n    iupBaseSetPosition(ih->firstchild->brother, x, y);\n  }\n  else  /* IDBOX_HORIZ */\n  {\n    y += ih->data->barsize;\n    iupBaseSetPosition(ih->firstchild->brother, x, y);\n  }\n}\n\nstatic int iDetachBoxCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle* bar;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->orientation = IDBOX_VERT;\n  ih->data->barsize = 10;\n  ih->data->showgrip = 1;\n\n  bar = IupCanvas(NULL);\n  bar->flags |= IUP_INTERNAL;\n  iupChildTreeAppend(ih, bar);  /* bar will always be the firstchild */\n\n  IupSetAttribute(bar, \"CANFOCUS\", \"NO\");\n  IupSetAttribute(bar, \"BORDER\", \"NO\");\n  IupSetAttribute(bar, \"EXPAND\", \"NO\");\n  IupSetAttribute(bar, \"CURSOR\", \"MOVE\");\n\n  /* Setting canvas bar callbacks */\n  IupSetCallback(bar, \"BUTTON_CB\", (Icallback) iDetachBoxButton_CB);\n  IupSetCallback(bar, \"FOCUS_CB\", (Icallback) iDetachBoxFocus_CB);\n  IupSetCallback(bar, \"ACTION\", (Icallback) iDetachBoxAction_CB);\n\n  /* Setting element callbacks */\n  IupSetCallback(ih, \"K_ANY\", (Icallback) iDetachBoxK_Any_CB);\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iDetachBoxCreateCursor(void)\n{\n  Ihandle *imgcursor;\n  unsigned char detach_img_cur[16*16] = \n  {\n    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    0,0,1,4,4,4,4,4,4,4,4,4,4,4,4,1,\n    0,0,1,4,4,4,4,4,4,4,4,4,4,4,4,1,\n    0,0,1,3,3,3,3,3,3,3,3,3,3,3,3,1,\n    0,0,1,3,3,3,2,2,2,3,3,3,3,3,3,1,\n    1,1,1,1,1,1,2,2,2,1,1,1,1,1,3,1,\n    1,4,4,4,4,4,2,2,2,4,4,4,4,1,3,1,\n    1,4,4,4,4,4,2,2,2,4,4,4,4,1,1,1,\n    1,3,3,3,3,3,2,2,2,3,3,3,3,1,0,0,\n    1,3,3,3,2,2,2,2,2,2,2,3,3,1,0,0,\n    1,3,3,3,3,2,2,2,2,2,3,3,3,1,0,0,\n    1,3,3,3,3,3,2,2,2,3,3,3,3,1,0,0,\n    1,3,3,3,3,3,3,2,3,3,3,3,3,1,0,0,\n    1,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0\n  };\n\n  imgcursor = IupImage(16, 16, detach_img_cur);\n  IupSetAttribute(imgcursor, \"0\", \"BGCOLOR\"); \n  IupSetAttribute(imgcursor, \"1\", \"0 0 0\"); \n  IupSetAttribute(imgcursor, \"2\", \"110 150 255\"); \n  IupSetAttribute(imgcursor, \"3\", \"255 255 255\"); \n  IupSetAttribute(imgcursor, \"4\", \"64 92 255\"); \n  IupSetHandle(\"IupDetachBoxCursor\", imgcursor); \n}\n\nIclass* iupDetachBoxNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name   = \"detachbox\";\n  ic->format = \"h\";   /* one Ihandle* */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype  = IUP_CHILDMANY+2; /* canvas+child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New    = iupDetachBoxNewClass;\n  ic->Create = iDetachBoxCreateMethod;\n  ic->Map    = iupBaseTypeVoidMapMethod;\n\n  ic->ComputeNaturalSize     = iDetachBoxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iDetachBoxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition    = iDetachBoxSetChildrenPositionMethod;\n\n  iupClassRegisterCallback(ic, \"DETACHED_CB\", \"\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iDetachBoxGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* IupDetachBox only */\n  iupClassRegisterAttribute(ic, \"COLOR\", NULL, iDetachBoxSetColorAttrib, IUPAF_SAMEASSYSTEM, \"160 160 160\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", NULL, iDetachBoxSetOrientationAttrib, IUPAF_SAMEASSYSTEM, \"VERTICAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BARSIZE\", iDetachBoxGetBarSizeAttrib, iDetachBoxSetBarSizeAttrib, IUPAF_SAMEASSYSTEM, \"10\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWGRIP\", iDetachBoxGetShowGripAttrib, iDetachBoxSetShowGripAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"OLDPARENT_HANDLE\", iDetachBoxGetOldParentHandleAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT | IUPAF_IHANDLE|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"OLDBROTHER_HANDLE\", iDetachBoxGetOldBrotherHandleAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT | IUPAF_IHANDLE | IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"RESTORE\", NULL, iDetachBoxSetRestoreAttrib, NULL, NULL, IUPAF_WRITEONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DETACH\", NULL, iDetachBoxSetDetachAttrib, NULL, NULL, IUPAF_WRITEONLY | IUPAF_NO_INHERIT);\n  \n  if (!IupGetHandle(\"IupDetachBoxCursor\"))\n    iDetachBoxCreateCursor();\n\n  return ic;\n}\n\nIhandle* IupDetachBox(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"detachbox\", children);\n}\n","/** \\file\n * \\brief IupDialog class\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_class.h\"\n#include \"iup_object.h\"\n#include \"iup_dlglist.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_focus.h\"\n#include \"iup_str.h\"\n#define _IUPDLG_PRIVATE\n#include \"iup_dialog.h\"\n\n\nstatic int dlg_popup_level = 1;\n\nInativeHandle* iupDialogGetNativeParent(Ihandle* ih)\n{\n  Ihandle* parent = IupGetAttributeHandle(ih, \"PARENTDIALOG\");\n  if (parent && parent->handle)\n    return parent->handle;\n  else\n    return (InativeHandle*)iupAttribGet(ih, \"NATIVEPARENT\");\n}\n\nint iupDialogSetClientSizeAttrib(Ihandle* ih, const char* value)\n{\n  int width = 0, height = 0;\n  int border = 0, caption = 0, menu = 0;\n  iupStrToIntInt(value, &width, &height, 'x');\n  iupdrvDialogGetDecoration(ih, &border, &caption, &menu);\n  if (width) width = width + 2*border;\n  if (height) height = height + 2*border + caption + menu;\n  IupSetfAttribute(ih, \"RASTERSIZE\", \"%dx%d\", width, height);\n  return 0;\n}\n\nstatic void iDialogAdjustPos(Ihandle *ih, int *x, int *y)\n{\n  int cursor_x = 0, cursor_y = 0;\n  int screen_width = 0, screen_height = 0;\n  int current_x = 0, current_y = 0;\n  int parent_x = 0, parent_y = 0;\n\n  /* the dialog is already mapped here */\n\n  if (*x == IUP_CURRENT || *y == IUP_CURRENT)\n  {\n    /* if first time, there is no current position */\n    if (!ih->data->first_show)\n    {\n      int center = IUP_CENTER;\n      InativeHandle* parent = iupDialogGetNativeParent(ih);\n      if (parent)\n        center = IUP_CENTERPARENT;\n\n      if (*x == IUP_CURRENT) *x = center;\n      if (*y == IUP_CURRENT) *y = center;\n    }\n    else\n      iupdrvDialogGetPosition(ih, NULL, &current_x, &current_y);\n  }\n\n  if (*x == IUP_CENTER || *y == IUP_CENTER ||\n      *x == IUP_RIGHT  || *y == IUP_RIGHT ||\n      *x == IUP_CENTERPARENT || *y == IUP_CENTERPARENT)\n    iupdrvGetScreenSize(&screen_width, &screen_height);\n\n  if (*x == IUP_CENTERPARENT || *y == IUP_CENTERPARENT)\n  {\n    InativeHandle* parent = iupDialogGetNativeParent(ih);\n    if (parent)\n    {\n      Ihandle* ih_parent = IupGetAttributeHandle(ih, \"PARENTDIALOG\");\n\n      iupdrvDialogGetPosition(ih_parent, parent, &parent_x, &parent_y);\n\n      if (*x == IUP_CENTERPARENT && *y == IUP_CENTERPARENT)\n        iupdrvDialogGetSize(ih_parent, parent, &screen_width, &screen_height);\n      else if (*x == IUP_CENTERPARENT)\n        iupdrvDialogGetSize(ih_parent, parent, &screen_width, NULL);\n      else if (*y == IUP_CENTERPARENT)\n        iupdrvDialogGetSize(ih_parent, parent, NULL, &screen_height);\n    }\n  }\n\n  if (*x == IUP_MOUSEPOS || *y == IUP_MOUSEPOS)\n    iupdrvGetCursorPos(&cursor_x, &cursor_y);\n\n  if (iupAttribGetBoolean(ih, \"MDICHILD\"))\n  {\n    Ihandle* client = (Ihandle*)iupAttribGet(ih, \"MDICLIENT_HANDLE\");\n    if (client)\n    {\n      /* position is relative to mdi client */\n      parent_x = 0; \n      parent_y = 0;\n\n      /* screen size is now the size of the mdi client */\n      screen_width = client->currentwidth;\n      screen_height = client->currentheight;\n\n      iupdrvScreenToClient(client, &current_x, &current_y);\n      iupdrvScreenToClient(client, &cursor_x, &cursor_y);\n    }\n  }\n\n  switch (*x)\n  {\n  case IUP_CENTERPARENT:\n    *x = (screen_width - ih->currentwidth)/2 + parent_x;\n    break;\n  case IUP_CENTER:\n    *x = (screen_width - ih->currentwidth)/2;\n    break;\n  case IUP_LEFT:\n    *x = 0;\n    break;\n  case IUP_RIGHT:\n    *x = screen_width - ih->currentwidth;\n    break;\n  case IUP_MOUSEPOS:\n    *x = cursor_x;\n    break;\n  case IUP_CURRENT:\n    *x = current_x;\n    break;\n  }\n\n  switch (*y)\n  {\n  case IUP_CENTERPARENT:\n    *y = (screen_height - ih->currentheight)/2 + parent_y;\n    break;\n  case IUP_CENTER:\n    *y = (screen_height - ih->currentheight)/2;\n    break;\n  case IUP_LEFT:\n    *y = 0;\n    break;\n  case IUP_RIGHT:\n    *y = screen_height - ih->currentheight;\n    break;\n  case IUP_MOUSEPOS:\n    *y = cursor_y;\n    break;\n  case IUP_CURRENT:\n    *y = current_y;\n    break;\n  }\n\n  iupdrvAddScreenOffset(x, y, 1);\n}\n\nvoid iupDialogEnterModal(Ihandle* ih_popup, int popup_level)\n{\n  Ihandle *ih;\n\n  assert(popup_level == dlg_popup_level);\n\n  /* disable all visible dialogs, and mark popup level */\n  for (ih = iupDlgListFirst(); ih; ih = iupDlgListNext())\n  {\n    if (ih != ih_popup &&\n      ih->handle &&\n      iupdrvDialogIsVisible(ih) &&\n      ih->data->popup_level == 0)\n    {\n      iupdrvSetActive(ih, 0);\n      ih->data->popup_level = dlg_popup_level;\n    }\n  }\n\n  dlg_popup_level++;\n}\n\nstatic void iDialogSetModal(Ihandle* ih_popup)\n{\n  iupAttribSet(ih_popup, \"MODAL\", \"YES\");\n\n  {\n    IFi cb = (IFi)IupGetFunction(\"GLOBALENTERMODAL_CB\");\n    int popup_level = dlg_popup_level;  /* save before it is changed */\n\n    iupDialogEnterModal(ih_popup, popup_level);\n\n    if (cb)\n      cb(popup_level);\n  }\n}\n\nvoid iupDialogLeaveModal(int popup_level)\n{\n  Ihandle *ih;\n\n  assert(popup_level == dlg_popup_level);\n\n  /* must enable all visible dialogs at the marked popup level */\n  for (ih = iupDlgListFirst(); ih; ih = iupDlgListNext())\n  {\n    if (ih->handle)\n    {\n      if (ih->data->popup_level == dlg_popup_level - 1)\n      {\n        iupdrvSetActive(ih, 1);\n        ih->data->popup_level = 0;\n      }\n    }\n  }\n\n  dlg_popup_level--;\n}\n\nstatic void iDialogUnSetModal(Ihandle* ih_popup)\n{\n  if (!iupAttribGetBoolean(ih_popup, \"MODAL\"))\n    return;\n\n  iupAttribSet(ih_popup, \"MODAL\", NULL);\n\n  {\n    IFi cb = (IFi)IupGetFunction(\"GLOBALLEAVEMODAL_CB\");\n    int popup_level = dlg_popup_level;  /* save before it is changed */\n\n    iupDialogLeaveModal(popup_level);\n\n    if (cb)\n      cb(popup_level);\n  }\n}\n\nstatic int iDialogCreateMethod(Ihandle* ih, void** params)\n{\n ih->data = iupALLOCCTRLDATA();\n\n  ih->data->child_id = 100; /* initial number */\n  ih->data->show_state = IUP_HIDE;\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  iupDlgListAdd(ih);\n\n  return IUP_NOERROR;\n}\n\nstatic void iDialogDestroyMethod(Ihandle* ih)\n{\n  iupDlgListRemove(ih);\n}\n\nstatic int iDialogSetMenuAttrib(Ihandle* ih, const char* value);\n\nstatic void iDialogComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int decorwidth, decorheight;\n  Ihandle* child = ih->firstchild;\n\n  /* if does not have a menu, but the attribute is defined,\n     try to update the menu before retrieving the decoration. */\n  char* value = iupAttribGet(ih, \"MENU\");\n  if (!ih->data->menu && value)\n    iDialogSetMenuAttrib(ih, value);\n\n  iupDialogGetDecorSize(ih, &decorwidth, &decorheight);\n  *w = decorwidth;\n  *h = decorheight;\n\n  if (child)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    *children_expand = child->expand;\n    *w += child->naturalwidth;\n    *h += child->naturalheight;\n  }\n}\n\nstatic void iDialogSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  int decorwidth, decorheight, client_width, client_height;\n\n  if (shrink)\n  {\n    client_width = ih->currentwidth;\n    client_height = ih->currentheight;\n  }\n  else\n  {\n    client_width = iupMAX(ih->naturalwidth, ih->currentwidth);\n    client_height = iupMAX(ih->naturalheight, ih->currentheight);\n  }\n\n  iupDialogGetDecorSize(ih, &decorwidth, &decorheight);\n\n  client_width  -= decorwidth;\n  client_height -= decorheight;\n  if (client_width < 0) client_width = 0;\n  if (client_height < 0) client_height = 0;\n\n  iupBaseSetCurrentSize(ih->firstchild, client_width, client_height, shrink);\n}\n\nstatic void iDialogSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild)\n  {\n    char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n    /* Native container, position is reset */\n    x = 0;\n    y = 0;\n\n    if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n    /* Child coordinates are relative to client left-top corner. */\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n}\n\nstatic void iDialogAfterHide(Ihandle* ih)\n{\n  IFni show_cb;\n\n  /* process all pending messages, make sure the dialog is hidden */\n  IupFlush();\n\n  show_cb = (IFni)IupGetCallback(ih, \"SHOW_CB\");\n  if (show_cb && show_cb(ih, ih->data->show_state) == IUP_CLOSE)\n  {\n    IupExitLoop();\n  }\n}\n\nstatic void iDialogAfterShow(Ihandle* ih)\n{\n  Ihandle* old_focus;\n  IFni show_cb;\n  int show_state;\n\n  /* process all pending messages, make sure the dialog is visible */\n  IupFlush();\n\n  old_focus = IupGetFocus();\n  show_state = ih->data->show_state;\n\n  show_cb = (IFni)IupGetCallback(ih, \"SHOW_CB\");\n  if (show_cb && show_cb(ih, show_state) == IUP_CLOSE)\n  {\n    IupExitLoop();\n    return;\n  }\n\n  if (show_state == IUP_SHOW)\n  {\n    if (show_cb)\n      IupFlush();  /* again to update focus */\n\n    /* do it only if show_cb did NOT changed the current focus */\n    if (old_focus == IupGetFocus())\n    {\n      Ihandle *startfocus = IupGetAttributeHandle(ih, \"STARTFOCUS\");\n      if (startfocus)\n        IupSetFocus(startfocus);\n      else\n        IupNextField(ih);\n    }\n  }\n}\n\nint iupDialogGetChildId(Ihandle* ih)\n{\n  int id;\n  ih = IupGetDialog(ih);\n  if (!ih) return -1;\n  id = ih->data->child_id;\n  ih->data->child_id = id+1;\n  return id;\n}\n\nchar* iupDialogGetChildIdStr(Ihandle* ih)\n{\n  Ihandle* dialog = IupGetDialog(ih);\n  return iupStrReturnStrf(\"iup-%s-%d\", ih->iclass->name, dialog->data->child_id);\n}\n\nstatic void iDialogListCheckLastVisible()\n{\n  if (iupDlgListVisibleCount() <= 0)\n  {\n    /* if this is the last window visible,\n    exit message loop except when LOCKLOOP==YES */\n    if (!iupStrBoolean(IupGetGlobal(\"LOCKLOOP\")))\n    {\n      IupExitLoop();\n    }\n  }\n}\n\nint iupDialogPopup(Ihandle* ih, int x, int y)\n{\n  int was_visible;\n\n  int ret = iupClassObjectDlgPopup(ih, x, y);\n  if (ret != IUP_INVALID) /* IUP_INVALID means it is not implemented */\n    return ret;\n\n  ih->data->show_state = IUP_SHOW;\n\n  /* save visible state before iupdrvDialogSetPlacement */\n  /* because it can also show the window when changing placement. */\n  was_visible = iupdrvDialogIsVisible(ih); \n\n  /* Update the position and placement */\n  if (!iupdrvDialogSetPlacement(ih))\n  {\n    iDialogAdjustPos(ih, &x, &y);\n    iupdrvDialogSetPosition(ih, x, y);\n  }\n\n  if (was_visible) /* already visible */\n  {\n    /* only re-show to raise the window */\n    iupdrvDialogSetVisible(ih, 1);\n    \n    /* flush, then process show_cb and startfocus */\n    iDialogAfterShow(ih);\n    return IUP_NOERROR; \n  }\n\n  if (iupAttribGetBoolean(ih, \"MODAL\")) /* already a popup */\n    return IUP_NOERROR; \n\n  iDialogSetModal(ih);\n\n  ih->data->first_show = 1;\n\n  /* actually show the window */\n  /* test if placement already turned the dialog visible */\n  if (!iupdrvDialogIsVisible(ih))\n    iupdrvDialogSetVisible(ih, 1);\n\n  /* increment visible count */\n  iupDlgListVisibleInc();\n    \n  /* flush, then process show_cb and startfocus */\n  iDialogAfterShow(ih);\n\n  /* interrupt processing here */\n  IupMainLoop();\n\n  /* if window is still valid (IupDestroy not called), \n     hide the dialog if still visible. */\n  if (iupObjectCheck(ih))\n  {\n    iDialogUnSetModal(ih);\n    iupDialogHide(ih);\n  }\n  else\n    iDialogListCheckLastVisible();\n\n  return IUP_NOERROR;\n}\n\nint iupDialogShowXY(Ihandle* ih, int x, int y)\n{\n  int was_visible;\n\n  /* Calling IupShow for a visible dialog shown with IupPopup does nothing. */\n  if (iupAttribGetBoolean(ih, \"MODAL\")) /* already a popup */\n    return IUP_NOERROR; \n\n  if (ih->data->popup_level != 0)\n  {\n    /* was disabled by a Popup, re-enable it */\n    iupdrvSetActive(ih, 1);\n    ih->data->popup_level = 0; /* Now it is at the current popup level */\n  }\n\n  /* save visible state before iupdrvDialogSetPlacement */\n  /* because it can also show the window when changing placement. */\n  was_visible = iupdrvDialogIsVisible(ih); \n\n  /* Update the position and placement */\n  if (!iupdrvDialogSetPlacement(ih))\n  {\n    iDialogAdjustPos(ih, &x, &y);\n    iupdrvDialogSetPosition(ih, x, y);\n  }\n\n  if (was_visible) /* already visible */\n  {\n    /* only re-show to raise the window */\n    iupdrvDialogSetVisible(ih, 1);\n    \n    /* flush, then process show_cb and startfocus */\n    iDialogAfterShow(ih);\n    return IUP_NOERROR; \n  }\n\n  ih->data->first_show = 1;\n                          \n  /* actually show the window */\n  /* test if placement turn the dialog visible */\n  if (!iupdrvDialogIsVisible(ih))\n    iupdrvDialogSetVisible(ih, 1);\n\n  /* increment visible count */\n  iupDlgListVisibleInc();\n\n  /* flush, then process show_cb and startfocus */\n  iDialogAfterShow(ih);\n\n  return IUP_NOERROR;\n}\n\nvoid iupDialogHide(Ihandle* ih)\n{\n  /* hidden at the system and marked hidden in IUP */\n  if (!iupdrvDialogIsVisible(ih) && ih->data->show_state == IUP_HIDE) \n    return;\n\n  /* marked hidden in IUP */\n  ih->data->show_state = IUP_HIDE;\n\n  /* if called IupHide for a Popup window */\n  if (iupAttribGetBoolean(ih, \"MODAL\"))\n  {\n    iDialogUnSetModal(ih);\n    IupExitLoop();\n  }\n\n  ih->data->ignore_resize = 1;\n\n  /* actually hide the window */\n  iupdrvDialogSetVisible(ih, 0);\n\n  ih->data->ignore_resize = 0;\n\n  /* decrement visible count */\n  iupDlgListVisibleDec();\n    \n  /* process flush and process show_cb */\n  iDialogAfterHide(ih);\n\n  iDialogListCheckLastVisible();\n}\n\n\n/****************************************************************/\n\n\nstatic int iDialogSizeGetScale(const char* sz)\n{\n  if (!sz || sz[0] == 0) return 0;\n  if (iupStrEqualNoCase(sz, \"FULL\"))     return 1;\n  if (iupStrEqualNoCase(sz, \"HALF\"))     return 2;\n  if (iupStrEqualNoCase(sz, \"THIRD\"))    return 3;\n  if (iupStrEqualNoCase(sz, \"QUARTER\"))  return 4;\n  if (iupStrEqualNoCase(sz, \"EIGHTH\"))   return 8;\n  return 0;\n}\n\nstatic int iDialogSetSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    char *sh, sw[40];\n    strcpy(sw, value);\n    sh = strchr(sw, 'x');\n    if (!sh)\n      sh = \"\";\n    else\n    {\n      *sh = '\\0';  /* to mark the end of sw */\n      ++sh;\n    }\n\n    {\n      int charwidth, charheight;\n      int screen_width, screen_height;\n      int wscale = iDialogSizeGetScale(sw);\n      int hscale = iDialogSizeGetScale(sh);\n\n      int width = 0, height = 0; \n      iupStrToIntInt(value, &width, &height, 'x');\n      if (width < 0) width = 0;\n      if (height < 0) height = 0;\n\n      iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n\n      /* desktop size, excluding task bars and menu bars */\n      iupdrvGetScreenSize(&screen_width, &screen_height);\n\n      if (wscale)\n        width = screen_width/wscale;\n      else\n        width = iupWIDTH2RASTER(width, charwidth);\n\n      if (hscale)\n        height = screen_height/hscale;\n      else\n        height = iupHEIGHT2RASTER(height, charheight);\n\n      ih->userwidth = width;\n      ih->userheight = height;\n    }\n  }\n\n  /* must reset the current size,  */\n  /* so the user or the natural size will be used to resize the dialog */\n  ih->currentwidth = 0;\n  ih->currentheight = 0;\n\n  return 0;\n}\n\nstatic char* iDialogGetSizeAttrib(Ihandle* ih)\n{\n  int charwidth, charheight, width, height;\n\n  if (ih->handle)\n  {\n    /* ih->currentwidth and/or ih->currentheight could have been reset in SetSize */\n    iupdrvDialogGetSize(ih, NULL, &width, &height);\n  }\n  else\n  {\n    width = ih->userwidth;\n    height = ih->userheight;\n  }\n\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  if (charwidth == 0 || charheight == 0)\n    return NULL;  /* if font failed get from the hash table */\n\n  return iupStrReturnIntInt(iupRASTER2WIDTH(width, charwidth), iupRASTER2HEIGHT(height, charheight), 'x');\n}\n\nstatic int iDialogSetRasterSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int w = 0, h = 0;\n    iupStrToIntInt(value, &w, &h, 'x');\n    if (w < 0) w = 0;\n    if (h < 0) h = 0;\n    ih->userwidth = w;\n    ih->userheight = h;\n  }\n\n  /* must reset the current size also,  */\n  /* so the user or the natural size will be used to resize the dialog */\n  ih->currentwidth = 0;\n  ih->currentheight = 0;\n\n  return 0;\n}\n\nstatic char* iDialogGetRasterSizeAttrib(Ihandle* ih)\n{\n  int width, height;\n\n  if (ih->handle)\n  {\n    /* ih->currentwidth and/or ih->currentheight could have been reset in SetRasterSize */\n    iupdrvDialogGetSize(ih, NULL, &width, &height);\n  }\n  else\n  {\n    width = ih->userwidth;\n    height = ih->userheight;\n  }\n\n  if (!width && !height)\n    return NULL;\n\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iDialogSetNActiveAttrib(Ihandle* ih, const char* value)\n{\n  iupdrvSetActive(ih, iupStrBoolean(value));\n  return 0;\n}\n\nstatic int iDialogSetVisibleAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    IupShow(ih);\n  else\n    IupHide(ih);\n  return 0;\n}\n\nvoid iupDialogUpdatePosition(Ihandle* ih)\n{\n  /* This funtion is used only by pre-defined popup native dialogs */\n\n  int x = iupAttribGetInt(ih, \"_IUPDLG_X\");\n  int y = iupAttribGetInt(ih, \"_IUPDLG_Y\");\n\n  iupdrvDialogGetSize(ih, NULL, &(ih->currentwidth), &(ih->currentheight));\n\n  /* handle always as visible for the first time */\n  ih->data->first_show = 0;\n\n  iDialogAdjustPos(ih, &x, &y);\n  iupdrvDialogSetPosition(ih, x, y);\n}\n\nvoid iupDialogGetDecorSize(Ihandle* ih, int *decorwidth, int *decorheight)\n{\n  int border, caption, menu;\n  iupdrvDialogGetDecoration(ih, &border, &caption, &menu);\n\n  *decorwidth = 2*border;\n  *decorheight = 2*border + caption + menu;\n}\n\nstatic int iDialogSetHideTaskbarAttrib(Ihandle *ih, const char *value)\n{\n  iupdrvDialogSetVisible(ih, !iupStrBoolean(value));\n  return 0;\n}\n\nstatic int iDialogSetDialogFrameAttrib(Ihandle *ih, const char *value)\n{\n  if (iupStrBoolean(value))\n  {\n    iupAttribSet(ih, \"RESIZE\", \"NO\");\n    iupAttribSet(ih, \"MAXBOX\", \"NO\");\n    iupAttribSet(ih, \"MINBOX\", \"NO\");\n  }\n  else\n  {\n    iupAttribSet(ih, \"RESIZE\", NULL);\n    iupAttribSet(ih, \"MAXBOX\", NULL);\n    iupAttribSet(ih, \"MINBOX\", NULL);\n  }\n  return 1;\n}\n\nstatic char* iDialogGetXAttrib(Ihandle *ih)\n{\n  int x = 0;\n  iupdrvDialogGetPosition(ih, NULL, &x, NULL);\n  return iupStrReturnInt(x);\n}\n\nstatic char* iDialogGetYAttrib(Ihandle *ih)\n{\n  int y = 0;\n  iupdrvDialogGetPosition(ih, NULL, NULL, &y);\n  return iupStrReturnInt(y);\n}\n\nstatic char* iDialogGetScreenPositionAttrib(Ihandle *ih)\n{\n  int x = 0, y = 0;\n  iupdrvDialogGetPosition(ih, NULL, &x, &y);\n  return iupStrReturnIntInt(x, y, ',');\n}\n\nstatic int iDialogSetMenuAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)\n  {\n    Ihandle* menu = IupGetHandle(value);\n    ih->data->menu = menu;\n    return 1;\n  }\n\n  if (!value)\n  {\n    if (ih->data->menu && ih->data->menu->handle)\n    {\n      ih->data->ignore_resize = 1;\n      IupUnmap(ih->data->menu);  /* this will remove the menu from the dialog */\n      ih->data->ignore_resize = 0;\n\n      ih->data->menu = NULL;\n    }\n  }\n  else\n  {\n    Ihandle* menu = IupGetHandle(value);\n    if (!menu || menu->iclass->nativetype != IUP_TYPEMENU || menu->parent)\n      return 0;\n\n    /* already the current menu and it is mapped */\n    if (ih->data->menu && ih->data->menu==menu && menu->handle)\n      return 1;\n\n    /* the current menu is mapped, so unmap it */\n    if (ih->data->menu && ih->data->menu->handle && ih->data->menu!=menu)\n    {\n      ih->data->ignore_resize = 1;\n      IupUnmap(ih->data->menu);   /* this will remove the menu from the dialog */\n      ih->data->ignore_resize = 0;\n    }\n\n    ih->data->menu = menu;\n\n    menu->parent = ih;    /* use this to create a menu bar instead of a popup menu */\n\n    ih->data->ignore_resize = 1;\n    IupMap(menu);     /* this will automatically add the menu to the dialog */\n    ih->data->ignore_resize = 0;\n  }\n  return 1;\n}\n\n\n/****************************************************************/\n\n\nIhandle* IupDialog(Ihandle* child)\n{\n  void *children[2];\n  children[0] = child;\n  children[1] = NULL;\n  return IupCreatev(\"dialog\", children);\n}\n\nIclass* iupDialogNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"dialog\";\n  ic->format = \"h\"; /* one Ihandle* */\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->childtype = IUP_CHILDMANY+1;  /* one child */\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupDialogNewClass;\n  ic->Create = iDialogCreateMethod;\n  ic->Destroy = iDialogDestroyMethod;\n  ic->ComputeNaturalSize = iDialogComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iDialogSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iDialogSetChildrenPositionMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"SHOW_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"RESIZE_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"CLOSE_CB\", \"\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Attribute functions */\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"SIZE\", iDialogGetSizeAttrib, iDialogSetSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iDialogGetRasterSizeAttrib, iDialogSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"POSITION\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED); /* forbidden in dialog */\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Native Container */\n  iupClassRegisterAttribute(ic, \"CHILDOFFSET\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Dialog only */\n  iupClassRegisterAttribute(ic, \"NACTIVE\", iupBaseGetActiveAttrib, iDialogSetNActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT | IUPAF_NO_INHERIT);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* Overwrite Visual */\n  /* the only case where VISIBLE default is NO, and must not be propagated to the dialog children */\n  iupClassRegisterAttribute(ic, \"VISIBLE\", iupBaseGetVisibleAttrib, iDialogSetVisibleAttrib, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NO_SAVE|IUPAF_NO_INHERIT);\n\n  /* X and Y here are at the top left corner of the window, not the client area. */\n  iupClassRegisterAttribute(ic, \"X\", iDialogGetXAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"Y\", iDialogGetYAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCREENPOSITION\", iDialogGetScreenPositionAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);\n\n  /* IupDialog only */\n  iupClassRegisterAttribute(ic, \"MENU\", NULL, iDialogSetMenuAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CURSOR\", NULL, iupdrvBaseSetCursorAttrib, IUPAF_SAMEASSYSTEM, \"ARROW\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HIDETASKBAR\", NULL, iDialogSetHideTaskbarAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MAXBOX\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MENUBOX\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MINBOX\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RESIZE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BORDER\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  \n  iupClassRegisterAttribute(ic, \"DEFAULTENTER\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DEFAULTESC\",   NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DIALOGFRAME\",  NULL, iDialogSetDialogFrameAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PARENTDIALOG\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHRINK\",       NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"STARTFOCUS\",   NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MODAL\",        NULL, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PLACEMENT\",    NULL, NULL, \"NORMAL\", NULL, IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"NATIVEPARENT\", NULL, NULL, NULL, NULL, IUPAF_NO_STRING);\n\n  iupdrvDialogInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief list of all created dialogs\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n\n#include \"iup.h\"\n\n#include \"iup_dlglist.h\"\n#include \"iup_object.h\"\n#include \"iup_assert.h\"\n\n\ntypedef struct Idiallst_\n{\n  Ihandle *ih;\n  struct Idiallst_ *next;\n} Idiallst;\n\nstatic Idiallst *idlglist = NULL;  /* list of all created dialogs */\nstatic int idlg_count = 0;\n\nvoid iupDlgListAdd(Ihandle *ih)\n{\n  if (ih)\n  {\n    Idiallst *p=(Idiallst *)malloc(sizeof(Idiallst));\n    if (!p)\n      return;\n    p->ih = ih;\n    p->next = idlglist;\n    idlglist = p;\n    idlg_count++;\n  }\n}\n\nvoid iupDlgListRemove(Ihandle *ih)\n{\n  if (!idlglist || !ih)\n    return;\n\n  if (idlglist->ih == ih)    /* ih is header */\n  {\n    Idiallst *p = idlglist->next;\n    free(idlglist);\n    idlglist = p;\n    idlg_count--;\n  }\n  else\n  {\n    Idiallst *p;    /* current pointer */\n    Idiallst *b;    /* before pointer */\n    for (b = idlglist, p = idlglist->next; p; b = p, p = p->next)\n    {\n      if (p->ih == ih)\n      {\n        b->next = p->next;\n        free (p);\n        idlg_count--;\n        return;\n      }\n    }\n  }\n}\n\nstatic Idiallst *idlg_first = NULL;\n\nint iupDlgListCount(void)\n{\n  return idlg_count;\n}\n\nIhandle *iupDlgListFirst (void)\n{\n  idlg_first = idlglist;\n  return iupDlgListNext();\n}\n\nIhandle *iupDlgListNext (void)\n{\n  Ihandle *ih = NULL;\n  if (idlg_first)\n  {\n    ih = idlg_first->ih;\n    idlg_first = idlg_first->next;\n  }\n  return ih;\n}\n\nstatic int idlg_nvisiblewin = 0;\n\nvoid iupDlgListVisibleInc(void)\n{\n  iupASSERT(idlg_nvisiblewin < idlg_count);\n  if (idlg_nvisiblewin == idlg_count)\n    return;\n  idlg_nvisiblewin++;\n}\n\nvoid iupDlgListVisibleDec(void)\n{\n  iupASSERT(idlg_nvisiblewin > 0);\n  idlg_nvisiblewin--;\n}\n\nint iupDlgListVisibleCount(void)\n{\n  return idlg_nvisiblewin;\n}\n\nvoid iupDlgListDestroyAll(void)\n{\n  int i = 0, count;\n  Ihandle** ih_array = (Ihandle**)malloc(idlg_count * sizeof(Ihandle*));\n  Idiallst *list;\n  for (list = idlglist; list; list = list->next)\n  {\n    if (iupObjectCheck(list->ih))\n    {\n      ih_array[i] = list->ih;\n      i++;\n    }\n  }\n\n  count = i;\n  for (i = 0; i < count; i++)\n  {\n    if (iupObjectCheck(ih_array[i]))\n      IupDestroy(ih_array[i]);   /* this will also destroy the list */\n  }\n\n  free(ih_array);\n}\n","/** \\file\n * \\brief iupexpander control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_childtree.h\"\n#include \"iup_draw.h\"\n#include \"iup_image.h\"\n\n\nstatic Ihandle* load_image_arrowup_highlight(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 175, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 211, 116, 116, 116, 255, 0, 0, 0, 211, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 171, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 171, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 143, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowdown_highlight(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 143, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 171, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 171, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 211, 116, 116, 116, 255, 0, 0, 0, 211, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 175, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowleft_highlight(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 171, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 211, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 211, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 171, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 116, 116, 116, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowright_highlight(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 0, 0, 0, 159, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 171, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 211, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 255, 255, 255, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 211, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 255, 255, 255, 255, 116, 116, 116, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 116, 116, 116, 255, 0, 0, 0, 171, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 116, 116, 255, 0, 0, 0, 159, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowup(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 175, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 171, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 171, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowleft(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 171, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 171, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowright(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 159, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 171, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 171, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 159, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic Ihandle* load_image_arrowdown(void)\n{\n  unsigned char imgdata[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 171, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 171, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 195, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 175, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  Ihandle* image = IupImageRGBA(15, 15, imgdata);\n  return image;\n}\n\nstatic void iExpanderLoadImages(void)\n{\n  IupSetHandle(\"IupArrowUp\", load_image_arrowup());\n  IupSetHandle(\"IupArrowLeft\", load_image_arrowleft());\n  IupSetHandle(\"IupArrowRight\", load_image_arrowright());\n  IupSetHandle(\"IupArrowDown\", load_image_arrowdown());\n  IupSetHandle(\"IupArrowUpHighlight\", load_image_arrowup_highlight());\n  IupSetHandle(\"IupArrowDownHighlight\", load_image_arrowdown_highlight());\n  IupSetHandle(\"IupArrowLeftHighlight\", load_image_arrowleft_highlight());\n  IupSetHandle(\"IupArrowRightHighlight\", load_image_arrowright_highlight());\n}\n\nenum { IEXPANDER_LEFT, IEXPANDER_RIGHT, IEXPANDER_TOP, IEXPANDER_BOTTOM };\nenum { IEXPANDER_CLOSE, IEXPANDER_OPEN, IEXPANDER_OPEN_FLOAT };\n\nstruct _IcontrolData\n{\n  /* attributes */\n  int position;\n  int state;\n  int bar_size;\n  int extra_buttons;\n  int auto_show;\n  int title_expand;\n  int animation;\n\n  /* aux */\n  Ihandle* auto_show_timer;\n  Ihandle* animate_timer;\n};\n\nstatic void iExpanderUpdateTitleState(Ihandle* ih)\n{\n  /* expander -> bar -> box -> (expand_button, title_label, ...) */\n  Ihandle* box = ih->firstchild->firstchild;\n  Ihandle* title_label = box->firstchild->brother;\n\n  /* called only when TITLEEXPAND=Yes */\n\n  char* titleimage = iupAttribGet(ih, \"TITLEIMAGE\");\n  if (titleimage)\n  {\n    if (ih->data->state != IEXPANDER_CLOSE)\n    {\n      char* imopen = iupAttribGetStr(ih, \"TITLEIMAGEOPEN\");\n      if (imopen) titleimage = imopen;\n\n      if (iupAttribGet(title_label, \"HIGHLIGHT\"))\n      {\n        char* imhighlight = iupAttribGetStr(ih, \"TITLEIMAGEOPENHIGHLIGHT\");\n        if (imhighlight) titleimage = imhighlight;\n      }\n    }\n    else\n    {\n      if (iupAttribGet(title_label, \"HIGHLIGHT\"))\n      {\n        char* imhighlight = iupAttribGetStr(ih, \"TITLEIMAGEHIGHLIGHT\");\n        if (imhighlight) titleimage = imhighlight;\n      }\n    }\n\n    IupSetStrAttribute(title_label, \"IMAGE\", titleimage);\n  }\n  else\n  {\n    char* color = iupAttribGetStr(ih, \"FORECOLOR\");\n\n    if (iupAttribGet(title_label, \"HIGHLIGHT\"))\n    {\n      char* highcolor = iupAttribGet(ih, \"HIGHCOLOR\");\n      if (highcolor) color = highcolor;\n    }\n    else if (ih->data->state != IEXPANDER_CLOSE)\n    {\n      char* opencolor = iupAttribGet(ih, \"OPENCOLOR\");\n      if (opencolor) color = opencolor;\n    }\n\n    IupSetStrAttribute(title_label, \"FGCOLOR\", color);\n  }\n}\n\nstatic void iExpanderUpdateStateImage(Ihandle* ih)\n{\n  /* expander -> bar -> box -> (expand_button, ...) */\n  Ihandle* box = ih->firstchild->firstchild;\n  Ihandle* expand_button = box->firstchild;\n\n  char* image = iupAttribGetStr(ih, \"IMAGE\");\n  if (image)\n  {\n    if (ih->data->state != IEXPANDER_CLOSE)\n    {\n      char* imopen = iupAttribGetStr(ih, \"IMAGEOPEN\");\n      if (imopen) image = imopen;\n\n      if (iupAttribGet(expand_button, \"HIGHLIGHT\"))\n      {\n        char* imhighlight = iupAttribGetStr(ih, \"IMAGEOPENHIGHLIGHT\");\n        if (imhighlight) image = imhighlight;\n      }\n    }\n    else\n    {\n      if (iupAttribGet(expand_button, \"HIGHLIGHT\"))\n      {\n        char* imhighlight = iupAttribGetStr(ih, \"IMAGEHIGHLIGHT\");\n        if (imhighlight) image = imhighlight;\n      }\n    }\n\n    IupSetAttribute(expand_button, \"IMAGE\", image);\n  }\n  else\n  {\n    /* the arrow points in the direction of the action */\n\n    switch (ih->data->position)\n    {\n    case IEXPANDER_LEFT:\n      if (ih->data->state == IEXPANDER_CLOSE)\n        image = \"IupArrowRight\";\n      else\n        image = \"IupArrowLeft\";\n      break;\n    case IEXPANDER_RIGHT:\n      if (ih->data->state == IEXPANDER_CLOSE)\n        image = \"IupArrowLeft\";\n      else\n        image = \"IupArrowRight\";\n      break;\n    case IEXPANDER_BOTTOM:\n      if (ih->data->state == IEXPANDER_CLOSE)\n        image = \"IupArrowUp\";\n      else\n        image = \"IupArrowDown\";\n      break;\n    default: /* IEXPANDER_TOP */\n      if (iupAttribGet(ih, \"TITLE\") || iupAttribGet(ih, \"TITLEIMAGE\"))\n      {\n        if (ih->data->state == IEXPANDER_CLOSE)\n          image = \"IupArrowRight\";\n        else\n          image = \"IupArrowDown\";\n      }\n      else\n      {\n        if (ih->data->state == IEXPANDER_CLOSE)\n          image = \"IupArrowDown\";\n        else\n          image = \"IupArrowUp\";\n      }\n      break;\n    }\n\n    if (iupAttribGet(expand_button, \"HIGHLIGHT\"))\n      IupSetfAttribute(expand_button, \"IMAGE\", \"%sHighlight\", image);\n    else\n      IupSetAttribute(expand_button, \"IMAGE\", image);\n  }\n}\n\nstatic int iExpanderAnimateTimer_CB(Ihandle* ih_timer)\n{\n  Ihandle* ih = (Ihandle*)iupAttribGet(ih_timer, \"_IUP_EXPANDER\");\n  Ihandle* child = (Ihandle*)iupAttribGet(ih_timer, \"_IUP_CHILD\");\n  int final_height = IupGetInt(ih_timer, \"_IUP_FINAL_HEIGHT\");\n  int closing = IupGetInt(ih_timer, \"_IUP_CLOSING\");\n  int width = IupGetInt(ih_timer, \"_IUP_WIDTH\");\n  int frame_time = iupAttribGetInt(ih, \"FRAMETIME\");\n  int num_frames = iupAttribGetInt(ih, \"NUMFRAMES\");\n  int time_delay = iupAttribGetInt(ih_timer, \"ELAPSEDTIME\");\n  int height;\n  int current_frame = time_delay / frame_time;\n\n  if (closing)\n    height = (final_height*(num_frames - current_frame)) / num_frames;\n  else\n    height = (final_height*(current_frame + 1)) / num_frames;\n\n  IupSetfAttribute(child, \"MAXSIZE\", \"%dx%d\", width, height);\n\n  if (ih->data->animation == 2)\n    IupSetfAttribute(child, \"CHILDOFFSET\", \"0x%d\", height - final_height);\n\n  IupRefresh(ih);\n\n  if (current_frame == num_frames - 1)\n  {\n    iupAttribSetStr(child, \"MAXSIZE\", iupAttribGet(child, \"OLD_MAXSIZE\"));\n\n    if (closing)\n    {\n      ih->data->state = IEXPANDER_CLOSE;\n      IupSetAttribute(child, \"VISIBLE\", \"NO\");\n      IupRefresh(ih);\n    }\n\n    IupSetAttribute(ih_timer, \"RUN\", \"NO\");\n  }\n\n  return IUP_DEFAULT;\n}\n\nstatic void iExpanderAnimateChild(Ihandle* ih, Ihandle* child)\n{\n  int width, final_height, closing = 0;\n  int frame_time = iupAttribGetInt(ih, \"FRAMETIME\");\n\n  /* IMPORTANT: child must be a native container or this will not work. */\n\n  if (ih->data->state != IEXPANDER_CLOSE)\n  {\n    /* was closed */\n    IupSetAttribute(child, \"VISIBLE\", \"YES\");\n\n    /* calculate the layout but do not update */\n    iupLayoutCompute(IupGetDialog(ih));\n  }\n  else\n  {\n    /* was open */\n\n    /* pretend it is still open */\n    ih->data->state = IEXPANDER_OPEN;\n    closing = 1;\n  }\n\n  final_height = child->currentheight;\n  width = child->currentwidth;\n\n  iupAttribSetStr(child, \"OLD_MAXSIZE\", iupAttribGet(child, \"MAXSIZE\"));\n\n  if (!ih->data->animate_timer)\n  {\n    ih->data->animate_timer = IupTimer();\n    IupSetCallback(ih->data->animate_timer, \"ACTION_CB\", (Icallback)iExpanderAnimateTimer_CB);\n    iupAttribSet(ih->data->animate_timer, \"_IUP_EXPANDER\", (char*)ih);\n  }\n\n  IupSetInt(ih->data->animate_timer, \"_IUP_FINAL_HEIGHT\", final_height);\n  IupSetInt(ih->data->animate_timer, \"_IUP_CLOSING\", closing);\n  IupSetInt(ih->data->animate_timer, \"_IUP_WIDTH\", width);\n  iupAttribSet(ih->data->animate_timer, \"_IUP_CHILD\", (char*)child);\n\n  IupSetInt(ih->data->animate_timer, \"TIME\", frame_time);\n  IupSetAttribute(ih->data->animate_timer, \"RUN\", \"YES\");\n}\n\nstatic void iExpanderOpenCloseChild(Ihandle* ih, int refresh, int callcb, int state)\n{\n  Ihandle* child = ih->firstchild->brother;\n\n  if (callcb)\n  {\n    IFni cb = (IFni)IupGetCallback(ih, \"OPENCLOSE_CB\");\n    if (cb)\n    {\n      int ret = cb(ih, state);\n      if (ret == IUP_IGNORE)\n        return;\n    }\n  }\n\n  ih->data->state = state;\n\n  iExpanderUpdateStateImage(ih);\n  if (ih->data->position == IEXPANDER_TOP)\n    iExpanderUpdateTitleState(ih);\n\n  if (child)\n  {\n    if (refresh && ih->data->animation && ih->data->position == IEXPANDER_TOP)\n      iExpanderAnimateChild(ih, child);\n    else\n    {\n      if (ih->data->state == IEXPANDER_CLOSE)\n        IupSetAttribute(child, \"VISIBLE\", \"NO\");\n      else\n        IupSetAttribute(child, \"VISIBLE\", \"YES\");\n\n      if (refresh)\n        IupRefresh(child); /* this will recompute the layout of the hole dialog */\n    }\n  }\n\n  if (callcb)\n  {\n    IFn cb = IupGetCallback(ih, \"ACTION\");\n    if (cb)\n      cb(ih);\n  }\n}\n\nstatic int iExpanderGetBarSize(Ihandle* ih)\n{\n  int bar_size;\n  if (ih->data->bar_size == -1)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n\n    iupBaseComputeNaturalSize(box);\n\n    if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n      bar_size = box->naturalwidth;\n    else\n      bar_size = box->naturalheight;\n  }\n  else\n    bar_size = ih->data->bar_size;\n\n  return bar_size;\n}\n\nstatic void iExpanderUpdateTitle(Ihandle* ih)\n{\n  Ihandle* box = ih->firstchild->firstchild;\n  Ihandle* expand_button = box->firstchild;\n  Ihandle* label = expand_button->brother;\n  char* title = iupAttribGet(ih, \"TITLE\");\n  char* titleimage = iupAttribGet(ih, \"TITLEIMAGE\");\n  if (title || titleimage)\n  {\n    if (!ih->handle) /* only update these before map*/\n    {\n      IupSetAttribute(box, \"MARGIN\", \"0x1\");\n      IupSetAttribute(box, \"GAP\", \"1\");\n      IupSetAttribute(expand_button, \"EXPAND\", \"NO\");\n    }\n\n    IupSetStrAttribute(label, \"VISIBLE\", \"Yes\");\n    IupSetStrAttribute(label, \"TITLE\", title);\n    IupSetStrAttribute(label, \"IMAGE\", titleimage);\n  }\n  else\n  {\n    if (!ih->handle) /* only update these before map*/\n    {\n      IupSetAttribute(box, \"MARGIN\", \"2x2\");\n      IupSetAttribute(box, \"GAP\", \"0\");\n      IupSetAttribute(expand_button, \"EXPAND\", \"HORIZONTAL\");\n    }\n\n    IupSetStrAttribute(label, \"VISIBLE\", \"No\");\n    IupSetAttribute(label, \"TITLE\", NULL);\n    IupSetAttribute(label, \"IMAGE\", NULL);\n  }\n\n  iExpanderUpdateStateImage(ih);\n\n  if (ih->data->position == IEXPANDER_TOP)\n    iExpanderUpdateTitleState(ih);\n}\n\nstatic void iExpanderUpdateExtraButtonImage(Ihandle* ih, Ihandle* extra_button, int pressed)\n{\n  int button = iupAttribGetInt(extra_button, \"EXTRABUTTON_NUMBER\");\n  char* image = iupAttribGetId(ih, \"IMAGEEXTRA\", button);\n  if (!image)\n    return;\n\n  if (pressed)\n  {\n    char* impress = iupAttribGetId(ih, \"IMAGEEXTRAPRESS\", button);\n    if (impress) image = impress;\n  }\n  else if (iupAttribGet(extra_button, \"HIGHLIGHT\"))\n  {\n    char* imhighlight = iupAttribGetId(ih, \"IMAGEEXTRAHIGHLIGHT\", button);\n    if (imhighlight) image = imhighlight;\n  }\n\n  IupSetStrAttribute(extra_button, \"IMAGE\", image);\n}\n\nstatic int iExpanderExtraButtonButton_CB(Ihandle* extra_button, int button, int pressed, int x, int y, char* status);\nstatic int iExpanderExtraButtonEnterWindow_cb(Ihandle* extra_button);\nstatic int iExpanderExtraButtonLeaveWindow_cb(Ihandle* extra_button);\n\nstatic void iExpanderAddExtraButton(Ihandle* ih, Ihandle* extra_box, int number)\n{\n  Ihandle* extra_button = IupLabel(NULL);\n  IupSetInt(extra_button, \"EXTRABUTTON_NUMBER\", number);\n  IupSetCallback(extra_button, \"BUTTON_CB\", (Icallback)iExpanderExtraButtonButton_CB);\n  IupSetCallback(extra_button, \"ENTERWINDOW_CB\", (Icallback)iExpanderExtraButtonEnterWindow_cb);\n  IupSetCallback(extra_button, \"LEAVEWINDOW_CB\", (Icallback)iExpanderExtraButtonLeaveWindow_cb);\n\n  iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n\n  IupAppend(extra_box, extra_button);\n}\n\nstatic void iExpanderUpdateExtraButtons(Ihandle* ih)\n{\n  Ihandle* box = ih->firstchild->firstchild;\n  Ihandle* extra_box = box->firstchild->brother->brother;  /* (expand_button, label, extra_box) */\n\n  if (extra_box)\n    IupDestroy(extra_box);\n\n  if (ih->data->extra_buttons)\n  {\n    extra_box = IupHbox(NULL);\n    IupSetAttribute(box, \"MARGIN\", \"0x0\");\n    IupSetAttribute(box, \"GAP\", \"2\");\n    IupAppend(box, extra_box);\n\n    iExpanderAddExtraButton(ih, extra_box, ih->data->extra_buttons);\n    if (ih->data->extra_buttons > 1)\n      iExpanderAddExtraButton(ih, extra_box, ih->data->extra_buttons-1);\n    if (ih->data->extra_buttons > 2)\n      iExpanderAddExtraButton(ih, extra_box, ih->data->extra_buttons-2);\n  }\n}\n\nstatic int iExpanderTitleButton_CB(Ihandle* title_label, int button, int pressed, int x, int y, char* status);\nstatic int iExpanderTitleEnterWindow_cb(Ihandle* title_label);\nstatic int iExpanderTitleLeaveWindow_cb(Ihandle* title_label);\n\nstatic int iExpanderExpandButtonButton_CB(Ihandle* expand_button, int button, int pressed, int x, int y, char* status);\nstatic int iExpanderExpandButtonEnterWindow_cb(Ihandle* expand_button);\nstatic int iExpanderExpandButtonLeaveWindow_cb(Ihandle* expand_button);\n\nstatic void iExpanderUpdateBox(Ihandle* ih)\n{\n  Ihandle* bar = ih->firstchild;\n  Ihandle* box, *expand_button;\n\n  if (bar->firstchild)\n    IupDestroy(bar->firstchild);\n\n  expand_button = IupLabel(NULL);\n  IupSetAttribute(expand_button, \"ALIGNMENT\", \"ACENTER:ACENTER\");\n  IupSetCallback(expand_button, \"BUTTON_CB\", (Icallback)iExpanderExpandButtonButton_CB);\n  IupSetCallback(expand_button, \"ENTERWINDOW_CB\", (Icallback)iExpanderExpandButtonEnterWindow_cb);\n  IupSetCallback(expand_button, \"LEAVEWINDOW_CB\", (Icallback)iExpanderExpandButtonLeaveWindow_cb);\n\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    Ihandle* title_label = IupLabel(NULL);\n    IupSetAttribute(title_label, \"EXPAND\", \"HORIZONTAL\");\n    IupSetCallback(title_label, \"BUTTON_CB\", (Icallback)iExpanderTitleButton_CB);\n    IupSetCallback(title_label, \"ENTERWINDOW_CB\", (Icallback)iExpanderTitleEnterWindow_cb);\n    IupSetCallback(title_label, \"LEAVEWINDOW_CB\", (Icallback)iExpanderTitleLeaveWindow_cb);\n\n    box = IupHbox(expand_button, title_label, NULL);\n  }\n  else if (ih->data->position == IEXPANDER_BOTTOM)\n  {\n    box = IupHbox(expand_button, NULL);\n    IupSetAttribute(expand_button, \"EXPAND\", \"HORIZONTAL\");\n  }\n  else\n  {\n    box = IupVbox(expand_button, NULL);\n    IupSetAttribute(expand_button, \"EXPAND\", \"VERTICAL\");\n  }\n\n  IupSetAttribute(box, \"MARGIN\", \"2x2\");\n  IupSetAttribute(box, \"GAP\", \"0\");\n  IupSetAttribute(box, \"ALIGNMENT\", \"ACENTER\");\n\n  IupAppend(bar, box);\n\n  if (ih->data->position == IEXPANDER_TOP)\n    iExpanderUpdateTitle(ih);\n\n  iExpanderUpdateStateImage(ih);\n}\n\n\n/*****************************************************************************\\\n|* Internal Callbacks                                                        *|\n\\*****************************************************************************/\n\n\nstatic int iExpanderGlobalMotion_cb(int x, int y)\n{\n  int child_x, child_y;\n  Ihandle* ih = (Ihandle*)IupGetGlobal(\"_IUP_EXPANDER_GLOBAL\");\n  Ihandle* bar = ih->firstchild;\n  Ihandle* child = bar->brother;\n\n  if (ih->data->state != IEXPANDER_OPEN_FLOAT)\n  {\n    IupSetGlobal(\"_IUP_EXPANDER_GLOBAL\", NULL);\n    IupSetFunction(\"GLOBALMOTION_CB\", IupGetFunction(\"_IUP_OLD_GLOBALMOTION_CB\"));\n    IupSetFunction(\"_IUP_OLD_GLOBALMOTION_CB\", NULL);\n    IupSetGlobal(\"INPUTCALLBACKS\", \"No\");\n    return IUP_DEFAULT;\n  }\n\n  child_x = 0, child_y = 0;\n  iupdrvClientToScreen(bar, &child_x, &child_y);\n  if (x > child_x && x < child_x + bar->currentwidth &&\n      y > child_y && y < child_y + bar->currentheight)\n    return IUP_DEFAULT;  /* ignore if inside the bar */\n\n  child_x = 0, child_y = 0;\n  iupdrvClientToScreen(child, &child_x, &child_y);\n  if (x < child_x || x > child_x+child->currentwidth ||\n      y < child_y || y > child_y+child->currentheight)\n  {\n    iExpanderOpenCloseChild(ih, 0, 1, IEXPANDER_CLOSE);\n\n    IupSetGlobal(\"_IUP_EXPANDER_GLOBAL\", NULL);\n    IupSetFunction(\"GLOBALMOTION_CB\", IupGetFunction(\"_IUP_OLD_GLOBALMOTION_CB\"));\n    IupSetFunction(\"_IUP_OLD_GLOBALMOTION_CB\", NULL);\n    IupSetGlobal(\"INPUTCALLBACKS\", \"No\");\n  }\n\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderTimer_cb(Ihandle* ih_timer)\n{\n  Ihandle* ih = (Ihandle*)iupAttribGet(ih_timer, \"_IUP_EXPANDER\");\n  Ihandle* child = ih->firstchild->brother;\n\n  /* run timer just once each time */\n  IupSetAttribute(ih_timer, \"RUN\", \"No\");\n\n  /* just show child on top,\n     that's why child must be a native container when using autoshow. */\n  iExpanderOpenCloseChild(ih, 0, 1, IEXPANDER_OPEN_FLOAT);\n  IupRefreshChildren(ih);\n  IupSetAttribute(child, \"ZORDER\", \"TOP\"); \n\n  /* now monitor mouse move */\n  IupSetGlobal(\"INPUTCALLBACKS\", \"Yes\");\n  IupSetFunction(\"_IUP_OLD_GLOBALMOTION_CB\", IupGetFunction(\"GLOBALMOTION_CB\"));\n  IupSetGlobal(\"_IUP_EXPANDER_GLOBAL\", (char*)ih);\n  IupSetFunction(\"GLOBALMOTION_CB\", (Icallback)iExpanderGlobalMotion_cb);\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExpandButtonLeaveWindow_cb(Ihandle* expand_button)\n{\n  /* expander -> bar -> box -> (expand_button, ...) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(expand_button)));\n\n  if (iupAttribGet(expand_button, \"HIGHLIGHT\"))\n  {\n    iupAttribSet(expand_button, \"HIGHLIGHT\", NULL);\n    iExpanderUpdateStateImage(ih);\n\n    if (ih->data->title_expand)\n    {\n      Ihandle* title_label = expand_button->brother;\n      iupAttribSet(title_label, \"HIGHLIGHT\", NULL);\n      iExpanderUpdateTitleState(ih);\n    }\n\n    if (ih->data->auto_show)\n    {\n      if (IupGetInt(ih->data->auto_show_timer, \"RUN\"))\n        IupSetAttribute(ih->data->auto_show_timer, \"RUN\", \"No\");\n    }\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExpandButtonEnterWindow_cb(Ihandle* expand_button)\n{\n  /* expander -> bar -> box -> (expand_button, ...) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(expand_button)));\n\n  if (!iupAttribGet(expand_button, \"HIGHLIGHT\"))\n  {\n    Ihandle* child = ih->firstchild->brother;\n\n    iupAttribSet(expand_button, \"HIGHLIGHT\", \"1\");\n    iExpanderUpdateStateImage(ih);\n\n    if (ih->data->title_expand)\n    {\n      Ihandle* title_label = expand_button->brother;\n      iupAttribSet(title_label, \"HIGHLIGHT\", \"1\");\n      iExpanderUpdateTitleState(ih);\n    }\n\n    if (ih->data->auto_show &&\n        child &&\n        ih->data->state == IEXPANDER_CLOSE)\n      IupSetAttribute(ih->data->auto_show_timer, \"RUN\", \"Yes\");\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExpandButtonButton_CB(Ihandle* expand_button, int button, int pressed, int x, int y, char* status)\n{\n  if (button == IUP_BUTTON1 && pressed)\n  {\n    /* expander -> bar -> box -> (expand_button, ...) */\n    Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(expand_button)));\n\n    if (ih->data->auto_show)\n    {\n      if (IupGetInt(ih->data->auto_show_timer, \"RUN\"))\n        IupSetAttribute(ih->data->auto_show_timer, \"RUN\", \"No\");\n    }\n\n    iExpanderOpenCloseChild(ih, 1, 1, ih->data->state == IEXPANDER_OPEN ? IEXPANDER_CLOSE : IEXPANDER_OPEN);\n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderTitleLeaveWindow_cb(Ihandle* title_label)\n{\n  /* expander -> bar -> box -> (expand_button, title_label, ...) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(title_label)));\n\n  if (ih->data->title_expand && iupAttribGet(title_label, \"HIGHLIGHT\"))\n  {\n    Ihandle* expand_button = IupGetChild(IupGetParent(title_label), 0);\n    iupAttribSet(expand_button, \"HIGHLIGHT\", NULL);\n    iExpanderUpdateStateImage(ih);\n\n    iupAttribSet(title_label, \"HIGHLIGHT\", NULL);\n    iExpanderUpdateTitleState(ih);\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderTitleEnterWindow_cb(Ihandle* title_label)\n{\n  /* expander -> bar -> box -> (expand_button, title_label, ...) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(title_label)));\n\n  if (ih->data->title_expand && !iupAttribGet(title_label, \"HIGHLIGHT\"))\n  {\n    Ihandle* expand_button = IupGetChild(IupGetParent(title_label), 0);\n    iupAttribSet(expand_button, \"HIGHLIGHT\", \"1\");\n    iExpanderUpdateStateImage(ih);\n\n    iupAttribSet(title_label, \"HIGHLIGHT\", \"1\");\n    iExpanderUpdateTitleState(ih);\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderTitleButton_CB(Ihandle* title_label, int button, int pressed, int x, int y, char* status)\n{\n  if (button == IUP_BUTTON1 && pressed)\n  {\n    /* expander -> bar -> box -> (expand_button, title_label, ...) */\n    Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(title_label)));\n\n    if (ih->data->title_expand)\n    {\n      iExpanderOpenCloseChild(ih, 1, 1, ih->data->state == IEXPANDER_OPEN ? IEXPANDER_CLOSE : IEXPANDER_OPEN);\n    }\n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExtraButtonLeaveWindow_cb(Ihandle* extra_button)\n{\n  /* expander -> bar -> box -> (expand_button, label, extra_box(extra_button)) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(IupGetParent(extra_button))));\n\n  if (iupAttribGet(extra_button, \"HIGHLIGHT\"))\n  {\n    iupAttribSet(extra_button, \"HIGHLIGHT\", NULL);\n    iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExtraButtonEnterWindow_cb(Ihandle* extra_button)\n{\n  /* expander -> bar -> box -> (expand_button, label, extra_box(extra_button)) */\n  Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(IupGetParent(extra_button))));\n\n  if (!iupAttribGet(extra_button, \"HIGHLIGHT\"))\n  {\n    iupAttribSet(extra_button, \"HIGHLIGHT\", \"1\");\n    iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n  }\n  return IUP_DEFAULT;\n}\n\nstatic int iExpanderExtraButtonButton_CB(Ihandle* extra_button, int button, int pressed, int x, int y, char* status)\n{\n  if (button == IUP_BUTTON1)\n  {\n    /* expander -> bar -> box -> (expand_button, label, extra_box(extra_button)) */\n    Ihandle* ih = IupGetParent(IupGetParent(IupGetParent(IupGetParent(extra_button))));\n\n    IFnii cb = (IFnii)IupGetCallback(ih, \"EXTRABUTTON_CB\");\n    if (cb)\n    {\n      button = IupGetInt(extra_button, \"EXTRABUTTON_NUMBER\");\n      cb(ih, button, pressed);\n    }\n\n    iExpanderUpdateExtraButtonImage(ih, extra_button, pressed);\n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\n\n/*****************************************************************************\\\n|* Attributes                                                                *|\n\\*****************************************************************************/\n\n\nstatic char* iExpanderGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  int bar_size = iExpanderGetBarSize(ih);\n\n  if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n    width -= bar_size;\n  else\n    height -= bar_size;\n\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iExpanderSetPositionAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle)\n    return 0; /* can be changed only before map */\n\n  if (iupStrEqualNoCase(value, \"LEFT\"))\n    ih->data->position = IEXPANDER_LEFT;\n  else if (iupStrEqualNoCase(value, \"RIGHT\"))\n    ih->data->position = IEXPANDER_RIGHT;\n  else if (iupStrEqualNoCase(value, \"BOTTOM\"))\n    ih->data->position = IEXPANDER_BOTTOM;\n  else  /* Default = TOP */\n    ih->data->position = IEXPANDER_TOP;\n\n  iExpanderUpdateBox(ih);\n\n  return 0;  /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetPositionAttrib(Ihandle* ih)\n{\n  if (ih->data->position == IEXPANDER_LEFT)\n    return \"LEFT\";\n  else if (ih->data->position == IEXPANDER_RIGHT)\n    return \"RIGHT\";\n  else if (ih->data->position == IEXPANDER_BOTTOM)\n    return \"BOTTOM\";\n  else  /* Default = TOP */\n    return \"TOP\";\n}\n\nstatic int iExpanderSetBarSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n    ih->data->bar_size = -1;\n  else\n    iupStrToInt(value, &ih->data->bar_size);  /* must manually update layout */\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetBarSizeAttrib(Ihandle* ih)\n{\n  int bar_size = iExpanderGetBarSize(ih);\n  return iupStrReturnInt(bar_size);\n}\n\nstatic int iExpanderSetStateAttrib(Ihandle* ih, const char* value)\n{\n  int state;\n  if (iupStrEqualNoCase(value, \"OPEN\"))\n    state = IEXPANDER_OPEN;\n  else\n    state = IEXPANDER_CLOSE;\n\n  if (ih->data->state == state)\n    return 0;\n\n  iExpanderOpenCloseChild(ih, 1, 0, state);\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetStateAttrib(Ihandle* ih)\n{\n  if (ih->data->state)\n    return \"OPEN\";\n  else\n    return \"CLOSE\";\n}\n\nstatic int iExpanderSetForeColorAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    if (ih->data->title_expand)\n    {\n      iupAttribSetStr(ih, \"FORECOLOR\", value);\n      iExpanderUpdateTitleState(ih);\n    }\n    else \n    {\n      /* expander -> bar -> box -> (expand_button, title_label, ...) */\n      Ihandle* box = ih->firstchild->firstchild;\n      Ihandle* title_label = box->firstchild->brother;\n      IupSetStrAttribute(title_label, \"FGCOLOR\", value);\n    }\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetOpenColorAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    iupAttribSetStr(ih, \"OPENCOLOR\", value);\n    iExpanderUpdateTitleState(ih);\n  }\n  return 1;\n}\n\nstatic int iExpanderSetHighColorAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    iupAttribSetStr(ih, \"HIGHCOLOR\", value);\n    iExpanderUpdateTitleState(ih);\n  }\n  return 1;\n}\n\nstatic int iExpanderSetBackColorAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* bar = ih->firstchild;\n  IupSetStrAttribute(bar, \"BGCOLOR\", value);\n  return 1;\n}\n\nstatic int iExpanderSetImageAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->state == IEXPANDER_CLOSE)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n    Ihandle* expand_button = box->firstchild;\n    IupSetStrAttribute(expand_button, \"IMAGE\", value);\n  }\n  return 1;\n}\n\nstatic int iExpanderSetImageOpenAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->state != IEXPANDER_CLOSE)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n    Ihandle* expand_button = box->firstchild;\n    IupSetStrAttribute(expand_button, \"IMAGE\", value);\n  }\n  return 1;\n}\n\nstatic int iExpanderSetImageExtra(Ihandle* ih, const char* value, int button)\n{\n  if (ih->data->extra_buttons > button - 1)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n    Ihandle* extra_box = box->firstchild->brother->brother;  /* (expand_button, label, extra_box) */\n\n    if (extra_box)\n    {\n      Ihandle* extra_button = IupGetChild(extra_box, ih->data->extra_buttons - button);\n      iupAttribSetStrId(ih, \"IMAGEEXTRA\", button, value);\n      iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n    }\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetImageExtraPress(Ihandle* ih, const char* value, int button)\n{\n  if (ih->data->extra_buttons > button - 1)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n    Ihandle* extra_box = box->firstchild->brother->brother;  /* (expand_button, label, extra_box) */\n\n    if (extra_box)\n    {\n      Ihandle* extra_button = IupGetChild(extra_box, ih->data->extra_buttons - button);\n      iupAttribSetStrId(ih, \"IMAGEEXTRAPRESS\", button, value);\n      iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n    }\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetImageExtraHighlight(Ihandle* ih, const char* value, int button)\n{\n  if (ih->data->extra_buttons > button - 1)\n  {\n    Ihandle* box = ih->firstchild->firstchild;\n    Ihandle* extra_box = box->firstchild->brother->brother;  /* (expand_button, label, extra_box) */\n\n    if (extra_box)\n    {\n      Ihandle* extra_button = IupGetChild(extra_box, ih->data->extra_buttons - button);\n      iupAttribSetStrId(ih, \"IMAGEEXTRAHIGHLIGHT\", button, value);\n      iExpanderUpdateExtraButtonImage(ih, extra_button, 0);\n    }\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetImageExtra1Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtra(ih, value, 1);\n}\n\nstatic int iExpanderSetImageExtraPress1Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraPress(ih, value, 1);\n}\n\nstatic int iExpanderSetImageExtraHighlight1Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraHighlight(ih, value, 1);\n}\n\nstatic int iExpanderSetImageExtra2Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtra(ih, value, 2);\n}\n\nstatic int iExpanderSetImageExtraPress2Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraPress(ih, value, 2);\n}\n\nstatic int iExpanderSetImageExtraHighlight2Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraHighlight(ih, value, 2);\n}\n\nstatic int iExpanderSetImageExtra3Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtra(ih, value, 3);\n}\n\nstatic int iExpanderSetImageExtraPress3Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraPress(ih, value, 3);\n}\n\nstatic int iExpanderSetImageExtraHighlight3Attrib(Ihandle* ih, const char* value)\n{\n  return iExpanderSetImageExtraHighlight(ih, value, 3);\n}\n\nstatic int iExpanderSetTitleAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    iupAttribSetStr(ih, \"TITLE\", value);\n    iupAttribSet(ih, \"TITLEIMAGE\", NULL);\n    iExpanderUpdateTitle(ih);\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetTitleImageAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    iupAttribSetStr(ih, \"TITLEIMAGE\", value);\n    iupAttribSet(ih, \"TITLE\", NULL);\n    iExpanderUpdateTitle(ih);\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetTitleImageOpenAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->data->position == IEXPANDER_TOP)\n  {\n    iupAttribSetStr(ih, \"TITLEIMAGEOPEN\", value);\n    iExpanderUpdateTitle(ih);\n  }\n\n  return 1;\n}\n\nstatic int iExpanderSetAutoShowAttrib(Ihandle* ih, const char* value)\n{\n  ih->data->auto_show = iupStrBoolean(value);\n  if (ih->data->auto_show)\n  {\n    if (!ih->data->auto_show_timer)\n    {\n      ih->data->auto_show_timer = IupTimer();\n      IupSetAttribute(ih->data->auto_show_timer, \"TIME\", \"1000\");  /* 1 second */\n      IupSetCallback(ih->data->auto_show_timer, \"ACTION_CB\", iExpanderTimer_cb);\n      iupAttribSet(ih->data->auto_show_timer, \"_IUP_EXPANDER\", (char*)ih);  /* 1 second */\n    }\n  }\n  else\n  {\n    if (ih->data->auto_show_timer)\n      IupSetAttribute(ih->data->auto_show_timer, \"RUN\", \"NO\");\n  }\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetAutoShowAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean(ih->data->auto_show);\n}\n\nstatic int iExpanderSetAnimationAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"SLIDE\"))\n    ih->data->animation = 2;\n  else if (iupStrEqualNoCase(value, \"CURTAIN\"))\n    ih->data->animation = 1;\n  else\n    ih->data->animation = 0;\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetAnimationAttrib(Ihandle* ih)\n{\n  if (ih->data->animation == 2)\n    return \"SLIDE\";\n  else if (ih->data->animation)\n    return \"CURTAIN\";\n  else\n    return \"NO\";\n}\n\nstatic int iExpanderSetTitleExpandAttrib(Ihandle* ih, const char* value)\n{\n  ih->data->title_expand = iupStrBoolean(value);\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetTitleExpandAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean(ih->data->title_expand);\n}\n\nstatic int iExpanderSetExtraButtonsAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle)\n    return 0; /* can be changed only before map */\n\n  if (!value)\n    ih->data->extra_buttons = 0;\n  else\n  {\n    iupStrToInt(value, &(ih->data->extra_buttons));\n    if (ih->data->extra_buttons < 0)\n      ih->data->extra_buttons = 0;\n    else if (ih->data->extra_buttons > 3)\n      ih->data->extra_buttons = 3;\n  }\n\n  iExpanderUpdateExtraButtons(ih);\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iExpanderGetExtraButtonsAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->extra_buttons);\n}\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\n\nstatic void iExpanderComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int child_expand = 0,\n      natural_w, natural_h;\n  Ihandle* bar = ih->firstchild;\n  Ihandle* child = bar->brother;\n  Ihandle* box = bar->firstchild;\n  int bar_size = iExpanderGetBarSize(ih);\n\n  iupBaseComputeNaturalSize(box);\n\n  /* bar */\n  if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n  {\n    natural_w = bar_size;\n    natural_h = box->naturalheight;\n  }\n  else\n  {\n    natural_w = box->naturalwidth;\n    natural_h = bar_size;\n  }\n\n  if (child)\n  {\n    /* update child natural bar_size first */\n    iupBaseComputeNaturalSize(child);\n\n    if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n    {\n      if (ih->data->state == IEXPANDER_OPEN)  /* only open, not float */\n        natural_w += child->naturalwidth;\n      natural_h = iupMAX(natural_h, child->naturalheight);\n    }\n    else\n    {\n      natural_w = iupMAX(natural_w, child->naturalwidth);\n      if (ih->data->state == IEXPANDER_OPEN)  /* only open, not float */\n        natural_h += child->naturalheight;\n    }\n\n    if (ih->data->state == IEXPANDER_OPEN)\n      child_expand = child->expand;\n    else\n    {\n      if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n        child_expand = child->expand & IUP_EXPAND_HEIGHT;  /* only vertical allowed */\n      else\n        child_expand = child->expand & IUP_EXPAND_WIDTH;  /* only horizontal allowed */\n    }\n  }\n\n  *children_expand = child_expand;\n  *w = natural_w;\n  *h = natural_h;\n}\n\nstatic void iExpanderSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* bar = ih->firstchild;\n  Ihandle* child = bar->brother;\n  Ihandle* box = bar->firstchild;\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  int bar_size = iExpanderGetBarSize(ih);\n\n  if (ih->data->position == IEXPANDER_LEFT || ih->data->position == IEXPANDER_RIGHT)\n  {\n    bar->currentwidth = bar_size;\n    bar->currentheight = ih->currentheight;\n\n    if (ih->currentwidth < bar_size)\n      ih->currentwidth = bar_size;\n\n    width = ih->currentwidth - bar_size;\n  }\n  else /* IEXPANDER_TOP OR IEXPANDER_BOTTOM */\n  {\n    bar->currentwidth = ih->currentwidth;\n    bar->currentheight = bar_size;\n\n    if (ih->currentheight < bar_size)\n      ih->currentheight = bar_size;\n\n    height = ih->currentheight - bar_size;\n  }\n\n  /* force the box size to be the same size of the bar */\n  box->naturalwidth = bar->currentwidth;\n  box->naturalheight = bar->currentheight;\n  iupBaseSetCurrentSize(box, bar->currentwidth, bar->currentheight, shrink);\n\n  if (child)\n  {\n    if (ih->data->state == IEXPANDER_OPEN)\n      iupBaseSetCurrentSize(child, width, height, shrink);\n    else if (ih->data->state == IEXPANDER_OPEN_FLOAT)  /* simply set to the natural size */\n      iupBaseSetCurrentSize(child, child->currentwidth, child->currentheight, shrink);\n  }\n}\n\nstatic void iExpanderSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  Ihandle* bar = ih->firstchild;\n  Ihandle* child = bar->brother;\n  int bar_size = iExpanderGetBarSize(ih);\n\n  /* always position bar */\n  if (ih->data->position == IEXPANDER_LEFT)\n  {\n    iupBaseSetPosition(bar, x, y);\n    x += bar_size;\n  }\n  else if (ih->data->position == IEXPANDER_RIGHT)\n    iupBaseSetPosition(bar, x + ih->currentwidth - bar_size, y);\n  else if (ih->data->position == IEXPANDER_BOTTOM)\n    iupBaseSetPosition(bar, x, y + ih->currentheight - bar_size);\n  else /* IEXPANDER_TOP */\n  {\n    iupBaseSetPosition(bar, x, y);\n    y += bar_size;\n  }\n\n  if (child)\n  {\n    if (ih->data->state == IEXPANDER_OPEN)\n      iupBaseSetPosition(child, x, y);\n    else if (ih->data->state == IEXPANDER_OPEN_FLOAT)\n    {\n      if (ih->data->position == IEXPANDER_RIGHT)\n        x -= child->currentwidth;\n      else if (ih->data->position == IEXPANDER_BOTTOM)\n        y -= child->currentheight;\n\n      iupBaseSetPosition(child, x, y);\n    }\n  }\n}\n\nstatic void iExpanderChildAddedMethod(Ihandle* ih, Ihandle* child)\n{\n  iExpanderOpenCloseChild(ih, 0, 0, ih->data->state);\n  (void)child;\n}\n\nstatic int iExpanderCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle* bar;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->position = IEXPANDER_TOP;\n  ih->data->state = IEXPANDER_OPEN;\n  ih->data->bar_size = -1;\n\n  bar = IupBackgroundBox(NULL);\n  iupChildTreeAppend(ih, bar);  /* bar will always be the firstchild */\n  bar->flags |= IUP_INTERNAL;\n\n  iExpanderUpdateBox(ih);\n\n  IupSetAttribute(bar, \"CANFOCUS\", \"NO\");\n  IupSetAttribute(bar, \"BORDER\", \"NO\");\n  IupSetAttribute(bar, \"EXPAND\", \"YES\");\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iExpanderDestroyMethod(Ihandle* ih)\n{\n  if (ih->data->auto_show_timer)\n    IupDestroy(ih->data->auto_show_timer);\n  if (ih->data->animate_timer)\n    IupDestroy(ih->data->animate_timer);\n}\n\nIclass* iupExpanderNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name   = \"expander\";\n  ic->format = \"h\";   /* one Ihandle* */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype  = IUP_CHILDMANY+2;  /* canvas+child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New     = iupExpanderNewClass;\n  ic->Create  = iExpanderCreateMethod;\n  ic->Destroy = iExpanderDestroyMethod;\n  ic->Map     = iupBaseTypeVoidMapMethod;\n  ic->ChildAdded = iExpanderChildAddedMethod;\n\n  ic->ComputeNaturalSize     = iExpanderComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iExpanderSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition    = iExpanderSetChildrenPositionMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"ACTION\", \"\");\n  iupClassRegisterCallback(ic, \"OPENCLOSE_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"EXTRABUTTON_CB\", \"ii\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iExpanderGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n\n  /* IupExpander only */\n  iupClassRegisterAttribute(ic, \"BARPOSITION\", iExpanderGetPositionAttrib, iExpanderSetPositionAttrib, IUPAF_SAMEASSYSTEM, \"TOP\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BARSIZE\", iExpanderGetBarSizeAttrib, iExpanderSetBarSizeAttrib, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"STATE\", iExpanderGetStateAttrib, iExpanderSetStateAttrib, IUPAF_SAMEASSYSTEM, \"OPEN\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORECOLOR\", NULL, iExpanderSetForeColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HIGHCOLOR\", NULL, iExpanderSetHighColorAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"OPENCOLOR\", NULL, iExpanderSetOpenColorAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BACKCOLOR\", NULL, iExpanderSetBackColorAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, iExpanderSetTitleAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEIMAGE\", NULL, iExpanderSetTitleImageAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEIMAGEOPEN\", NULL, iExpanderSetTitleImageOpenAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEIMAGEHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEIMAGEOPENHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEEXPAND\", iExpanderGetTitleExpandAttrib, iExpanderSetTitleExpandAttrib, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"AUTOSHOW\", iExpanderGetAutoShowAttrib, iExpanderSetAutoShowAttrib, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXTRABUTTONS\", iExpanderGetExtraButtonsAttrib, iExpanderSetExtraButtonsAttrib, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ANIMATION\", iExpanderGetAnimationAttrib, iExpanderSetAnimationAttrib, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NUMFRAMES\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"10\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FRAMETIME\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"30\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, iExpanderSetImageAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEOPEN\", NULL, iExpanderSetImageOpenAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEOPENHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRA1\", NULL, iExpanderSetImageExtra1Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAPRESS1\", NULL, iExpanderSetImageExtraPress1Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAHIGHLIGHT1\", NULL, iExpanderSetImageExtraHighlight1Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRA2\", NULL, iExpanderSetImageExtra2Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAPRESS2\", NULL, iExpanderSetImageExtraPress2Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAHIGHLIGHT2\", NULL, iExpanderSetImageExtraHighlight2Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRA3\", NULL, iExpanderSetImageExtra3Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAPRESS3\", NULL, iExpanderSetImageExtraPress3Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEEXTRAHIGHLIGHT3\", NULL, iExpanderSetImageExtraHighlight3Attrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  if (!IupGetHandle(\"IupArrowUp\") || !IupGetHandle(\"IupArrowDown\"))\n    iExpanderLoadImages();\n\n  return ic;\n}\n\nIhandle* IupExpander(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"expander\", children);\n}\n","/** \\file\n * \\brief IupFileDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n\n\nIhandle* IupFileDlg(void)\n{\n  return IupCreate(\"filedlg\");\n}\n\nIclass* iupFileDlgNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"dialog\"));\n\n  ic->name = \"filedlg\";\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->is_interactive = 1;\n\n  iupClassRegisterCallback(ic, \"FILE_CB\", \"ss\");\n\n  ic->New = iupFileDlgNewClass;\n\n  /* reset not used native dialog methods */\n  ic->parent->LayoutUpdate = NULL;\n  ic->parent->SetChildrenPosition = NULL;\n  ic->parent->Map = NULL;\n  ic->parent->UnMap = NULL;\n\n  iupdrvFileDlgInitClass(ic);\n\n  /* only the default value */\n  iupClassRegisterAttribute(ic, \"NOCHANGEDIR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DIALOGTYPE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"OPEN\", IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"PREVIEWDC\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"PREVIEWWIDTH\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n  iupClassRegisterAttribute(ic, \"PREVIEWHEIGHT\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n\n  iupClassRegisterAttribute(ic, \"ALLOWNEW\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DIRECTORY\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FILE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FILTER\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NOOVERWRITEPROMPT\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWHIDDEN\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWPREVIEW\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"FILEEXIST\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n  iupClassRegisterAttribute(ic, \"STATUS\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n  iupClassRegisterAttribute(ic, \"VALUE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n\n  return ic;\n}\n","/** \\file\n * \\brief Fill Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n\n\nenum {IUP_FILL_NONE, IUP_FILL_HORIZ, IUP_FILL_VERT};\n\nstruct _IcontrolData \n{\n  int dir;\n};\n\nstatic int iFillGetDir(Ihandle* ih)\n{\n  if (!ih->parent)\n    return IUP_FILL_NONE;\n\n  if (ih->data->dir != IUP_FILL_NONE)\n    return ih->data->dir;\n\n  /* Its parent should be an IupHbox or an IupVbox. */\n  if (ih->parent->iclass->nativetype == IUP_TYPEVOID)\n  {\n    if (IupClassMatch(ih->parent, \"vbox\"))\n      ih->data->dir = IUP_FILL_VERT;\n    else\n      ih->data->dir = IUP_FILL_HORIZ;\n  }\n\n  return ih->data->dir;\n}\n\nstatic int iFillMapMethod(Ihandle* ih)\n{\n  iFillGetDir(ih);\n  return iupBaseTypeVoidMapMethod(ih);\n}\n\nstatic void iFillUnMapMethod(Ihandle* ih)\n{\n  ih->data->dir = IUP_FILL_NONE;\n}\n\nstatic int iFillSetRasterSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    if (iFillGetDir(ih) == IUP_FILL_NONE)  /* if Fill is not yet a child of a Vbox or Hbox */\n    {\n      iupAttribSet(ih, \"SIZE\", NULL);\n      return 1;\n    }\n\n    if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n      iupStrToIntInt(value, &s, &d, 'x');  /* second value will be ignored, can NOT set height */\n    else\n    {\n      iupStrToIntInt(value, &s, &d, 'x');  /* first value will be ignored if second defined, can NOT set width */\n      if (d != 0) s = d;\n    }\n\n    if (s > 0) \n    {\n      if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n      {\n        ih->userwidth = s;  /* inside HBOX */\n        ih->userheight = 0;\n      }\n      else\n      {\n        ih->userheight = s; /* inside VBOX */\n        ih->userwidth = 0;\n      }\n    }\n  }\n  iupAttribSet(ih, \"SIZE\", NULL);\n  return 0;\n}\n\nstatic int iFillSetSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    if (iFillGetDir(ih) == IUP_FILL_NONE) /* if Fill is not yet a child of a Vbox or Hbox */\n    {\n      iupAttribSet(ih, \"RASTERSIZE\", NULL);\n      return 1;\n    }\n\n    if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n      iupStrToIntInt(value, &s, &d, 'x');  /* second value will be ignored, can NOT set height */\n    else\n    {\n      iupStrToIntInt(value, &s, &d, 'x');  /* first value will be ignored if second defined, can NOT set width */\n      if (d != 0) s = d;\n    }\n\n    if (s > 0) \n    {\n      int charwidth, charheight;\n      iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n      if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n      {\n        ih->userwidth = iupWIDTH2RASTER(s, charwidth);  /* inside HBOX */\n        ih->userheight = 0;\n      }\n      else\n      {\n        ih->userheight = iupHEIGHT2RASTER(s, charheight); /* inside VBOX */\n        ih->userwidth = 0;\n      }\n    }\n  }\n  iupAttribSet(ih, \"RASTERSIZE\", NULL);\n  return 1;  /* always save in the hash table, so when FONT is changed SIZE can be updated */\n}\n\nstatic char* iFillGetExpandAttrib(Ihandle* ih)\n{\n  if (iFillGetDir(ih) == IUP_FILL_NONE) /* if Fill is not yet a child of a Vbox or Hbox */\n    return \"NO\";\n\n  /* if size is not defined, then expansion on that direction is permited */\n  if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n  {\n    if (ih->userwidth <= 0)\n      return \"HORIZONTAL\";\n  }\n  else\n  {\n    if (ih->userheight <= 0)\n      return \"VERTICAL\";\n  }\n\n  return \"NO\";\n}\n\nstatic void iFillUpdateSize(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"SIZE\");\n  if (value) \n  { \n    iFillSetSizeAttrib(ih, value);\n    iupAttribSet(ih, \"SIZE\", NULL);\n  }\n  value = iupAttribGet(ih, \"RASTERSIZE\");\n  if (value) \n  { \n    iFillSetRasterSizeAttrib(ih, value);\n    iupAttribSet(ih, \"RASTERSIZE\", NULL);\n  }\n}\n\nstatic void iFillComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  (void)children_expand;  /* unset if not a container */\n\n  /* EXPAND is initialized as none for FILL */\n  ih->expand = IUP_EXPAND_NONE;\n\n  iFillUpdateSize(ih);\n\n  /* always initialize the natural size using the user size,\n     must do this again because of iFillUpdateSize */\n  ih->naturalwidth = ih->userwidth;\n  ih->naturalheight = ih->userheight;\n\n  if (iFillGetDir(ih) == IUP_FILL_NONE) /* if Fill is not a child of a Vbox or Hbox */\n    return;\n\n  /* If size is NOT defined, then expansion on that direction is permited.\n     This type of expansion works only when inside a vbox, hbox or gridbox. */\n  if (iFillGetDir(ih) == IUP_FILL_HORIZ)\n  {\n    if (ih->naturalwidth <= 0)\n      ih->expand = IUP_EXPAND_W0;\n  }\n  else\n  {\n    if (ih->naturalheight <= 0)\n      ih->expand = IUP_EXPAND_H0;\n  }\n\n  *w = ih->naturalwidth;\n  *h = ih->naturalheight;\n}\n\nstatic int iFillCreateMethod(Ihandle* ih, void** params)\n{\n  (void)params;\n  ih->data = iupALLOCCTRLDATA();\n  return IUP_NOERROR;\n}\n\n/******************************************************************************/\n\nIhandle* IupFill(void)\n{\n  return IupCreate(\"fill\");\n}\n\nIclass* iupFillNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"fill\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupFillNewClass;\n  ic->Create = iFillCreateMethod;\n  ic->Map = iFillMapMethod;\n  ic->UnMap = iFillUnMapMethod;\n  ic->ComputeNaturalSize = iFillComputeNaturalSizeMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"SIZE\", iupBaseGetSizeAttrib, iFillSetSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iupBaseGetRasterSizeAttrib, iFillSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Base */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iFillGetExpandAttrib, NULL, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Button Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_image.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n#include \"iup_draw.h\"\n#include \"iup_key.h\"\n\n\n/* from IupRadio implementation */\nIhandle *iupRadioFindToggleParent(Ihandle* ih_toggle);\n\nenum{IUP_IMGPOS_LEFT, IUP_IMGPOS_RIGHT, IUP_IMGPOS_TOP, IUP_IMGPOS_BOTTOM};\n\nstruct _IcontrolData \n{\n  /* attributes */\n  int horiz_padding, vert_padding;  /* button margin */\n  int spacing, img_position;        /* used when both text and image are displayed */\n  int horiz_alignment, vert_alignment;  \n  int border_width;\n\n  /* aux */\n  int has_focus,\n    highlight,\n    pressed;\n};\n\n\n/****************************************************************/\n\n\nstatic void iFlatButtonDrawBorder(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int border_width, const char* color, char* bgcolor, int active)\n{\n  unsigned char r = 0, g = 0, b = 0;\n\n  if (!color || border_width == 0 || xmin == xmax || ymin == ymax)\n    return;\n\n  if (xmin > xmax) { int _t = xmin; xmin = xmax; xmax = _t; }\n  if (ymin > ymax) { int _t = ymin; ymin = ymax; ymax = _t; }\n\n  iupStrToRGB(color, &r, &g, &b);\n  if (!active)\n  {\n    unsigned char bg_r = 0, bg_g = 0, bg_b = 0;\n    iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);\n    iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n  }\n\n  iupDrawRectangle(dc, xmin, ymin, xmax, ymax, r, g, b, IUP_DRAW_STROKE);\n  while (border_width > 1)\n  {\n    border_width--;\n    iupDrawRectangle(dc, xmin + border_width, \n                         ymin + border_width, \n                         xmax - border_width, \n                         ymax - border_width, r, g, b, IUP_DRAW_STROKE);\n  } \n}\n\nstatic void iFlatButtonDrawBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, const char* color, char* bgcolor, int active)\n{\n  unsigned char r = 0, g = 0, b = 0;\n\n  if (!color || xmin == xmax || ymin == ymax)\n    return;\n\n  if (xmin > xmax) { int _t = xmin; xmin = xmax; xmax = _t; }\n  if (ymin > ymax) { int _t = ymin; ymin = ymax; ymax = _t; }\n\n  iupStrToRGB(color, &r, &g, &b);\n  if (!active)\n  {\n    unsigned char bg_r = 0, bg_g = 0, bg_b = 0;\n    iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);\n    iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n  }\n\n  iupDrawRectangle(dc, xmin, ymin, xmax, ymax, r, g, b, IUP_DRAW_FILL);\n}\n\nstatic char* iFlatButtonMakeImageName(Ihandle* ih, const char* baseattrib, const char* state)\n{\n  char attrib[1024];\n  strcpy(attrib, baseattrib);\n  strcat(attrib, state);\n  return iupAttribGet(ih, attrib);\n}\n\nstatic const char* iFlatButtonGetImageName(Ihandle* ih, const char* baseattrib, const char* basename, int active, int *make_inactive)\n{\n  const char* imagename = NULL;\n\n  *make_inactive = 0;\n\n  if (baseattrib)\n  {\n    if (active)\n    {\n      if (ih->data->pressed)\n        imagename = iFlatButtonMakeImageName(ih, baseattrib, \"PRESS\");\n      else\n      {\n        if (ih->data->highlight)\n          imagename = iFlatButtonMakeImageName(ih, baseattrib, \"HIGHLIGHT\");\n      }\n    }\n    else\n    {\n      imagename = iFlatButtonMakeImageName(ih, baseattrib, \"INACTIVE\");\n      if (!imagename)\n        *make_inactive = 1;\n    }\n  }\n\n  if (imagename)\n    return imagename;\n  else\n    return basename;\n}\n\nstatic void iFlatButtonDrawImage(Ihandle* ih, IdrawCanvas* dc, int x, int y, const char* baseattrib, const char* imagename, int active)\n{\n  int img_w, img_h;\n  int make_inactive;\n  const char* name = iFlatButtonGetImageName(ih, baseattrib, imagename, active, &make_inactive);\n  iupDrawImage(dc, name, make_inactive, x, y, &img_w, &img_h);\n}\n\nvoid iFlatButtonDrawText(Ihandle* ih, IdrawCanvas* dc, int x, int y, const char* str, const char* color, const char* bgcolor, int active)\n{\n  unsigned char r = 0, g = 0, b = 0;\n\n  if (!color || !str || str[0] == 0)\n    return;\n\n  iupStrToRGB(color, &r, &g, &b);\n  if (!active)\n  {\n    unsigned char bg_r = 0, bg_g = 0, bg_b = 0;\n    iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);\n    iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n  }\n\n  iupDrawText(dc, str, (int)strlen(str), x, y, r, g, b, IupGetAttribute(ih, \"FONT\"));\n}\n\nstatic void iFlatButtonGetIconPosition(Ihandle* ih, int icon_width, int icon_height, int *x, int *y, int width, int height)\n{\n  if (ih->data->horiz_alignment == IUP_ALIGN_ARIGHT)\n    *x = icon_width - (width + 2 * ih->data->horiz_padding);\n  else if (ih->data->horiz_alignment == IUP_ALIGN_ACENTER)\n    *x = (icon_width - (width + 2 * ih->data->horiz_padding)) / 2;\n  else  /* ALEFT */\n    *x = 0;\n\n  if (ih->data->vert_alignment == IUP_ALIGN_ABOTTOM)\n    *y = icon_height - (height + 2 * ih->data->vert_padding);\n  else if (ih->data->vert_alignment == IUP_ALIGN_ACENTER)\n    *y = (icon_height - (height + 2 * ih->data->vert_padding)) / 2;\n  else  /* ATOP */\n    *y = 0;\n\n  *x += ih->data->horiz_padding;\n  *y += ih->data->vert_padding;\n}\n\nstatic void iFlatButtonGetImageTextPosition(int x, int y, int img_position, int spacing,\n                                            int img_width, int img_height, int txt_width, int txt_height,\n                                            int *img_x, int *img_y, int *txt_x, int *txt_y)\n{\n  switch (img_position)\n  {\n  case IUP_IMGPOS_TOP:\n    *img_y = y;\n    *txt_y = y + img_height + spacing;\n    if (img_width > txt_width)\n    {\n      *img_x = x;\n      *txt_x = x + (img_width - txt_width) / 2;\n    }\n    else\n    {\n      *img_x = x + (txt_width - img_width) / 2;\n      *txt_x = x;\n    }\n    break;\n  case IUP_IMGPOS_BOTTOM:\n    *img_y = y + txt_height + spacing;\n    *txt_y = y;\n    if (img_width > txt_width)\n    {\n      *img_x = x;\n      *txt_x = x + (img_width - txt_width) / 2;\n    }\n    else\n    {\n      *img_x = x + (txt_width - img_width) / 2;\n      *txt_x = x;\n    }\n    break;\n  case IUP_IMGPOS_RIGHT:\n    *img_x = x + txt_width + spacing;\n    *txt_x = x;\n    if (img_height > txt_height)\n    {\n      *img_y = y;\n      *txt_y = y + (img_height - txt_height) / 2;\n    }\n    else\n    {\n      *img_y = y + (txt_height - img_height) / 2;\n      *txt_y = y;\n    }\n    break;\n  default: /* IUP_IMGPOS_LEFT (image at left of text) */\n    *img_x = x;\n    *txt_x = x + img_width + spacing;\n    if (img_height > txt_height)\n    {\n      *img_y = y;\n      *txt_y = y + (img_height - txt_height) / 2;\n    }\n    else\n    {\n      *img_y = y + (txt_height - img_height) / 2;\n      *txt_y = y;\n    }\n    break;\n  }\n}\n\nstatic void iFlatButtonDrawIcon(Ihandle* ih, IdrawCanvas* dc, int icon_x, int icon_y, int icon_width, int icon_height,\n                                const char *baseattrib, const char* imagename, const char* title, const char* fgcolor, const char* bgcolor, int active)\n{\n  int x, y, width, height;\n\n  if (imagename)\n  {\n    if (title)\n    {\n      int img_x, img_y, txt_x, txt_y;\n      int txt_width, txt_height;\n      int img_width, img_height;\n\n      iupdrvFontGetMultiLineStringSize(ih, title, &txt_width, &txt_height);\n      iupImageGetInfo(imagename, &img_width, &img_height, NULL);\n\n      if (ih->data->img_position == IUP_IMGPOS_RIGHT || ih->data->img_position == IUP_IMGPOS_LEFT)\n      {\n        width = img_width + txt_width + ih->data->spacing;\n        height = iupMAX(img_height, txt_height);\n      }\n      else\n      {\n        width = iupMAX(img_width, txt_width);\n        height = img_height + txt_height + ih->data->spacing;\n      }\n\n      iFlatButtonGetIconPosition(ih, icon_width, icon_height, &x, &y, width, height);\n\n      iFlatButtonGetImageTextPosition(x, y, ih->data->img_position, ih->data->spacing,\n                                      img_width, img_height, txt_width, txt_height,\n                                      &img_x, &img_y, &txt_x, &txt_y);\n\n      iFlatButtonDrawImage(ih, dc, img_x + icon_x, img_y + icon_y, baseattrib, imagename, active);\n      iFlatButtonDrawText(ih, dc, txt_x + icon_x, txt_y + icon_y, title, fgcolor, bgcolor, active);\n    }\n    else\n    {\n      iupImageGetInfo(imagename, &width, &height, NULL);\n\n      iFlatButtonGetIconPosition(ih, icon_width, icon_height, &x, &y, width, height);\n\n      iFlatButtonDrawImage(ih, dc, x + icon_x, y + icon_y, baseattrib, imagename, active);\n    }\n  }\n  else if (title)\n  {\n    iupdrvFontGetMultiLineStringSize(ih, title, &width, &height);\n\n    iFlatButtonGetIconPosition(ih, icon_width, icon_height, &x, &y, width, height);\n\n    iFlatButtonDrawText(ih, dc, x + icon_x, y + icon_y, title, fgcolor, bgcolor, active);\n  }\n}\n\nstatic int iFlatButtonRedraw_CB(Ihandle* ih)\n{\n  char *image = iupAttribGet(ih, \"IMAGE\");\n  char* title = iupAttribGet(ih, \"TITLE\");\n  int active = IupGetInt(ih, \"ACTIVE\");  /* native implementation */\n  int selected = iupAttribGetInt(ih, \"VALUE\");\n  char* fgcolor = iupAttribGetStr(ih, \"FGCOLOR\");\n  char* bgcolor = iupAttribGetStr(ih, \"BGCOLOR\");\n  char* bgimage = iupAttribGet(ih, \"BACKIMAGE\");\n  char* fgimage = iupAttribGet(ih, \"FRONTIMAGE\");\n  int border_width = ih->data->border_width;\n  int draw_border = 0;\n  int old_pressed = ih->data->pressed;\n  IdrawCanvas* dc = iupDrawCreateCanvas(ih);\n  \n  iupDrawParentBackground(dc);\n\n  if (!bgcolor)\n    bgcolor = iupBaseNativeParentGetBgColorAttrib(ih);\n\n  if (ih->data->pressed || selected)\n  {\n    char* presscolor = iupAttribGetStr(ih, \"PSCOLOR\");\n    if (presscolor)\n      bgcolor = presscolor;\n\n    draw_border = 1;\n\n    if (!ih->data->pressed && (bgimage || image))\n      ih->data->pressed = 1;\n  }\n  else if (ih->data->highlight)\n  {\n    char* hlcolor = iupAttribGetStr(ih, \"HLCOLOR\");\n    if (hlcolor)\n      bgcolor = hlcolor;\n\n    draw_border = 1;\n  }\n\n  /* draw border - can still be disabled setting border_width=0 */\n  if (draw_border)\n  {\n    char* bordercolor = iupAttribGetStr(ih, \"BORDERCOLOR\");\n    iFlatButtonDrawBorder(dc, 0, ih->currentwidth - 1, \n                              0, ih->currentheight - 1, \n                              border_width, bordercolor, bgcolor, active);\n  }\n\n  /* draw background */\n  if (bgimage)\n    iFlatButtonDrawImage(ih, dc, border_width, border_width, \"BACKIMAGE\", bgimage, active);\n  else\n    iFlatButtonDrawBox(dc, border_width, ih->currentwidth - 1 - border_width,\n                           border_width, ih->currentheight - 1 - border_width,\n                           bgcolor, NULL, 1);  /* always active */\n\n  iFlatButtonDrawIcon(ih, dc, border_width, border_width,\n                              ih->currentwidth - 2 * border_width, ih->currentheight - 2 * border_width,\n                              \"IMAGE\", image, title, fgcolor, bgcolor, active);\n\n  if (fgimage)\n    iFlatButtonDrawImage(ih, dc, border_width, border_width, \"FRONTIMAGE\", fgimage, active);\n  else if (!image && !title)\n  {\n    int space = border_width + 2;\n    iFlatButtonDrawBorder(dc, space, ih->currentwidth - 1 - space,\n                              space, ih->currentheight - 1 - space,\n                              1, \"0 0 0\", bgcolor, active);\n    space++;\n    iFlatButtonDrawBox(dc, space, ih->currentwidth - 1 - space,\n                           space, ih->currentheight - 1 - space,\n                           fgcolor, bgcolor, active);\n  }\n\n\n  if (selected && !old_pressed && (bgimage || image))\n    ih->data->pressed = 0;\n\n  if (ih->data->has_focus)\n    iupDrawFocusRect(dc, border_width, border_width, ih->currentwidth - 2 * border_width, ih->currentheight - 2 * border_width);\n\n  iupDrawFlush(dc);\n\n  iupDrawKillCanvas(dc);\n\n  return IUP_DEFAULT;\n}\n\nstatic void iFlatButtonNotify(Ihandle* ih, int is_toggle)\n{\n  Icallback cb = IupGetCallback(ih, \"FLAT_ACTION\");\n  if (cb)\n  {\n    int ret = cb(ih);\n    if (ret == IUP_CLOSE)\n      IupExitLoop();\n  }\n\n  if (is_toggle)\n  {\n    if (iupObjectCheck(ih))\n      iupBaseCallValueChangedCb(ih);\n  }\n}\n\nstatic int iFlatButtonButton_CB(Ihandle* ih, int button, int pressed, int x, int y, char* status)\n{\n  IFniiiis cb = (IFniiiis)IupGetCallback(ih, \"FLAT_BUTTON_CB\");\n  if (cb)\n  {\n    if (cb(ih, button, pressed, x, y, status) == IUP_IGNORE)\n      return IUP_DEFAULT;\n  }\n\n  if (button == IUP_BUTTON1)\n  {\n    if (iupAttribGetBoolean(ih, \"TOGGLE\"))\n    {\n      Ihandle* radio = iupRadioFindToggleParent(ih);\n      int selected = iupAttribGetInt(ih, \"VALUE\");\n      Ihandle* last_tg = NULL;\n\n      if (!pressed)\n      {\n        if (selected)  /* was ON */\n        {\n          if (!radio)\n          {\n            iupAttribSet(ih, \"VALUE\", \"OFF\");\n            selected = 0;\n          }\n          else\n            last_tg = ih;  /* to avoid the callback call */\n        }\n        else  /* was OFF */\n        {\n          if (radio)\n          {\n            last_tg = (Ihandle*)iupAttribGet(radio, \"_IUP_FLATBUTTON_LASTRADIO\");\n            if (iupObjectCheck(last_tg) && last_tg != ih)\n            {\n              iupAttribSet(last_tg, \"VALUE\", \"OFF\");\n              iupdrvRedrawNow(last_tg);\n            }\n            else\n              last_tg = NULL;\n\n            iupAttribSet(radio, \"_IUP_FLATBUTTON_LASTRADIO\", (char*)ih);\n          }\n\n          iupAttribSet(ih, \"VALUE\", \"ON\");\n          selected = 1;\n        }\n      }\n\n      ih->data->pressed = pressed;\n      iupdrvRedrawNow(ih);\n\n      if (!pressed)\n      {\n        if (last_tg && ih != last_tg)\n          iFlatButtonNotify(last_tg, 1);\n\n        if (!radio || ih != last_tg)\n          iFlatButtonNotify(ih, 1);\n      }\n    }\n    else\n    {\n      ih->data->pressed = pressed;\n      iupdrvRedrawNow(ih);\n\n      if (!pressed)\n        iFlatButtonNotify(ih, 0);\n    }\n  }\n\n  return IUP_DEFAULT;\n}\n\nstatic int iFlatButtonActivate_CB(Ihandle* ih)\n{\n  char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;\n\n  iFlatButtonButton_CB(ih, IUP_BUTTON1, 1, 0, 0, status);\n\n  iupdrvSleep(100);\n\n  iFlatButtonButton_CB(ih, IUP_BUTTON1, 0, 0, 0, status);\n\n  return IUP_DEFAULT;\n}\n\nstatic int iFlatButtonFocus_CB(Ihandle* ih, int focus)\n{\n  IFni cb = (IFni)IupGetCallback(ih, \"FLAT_FOCUS_CB\");\n  if (cb)\n  {\n    if (cb(ih, focus) == IUP_IGNORE)\n      return IUP_DEFAULT;\n  }\n\n  ih->data->has_focus = focus;\n  iupdrvRedrawNow(ih);\n\n  return IUP_DEFAULT;\n}\n\nstatic int iFlatButtonEnterWindow_CB(Ihandle* ih)\n{\n  IFn cb = (IFn)IupGetCallback(ih, \"FLAT_ENTERWINDOW_CB\");\n  if (cb)\n  {\n    if (cb(ih) == IUP_IGNORE)\n      return IUP_DEFAULT;\n  }\n\n  ih->data->highlight = 1;\n  iupdrvRedrawNow(ih);\n\n  return IUP_DEFAULT;\n}\n\nstatic int iFlatButtonLeaveWindow_CB(Ihandle* ih)\n{\n  IFn cb = (IFn)IupGetCallback(ih, \"FLAT_LEAVEWINDOW_CB\");\n  if (cb)\n  {\n    if (cb(ih) == IUP_IGNORE)\n      return IUP_DEFAULT;\n  }\n\n  ih->data->highlight = 0;\n  iupdrvRedrawNow(ih);\n\n  return IUP_DEFAULT;\n}\n\n\n/***********************************************************************************************/\n\n\nstatic int iFlatButtonSetActiveAttrib(Ihandle* ih, const char* value)\n{\n  iupBaseSetActiveAttrib(ih, value);\n  iupdrvRedrawNow(ih);\n  return 0; \n}\n\nstatic int iFlatButtonSetAlignmentAttrib(Ihandle* ih, const char* value)\n{\n  char value1[30], value2[30];\n\n  iupStrToStrStr(value, value1, value2, ':');\n\n  if (iupStrEqualNoCase(value1, \"ARIGHT\"))\n    ih->data->horiz_alignment = IUP_ALIGN_ARIGHT;\n  else if (iupStrEqualNoCase(value1, \"ALEFT\"))\n    ih->data->horiz_alignment = IUP_ALIGN_ALEFT;\n  else /* \"ACENTER\" */\n    ih->data->horiz_alignment = IUP_ALIGN_ACENTER;\n\n  if (iupStrEqualNoCase(value2, \"ABOTTOM\"))\n    ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;\n  else if (iupStrEqualNoCase(value2, \"ATOP\"))\n    ih->data->vert_alignment = IUP_ALIGN_ATOP;\n  else /* \"ACENTER\" */\n    ih->data->vert_alignment = IUP_ALIGN_ACENTER;\n\n  if (ih->handle)\n    iupdrvRedrawNow(ih);\n\n  return 1;\n}\n\nstatic char* iFlatButtonGetAlignmentAttrib(Ihandle *ih)\n{\n  char* horiz_align2str[3] = {\"ALEFT\", \"ACENTER\", \"ARIGHT\"};\n  char* vert_align2str[3] = {\"ATOP\", \"ACENTER\", \"ABOTTOM\"};\n  return iupStrReturnStrf(\"%s:%s\", horiz_align2str[ih->data->horiz_alignment], vert_align2str[ih->data->vert_alignment]);\n}\n\nstatic int iFlatButtonSetPaddingAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');\n  if (ih->handle)\n    iupdrvRedrawNow(ih);\n  return 0;\n}\n\nstatic int iFlatButtonSetBgColorAttrib(Ihandle* ih, const char* value)\n{\n  iupAttribSet(ih, \"BGCOLOR\", value);\n  iupImageUpdateParent(ih);\n  iupdrvRedrawNow(ih);\n  return 1;\n}\n\nstatic char* iFlatButtonGetBgColorAttrib(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"BGCOLOR\");\n  if (!value)\n    return iupBaseNativeParentGetBgColorAttrib(ih);\n  else\n    return value;\n}\n\nstatic char* iFlatButtonGetPaddingAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n}\n\nstatic int iFlatButtonSetImagePositionAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"RIGHT\"))\n    ih->data->img_position = IUP_IMGPOS_RIGHT;\n  else if (iupStrEqualNoCase(value, \"BOTTOM\"))\n    ih->data->img_position = IUP_IMGPOS_BOTTOM;\n  else if (iupStrEqualNoCase(value, \"TOP\"))\n    ih->data->img_position = IUP_IMGPOS_TOP;\n  else /* \"LEFT\" */\n    ih->data->img_position = IUP_IMGPOS_LEFT;\n\n  if (ih->handle)\n    iupdrvRedrawNow(ih);\n\n  return 0;\n}\n\nstatic char* iFlatButtonGetImagePositionAttrib(Ihandle *ih)\n{\n  char* img_pos2str[4] = {\"LEFT\", \"RIGHT\", \"TOP\", \"BOTTOM\"};\n  return iupStrReturnStr(img_pos2str[ih->data->img_position]);\n}\n\nstatic int iFlatButtonSetSpacingAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->spacing);\n  if (ih->handle)\n    iupdrvRedrawNow(ih);\n  return 0;\n}\n\nstatic char* iFlatButtonGetSpacingAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->data->spacing);\n}\n\nstatic int iFlatButtonSetBorderWidthAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->border_width);\n  if (ih->handle)\n    iupdrvRedrawNow(ih);\n  return 0;\n}\n\nstatic char* iFlatButtonGetBorderWidthAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->data->border_width);\n}\n\nstatic int iFlatButtonSetValueAttrib(Ihandle* ih, const char* value)\n{\n  if (iupAttribGetBoolean(ih, \"TOGGLE\"))\n  {\n    Ihandle* radio = iupRadioFindToggleParent(ih);\n    if (radio)\n    {\n      /* can only set Radio to ON */\n      if (iupStrEqualNoCase(value, \"TOGGLE\") || iupStrBoolean(value))\n      {\n        Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, \"_IUP_FLATBUTTON_LASTRADIO\");\n        if (iupObjectCheck(last_tg) && last_tg != ih)\n        {\n          iupAttribSet(last_tg, \"VALUE\", \"OFF\");\n          if (last_tg->handle)\n            iupdrvRedrawNow(last_tg);\n        }\n\n        iupAttribSet(radio, \"_IUP_FLATBUTTON_LASTRADIO\", (char*)ih);\n      }\n      else\n        return 0;\n    }\n    else\n    {\n      if (iupStrEqualNoCase(value, \"TOGGLE\"))\n      {\n        int oldcheck = iupAttribGetBoolean(ih, \"VALUE\");\n        if (oldcheck)\n          iupAttribSet(ih, \"VALUE\", \"OFF\");\n        else\n          iupAttribSet(ih, \"VALUE\", \"ON\");\n\n        if (ih->handle)\n          iupdrvRedrawNow(ih);\n\n        return 0;\n      }\n    }\n\n    if (ih->handle)\n      iupdrvPostRedraw(ih);\n\n    return 1;\n  }\n  else\n    return 0;\n}\n\nstatic char* iFlatButtonGetRadioAttrib(Ihandle* ih)\n{\n  if (iupAttribGetBoolean(ih, \"TOGGLE\"))\n  {\n    Ihandle* radio = iupRadioFindToggleParent(ih);\n    return iupStrReturnBoolean(radio != NULL);\n  }\n  else\n    return NULL;\n}\n\n\n/*****************************************************************************************/\n\n\nstatic int iFlatButtonCreateMethod(Ihandle* ih, void** params)\n{\n  if (params && params[0])\n  {\n    iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n  }\n  \n  /* free the data allocated by IupCanvas */\n  free(ih->data);\n  ih->data = iupALLOCCTRLDATA();\n\n  /* change the IupCanvas default values */\n  iupAttribSet(ih, \"BORDER\", \"NO\");\n  ih->expand = IUP_EXPAND_NONE;\n\n  /* non zero default values */\n  ih->data->spacing = 2;\n  ih->data->border_width = 1;\n  ih->data->horiz_alignment = IUP_ALIGN_ACENTER;\n  ih->data->vert_alignment = IUP_ALIGN_ACENTER;\n  \n  IupSetCallback(ih, \"ACTION\", (Icallback)iFlatButtonRedraw_CB);\n  IupSetCallback(ih, \"BUTTON_CB\", (Icallback)iFlatButtonButton_CB);\n  IupSetCallback(ih, \"FOCUS_CB\", (Icallback)iFlatButtonFocus_CB);\n  IupSetCallback(ih, \"LEAVEWINDOW_CB\", iFlatButtonLeaveWindow_CB);\n  IupSetCallback(ih, \"ENTERWINDOW_CB\", iFlatButtonEnterWindow_CB);\n  IupSetCallback(ih, \"K_CR\", (Icallback)iFlatButtonActivate_CB);\n  IupSetCallback(ih, \"K_SP\", (Icallback)iFlatButtonActivate_CB);\n\n  return IUP_NOERROR;\n}\n\nstatic int iFlatButtonMapMethod(Ihandle* ih)\n{\n  if (iupAttribGetBoolean(ih, \"TOGGLE\"))\n  {\n    Ihandle* radio = iupRadioFindToggleParent(ih);\n    if (radio)\n    {\n      if (!iupAttribGet(radio, \"_IUP_FLATBUTTON_LASTRADIO\"))\n      {\n        /* this is the first toggle in the radio, and then set it with VALUE=ON */\n        iupAttribSet(ih, \"VALUE\", \"ON\");\n      }\n    }\n  }\n  return IUP_NOERROR;\n}\n\nstatic void iFlatButtonComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int fit2backimage = iupAttribGetBoolean(ih, \"FITTOBACKIMAGE\");\n  char* bgimage = iupAttribGet(ih, \"BACKIMAGE\");\n  if (fit2backimage && bgimage)\n    iupImageGetInfo(bgimage, w, h, NULL);\n  else\n  {\n    char* image = iupAttribGet(ih, \"IMAGE\");\n    char* title = iupAttribGet(ih, \"TITLE\");\n\n    *w = 0,\n    *h = 0;\n\n    if (image)\n    {\n      iupImageGetInfo(image, w, h, NULL);\n\n      if (title)\n      {\n        int text_w, text_h;\n        iupdrvFontGetMultiLineStringSize(ih, title, &text_w, &text_h);\n\n        if (ih->data->img_position == IUP_IMGPOS_RIGHT ||\n            ih->data->img_position == IUP_IMGPOS_LEFT)\n        {\n          *w += text_w + ih->data->spacing;\n          *h = iupMAX(*h, text_h);\n        }\n        else\n        {\n          *w = iupMAX(*w, text_w);\n          *h += text_h + ih->data->spacing;\n        }\n      }\n    }\n    else if (title)\n      iupdrvFontGetMultiLineStringSize(ih, title, w, h);\n\n    *w += 2 * ih->data->horiz_padding;\n    *h += 2 * ih->data->vert_padding;\n\n    *w += 2 * ih->data->border_width;\n    *h += 2 * ih->data->border_width;\n  }\n\n  (void)children_expand; /* unset if not a container */\n}\n\n\n/******************************************************************************/\n\n\nIclass* iupFlatButtonNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"canvas\"));\n\n  ic->name = \"flatbutton\";\n  ic->format = \"s\"; /* one string */\n  ic->nativetype = IUP_TYPECANVAS;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupFlatButtonNewClass;\n  ic->Create = iFlatButtonCreateMethod;\n  ic->ComputeNaturalSize = iFlatButtonComputeNaturalSizeMethod;\n  ic->Map = iFlatButtonMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"FLAT_ACTION\", \"\");\n  iupClassRegisterCallback(ic, \"FLAT_BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"FLAT_FOCUS_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"FLAT_ENTERWINDOW_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"FLAT_LEAVEWINDOW_CB\", \"\");\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n\n  /* Overwrite Visual */\n  iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, iFlatButtonSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n\n  /* Special */\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n\n  /* IupButton only */\n  iupClassRegisterAttribute(ic, \"VALUE\", NULL, iFlatButtonSetValueAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RADIO\", iFlatButtonGetRadioAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TOGGLE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", iFlatButtonGetAlignmentAttrib, iFlatButtonSetAlignmentAttrib, \"ACENTER:ACENTER\", NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PADDING\", iFlatButtonGetPaddingAttrib, iFlatButtonSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"SPACING\", iFlatButtonGetSpacingAttrib, iFlatButtonSetSpacingAttrib, IUPAF_SAMEASSYSTEM, \"2\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"BORDERCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"50 150 255\", IUPAF_DEFAULT);  /* inheritable */\n  iupClassRegisterAttribute(ic, \"BORDERWIDTH\", iFlatButtonGetBorderWidthAttrib, iFlatButtonSetBorderWidthAttrib, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_DEFAULT);  /* inheritable */\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, NULL, \"DLGFGCOLOR\", NULL, IUPAF_NOT_MAPPED);  /* force the new default value */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", iFlatButtonGetBgColorAttrib, iFlatButtonSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_NO_SAVE | IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"HLCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"200 225 245\", IUPAF_DEFAULT);  /* inheritable */\n  iupClassRegisterAttribute(ic, \"PSCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"150 200 235\", IUPAF_DEFAULT);  /* inheritable */\n\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEPRESS\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEINACTIVE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  \n  iupClassRegisterAttribute(ic, \"IMAGEPOSITION\", iFlatButtonGetImagePositionAttrib, iFlatButtonSetImagePositionAttrib, IUPAF_SAMEASSYSTEM, \"LEFT\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"BACKIMAGE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BACKIMAGEPRESS\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BACKIMAGEHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BACKIMAGEINACTIVE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  \n  iupClassRegisterAttribute(ic, \"FITTOBACKIMAGE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"FRONTIMAGE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FRONTIMAGEPRESS\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FRONTIMAGEHIGHLIGHT\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FRONTIMAGEINACTIVE\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle* IupFlatButton(const char* title)\n{\n  void *params[2];\n  params[0] = (void*)title;\n  params[1] = NULL;\n  return IupCreatev(\"flatbutton\", params);\n}\n","/** \\file\n * \\brief Keyboard Focus navigation\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_focus.h\"\n#include \"iup_class.h\"\n#include \"iup_assert.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n\n\nIhandle* iupFocusNextInteractive(Ihandle *ih)\n{\n  Ihandle *c;\n\n  if (!ih)\n    return NULL;\n\n  for (c = ih->brother; c; c = c->brother)\n  {\n    if (c->iclass->is_interactive)\n      return c;\n  }\n\n  return NULL;\n}\n\nint iupFocusCanAccept(Ihandle *ih)\n{\n  if (ih->iclass->is_interactive &&  /* interactive */\n      iupAttribGetBoolean(ih, \"CANFOCUS\") &&   /* can receive focus */\n      ih->handle &&                  /* mapped  */\n      IupGetInt(ih, \"ACTIVE\") &&     /* active  */\n      IupGetInt(ih, \"VISIBLE\"))      /* visible */\n    return 1;\n  else\n    return 0;\n}\n\nstatic int iFocusCheckActiveRadio(Ihandle *ih)\n{\n  if (IupClassMatch(ih, \"toggle\") && \n      IupGetInt(ih, \"RADIO\") &&\n      !IupGetInt(ih, \"VALUE\"))\n    return 0;\n  else\n    return 1;\n}\n\nstatic Ihandle* iFocusFindAtBrothers(Ihandle *start, int checkradio)\n{\n  Ihandle *c;\n  Ihandle *nf;\n\n  for (c = start; c; c = c->brother)\n  {\n    /* check itself */\n    if (iupFocusCanAccept(c) && (!checkradio || iFocusCheckActiveRadio(c)))\n      return c;\n\n    /* then check its children */\n    nf = iFocusFindAtBrothers(c->firstchild, checkradio);\n    if (nf)\n      return nf;\n  }\n\n  return NULL;\n}\n\nstatic Ihandle* iFocusFindNext(Ihandle *ih, int checkradio)\n{\n  Ihandle *nf, *p;\n\n  if (!ih)\n    return NULL;\n\n  /* look down in the child tree */\n  if (ih->firstchild)\n  {\n    nf = iFocusFindAtBrothers(ih->firstchild, checkradio);\n    if (nf) return nf;\n  }\n\n  /* look in the same level */\n  if (ih->brother)\n  {\n    nf = iFocusFindAtBrothers(ih->brother, checkradio);\n    if (nf) return nf;\n  }\n\n  /* look up in the brothers of the parent level */\n  if (ih->parent)\n  {\n    for (p = ih->parent; p; p = p->parent)\n    {\n      if (p->brother)\n      {\n        nf = iFocusFindAtBrothers(p->brother, checkradio);\n        if (nf) return nf;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nIhandle* IupNextField(Ihandle *ih)\n{\n  Ihandle *ih_next;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  ih_next = iFocusFindNext(ih, 1);\n  if (!ih_next)\n  {\n    /* not found after the element, then start over from the begining,\n       at the dialog. */\n    ih_next = iFocusFindNext(IupGetDialog(ih), 1);\n    if (ih_next == ih)\n      return NULL;\n  }\n\n  if (ih_next)\n  {\n    iupdrvSetFocus(ih_next);\n    return ih_next;\n  }\n\n  return NULL;\n}\n\nvoid iupFocusNext(Ihandle *ih)\n{\n  Ihandle *ih_next = iFocusFindNext(ih, 0);\n  if (!ih_next)\n  {\n    /* not found after the element, then start over from the begining,\n       at the dialog. */\n    ih_next = iFocusFindNext(IupGetDialog(ih), 0);\n    if (ih_next == ih)\n      return;\n  }\n  if (ih_next)\n    iupdrvSetFocus(ih_next);\n}\n\nstatic int iFocusFindPrevious(Ihandle *parent, Ihandle **previous, Ihandle *ih, int checkradio)\n{\n  Ihandle *c;\n\n  if (!parent)\n    return 0;\n\n  for (c = parent->firstchild; c; c = c->brother)\n  {\n    if (c == ih)\n    {\n      /* if found child, returns the current previous.\n         but if previous is NULL, then keep searching until the last element. */\n      if (*previous)\n        return 1;\n    }\n    else\n    {\n      /* save the possible previous */\n      if (iupFocusCanAccept(c) && (!checkradio || iFocusCheckActiveRadio(c)))\n        *previous = c;\n    }\n\n    /* then check its children */\n    if (iFocusFindPrevious(c, previous, ih, checkradio))\n      return 1;\n  }\n\n  return 0;\n}\n\nIhandle* IupPreviousField(Ihandle *ih)\n{\n  Ihandle *previous = NULL;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  /* search from the dialog down to the element */\n  iFocusFindPrevious(IupGetDialog(ih), &previous, ih, 1);\n  \n  if (previous)\n  {\n    iupdrvSetFocus(previous);\n    return previous;\n  }\n\n  return NULL;\n}\n\nvoid iupFocusPrevious(Ihandle *ih)\n{\n  Ihandle *previous = NULL;\n\n  /* search from the dialog down to the element */\n  iFocusFindPrevious(IupGetDialog(ih), &previous, ih, 0);\n  \n  if (previous)\n    iupdrvSetFocus(previous);\n}\n\n/* local variables */\nstatic Ihandle* iup_current_focus = NULL;\n\nIhandle* IupGetFocus(void)\n{\n  return iup_current_focus;\n}\n\nvoid iupSetCurrentFocus(Ihandle *ih)\n{\n  iup_current_focus = ih;\n}\n\nIhandle *IupSetFocus(Ihandle *ih)\n{\n  Ihandle* old_focus = IupGetFocus();\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return old_focus;\n\n  /* Current focus is NOT set here, \n     only in the iupCallGetFocusCb */\n\n  if (iupFocusCanAccept(ih))  \n    iupdrvSetFocus(ih);\n\n  return old_focus;\n}\n\nvoid iupCallGetFocusCb(Ihandle *ih)\n{\n  Icallback cb;\n\n  if (ih == IupGetFocus())  /* avoid duplicate messages */\n    return;\n\n  cb = (Icallback)IupGetCallback(ih, \"GETFOCUS_CB\");\n  if (cb) cb(ih);\n\n  if (ih->iclass->nativetype == IUP_TYPECANVAS)\n  {\n    IFni cb2 = (IFni)IupGetCallback(ih, \"FOCUS_CB\");\n    if (cb2) cb2(ih, 1);\n  }\n\n  iupSetCurrentFocus(ih);\n}\n\nvoid iupCallKillFocusCb(Ihandle *ih)\n{\n  Icallback cb;\n\n  if (ih != IupGetFocus())  /* avoid duplicate messages */\n    return;\n\n  cb = IupGetCallback(ih, \"KILLFOCUS_CB\");\n  if (cb) cb(ih);\n\n  if (ih->iclass->nativetype == IUP_TYPECANVAS)\n  {\n    IFni cb2 = (IFni)IupGetCallback(ih, \"FOCUS_CB\");\n    if (cb2) cb2(ih, 0);\n  }\n\n  iupSetCurrentFocus(NULL);\n}\n","/** \\file\n * \\brief Font mapping\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h> \n#include <string.h> \n#include <stdio.h> \n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_assert.h\"\n#include \"iup_attrib.h\"\n#include \"iup_class.h\"\n\ntypedef struct _IfontNameMap {\n  const char* pango;\n  const char* x;\n  const char* win;\n} IfontNameMap;\n\n#define IFONT_NAME_MAP_SIZE 7\n\nstatic IfontNameMap ifont_name_map[IFONT_NAME_MAP_SIZE] = {\n  {\"sans\",      \"helvetica\",              \"arial\"},\n  {NULL,        \"new century schoolbook\", \"century schoolbook\"},\n  {\"monospace\", \"courier\",                \"courier new\"},\n  {NULL,        \"lucida\",                 \"lucida sans unicode\"},\n  {NULL,        \"lucidabright\",           \"lucida bright\"},\n  {NULL,        \"lucidatypewriter\",       \"lucida console\"},\n  {\"serif\",     \"times\",                  \"times new roman\"}\n};\n\nconst char* iupFontGetPangoName(const char* name)\n{\n  int i;\n  if (!name)\n    return NULL;\n  for (i=0; i<IFONT_NAME_MAP_SIZE; i++)\n  {\n    if (iupStrEqualNoCase(ifont_name_map[i].win, name))\n      return ifont_name_map[i].pango;\n    if (iupStrEqualNoCase(ifont_name_map[i].x, name))\n      return ifont_name_map[i].pango;\n  }\n\n  return NULL;\n}\n\nconst char* iupFontGetWinName(const char* name)\n{\n  int i;\n  if (!name)\n    return NULL;\n  for (i=0; i<IFONT_NAME_MAP_SIZE; i++)\n  {\n    if (iupStrEqualNoCase(ifont_name_map[i].pango, name))\n      return ifont_name_map[i].win;\n    if (iupStrEqualNoCase(ifont_name_map[i].x, name))\n      return ifont_name_map[i].win;\n  }\n\n  return NULL;\n}\n\nconst char* iupFontGetXName(const char* name)\n{\n  int i;\n  if (!name)\n    return NULL;\n  for (i=0; i<IFONT_NAME_MAP_SIZE; i++)\n  {\n    if (iupStrEqualNoCase(ifont_name_map[i].win, name))\n      return ifont_name_map[i].x;\n    if (iupStrEqualNoCase(ifont_name_map[i].pango, name))\n      return ifont_name_map[i].x;\n  }\n\n  return NULL;\n}\n\nchar *IupUnMapFont(const char *standardfont)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char *iup_typeface, *iup_style;\n\n  iupASSERT(standardfont!=NULL);\n  if (!standardfont)\n    return NULL;\n\n  if (!iupFontParsePango(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  if (strstr(typeface, \"Helvetica\"))\n    iup_typeface = \"HELVETICA_\";\n  else if (strstr(typeface, \"Courier\"))\n    iup_typeface = \"COURIER_\";\n  else if (strstr(typeface, \"Times\"))\n    iup_typeface = \"TIMES_\";\n  else\n    return NULL;\n\n  if (!is_bold && !is_italic)\n    iup_style = \"NORMAL_\";\n  else if (!is_bold && is_italic)\n    iup_style = \"ITALIC_\";\n  else if (is_bold && !is_italic)\n    iup_style = \"BOLD_\";\n  else\n    return NULL;\n\n  return iupStrReturnStrf(\"%s%s%d\", iup_typeface, iup_style, size);\n}\n\nstatic char* iFontGetStyle(const char* iupfont, int *size)\n{\n  char* style = NULL;\n\n  if (strstr(iupfont, \"NORMAL_\"))\n  {\n    style = \"\";\n    iupfont += strlen(\"NORMAL_\");\n  }\n  else if (strstr(iupfont, \"ITALIC_\"))\n  {\n    style = \"Italic\";\n    iupfont += strlen(\"ITALIC_\");\n  }\n  else if (strstr(iupfont, \"BOLD_\"))\n  {\n    style = \"Bold\";\n    iupfont += strlen(\"BOLD_\");\n  }\n  else \n    return NULL;\n\n  *size = atoi(iupfont);\n  return style;\n}\n\nchar *IupMapFont(const char *iupfont)\n{\n  int size = 0;\n  char *typeface, *style;\n\n  iupASSERT(iupfont!=NULL);\n  if (!iupfont)\n    return NULL;\n\n  if (strstr(iupfont, \"HELVETICA_\"))\n  {\n    typeface = \"Helvetica\";\n    style = iFontGetStyle(iupfont+strlen(\"HELVETICA_\"), &size);\n    if (!style || size==0)\n      return NULL;\n  }\n  else if (strstr(iupfont, \"COURIER_\"))\n  {\n    typeface = \"Courier\";\n    style = iFontGetStyle(iupfont+strlen(\"COURIER_\"), &size);\n    if (!style || size==0)\n      return NULL;\n  }\n  else if (strstr(iupfont, \"TIMES_\"))\n  {\n    typeface = \"Times\";\n    style = iFontGetStyle(iupfont+strlen(\"TIMES_\"), &size);\n    if (!style || size==0)\n      return NULL;\n  }\n  else \n    return NULL;\n\n  return iupStrReturnStrf(\"%s, %s %d\", typeface, style, size);\n}\n\nint iupSetFontAttrib(Ihandle* ih, const char* value)\n{\n  /* when set FONT can be an OLD IUP Font or a Native font */\n  const char* standardfont = IupMapFont(value);\n  if (!standardfont)\n    standardfont = value;\n\n  IupStoreAttribute(ih, \"STANDARDFONT\", standardfont);\n  return 0;\n}\n\nchar* iupGetFontAttrib(Ihandle* ih)\n{\n  return iupAttribGetStr(ih, \"STANDARDFONT\");\n}\n\nvoid iupUpdateStandardFontAttrib(Ihandle* ih)\n{\n  iupAttribSetClassObject(ih, \"STANDARDFONT\", iupGetFontAttrib(ih));\n}\n\nint iupGetFontInfo(const char* standardfont, char *typeface, int *size, int *is_bold, int *is_italic, int *is_underline, int *is_strikeout)\n{\n  if (size) *size = 0;\n  if (is_bold) *is_bold = 0;\n  if (is_italic) *is_italic = 0; \n  if (is_underline) *is_underline = 0;\n  if (is_strikeout) *is_strikeout = 0;\n  if (typeface) *typeface = 0;\n  \n  /* parse the old Windows format first */\n  if (!iupFontParseWin(standardfont, typeface, size, is_bold, is_italic, is_underline, is_strikeout))\n  {\n    if (!iupFontParseX(standardfont, typeface, size, is_bold, is_italic, is_underline, is_strikeout))\n    {\n      if (!iupFontParsePango(standardfont, typeface, size, is_bold, is_italic, is_underline, is_strikeout))\n        return 0;\n    }\n  }\n\n  return 1;\n}\n\nchar* iupGetFontFaceAttrib(Ihandle* ih)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont; \n  \n  standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnStr(typeface);\n}\n\nint iupSetFontFaceAttrib(Ihandle* ih, const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0,\n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont;\n\n  if (!value)\n    return 0;\n\n  standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return 0;\n\n  IupSetfAttribute(ih, \"STANDARDFONT\", \"%s, %s%s%s%s %d\", value, is_bold ? \"Bold \" : \"\", is_italic ? \"Italic \" : \"\", is_underline ? \"Underline \" : \"\", is_strikeout ? \"Strikeout \" : \"\", size);\n  return 0;\n}\n\nchar* iupGetFontSizeAttrib(Ihandle* ih)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont; \n  \n  standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnInt(size);\n}\n\nint iupSetFontSizeAttrib(Ihandle* ih, const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont; \n\n  if (!value)\n    return 0;\n  \n  standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return 0;\n\n  IupSetfAttribute(ih, \"STANDARDFONT\", \"%s, %s%s%s%s %s\", typeface, is_bold?\"Bold \":\"\", is_italic?\"Italic \":\"\", is_underline?\"Underline \":\"\", is_strikeout?\"Strikeout \":\"\", value);\n  return 0;\n}\n\nchar* iupGetDefaultFontFaceGlobalAttrib(void)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0,\n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n\n  char* standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnStr(typeface);\n}\n\nint iupSetDefaultFontFaceGlobalAttrib(const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0,\n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont;\n\n  if (!value)\n    return 0;\n\n  standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return 0;\n\n  IupSetfAttribute(NULL, \"DEFAULTFONT\", \"%s, %s%s%s%s %d\", value, is_bold ? \"Bold \" : \"\", is_italic ? \"Italic \" : \"\", is_underline ? \"Underline \" : \"\", is_strikeout ? \"Strikeout \" : \"\", size);\n\n  return 0;\n}\n\nchar* iupGetDefaultFontStyleGlobalAttrib(void)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0,\n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n\n  char* standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnStrf(\"%s%s%s%s\", is_bold ? \"Bold \" : \"\", is_italic ? \"Italic \" : \"\", is_underline ? \"Underline \" : \"\", is_strikeout ? \"Strikeout \" : \"\");\n}\n\nint iupSetDefaultFontStyleGlobalAttrib(const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0,\n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont;\n\n  if (!value)\n    return 0;\n\n  standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return 0;\n\n  IupSetfAttribute(NULL, \"DEFAULTFONT\", \"%s, %s %d\", typeface, value, size);\n\n  return 0;\n}\n\nvoid iupSetDefaultFontSizeGlobalAttrib(const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont; \n\n  if (!value)\n    return;\n  \n  standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return;\n\n  IupSetfAttribute(NULL, \"DEFAULTFONT\", \"%s, %s%s%s%s %s\", typeface, is_bold?\"Bold \":\"\", is_italic?\"Italic \":\"\", is_underline?\"Underline \":\"\", is_strikeout?\"Strikeout \":\"\", value);\n\n  return;\n}\n\nchar* iupGetDefaultFontSizeGlobalAttrib(void)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n\n  char* standardfont = IupGetGlobal(\"DEFAULTFONT\");\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnInt(size);\n}\n\nchar* iupGetFontStyleAttrib(Ihandle* ih)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return NULL;\n\n  return iupStrReturnStrf(\"%s%s%s%s\", is_bold?\"Bold \":\"\", is_italic?\"Italic \":\"\", is_underline?\"Underline \":\"\", is_strikeout?\"Strikeout \":\"\");\n}\n\nint iupSetFontStyleAttrib(Ihandle* ih, const char* value)\n{\n  int size = 0;\n  int is_bold = 0,\n    is_italic = 0, \n    is_underline = 0,\n    is_strikeout = 0;\n  char typeface[1024];\n  char* standardfont; \n\n  if (!value)\n    return 0;\n  \n  standardfont = iupGetFontAttrib(ih);\n\n  if (!iupGetFontInfo(standardfont, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))\n    return 0;\n\n  IupSetfAttribute(ih, \"STANDARDFONT\", \"%s, %s %d\", typeface, value, size);\n\n  return 0;\n}\n\n/**************************************************************/\n/* Native Font Format, compatible with Pango Font Description */\n/**************************************************************/\n\n/*\nThe string contains the font name, the style and the size. \nStyle can be a free combination of some names separated by spaces.\nFont name can be a list of font family names separated by comma.\n*/\n\nenum {                          /* style */\n FONT_PLAIN  = 0,\n FONT_BOLD   = 1,\n FONT_ITALIC = 2,\n FONT_UNDERLINE = 4,\n FONT_STRIKEOUT = 8\n};\n\n/* this code is shared between CD and IUP, must be updated on both libraries */\nstatic int iFontFindStyleName(const char *name, int len, int *style)\n{\n#define STYLE_NUM_NAMES 21\n  static struct { const char* name; int style; } style_names[STYLE_NUM_NAMES] = {\n    {\"Normal\",         0},\n    {\"Oblique\",        FONT_ITALIC},\n    {\"Italic\",         FONT_ITALIC},\n    {\"Small-Caps\",     0},\n    {\"Ultra-Light\",    0},\n    {\"Light\",          0},\n    {\"Medium\",         0},\n    {\"Semi-Bold\",      FONT_BOLD},\n    {\"Bold\",           FONT_BOLD},\n    {\"Ultra-Bold\",     FONT_BOLD},\n    {\"Heavy\",          0},\n    {\"Ultra-Condensed\",0},\n    {\"Extra-Condensed\",0},\n    {\"Condensed\",      0},\n    {\"Semi-Condensed\", 0},\n    {\"Semi-Expanded\",  0},\n    {\"Expanded\",       0},\n    {\"Extra-Expanded\", 0},\n    {\"Ultra-Expanded\", 0},\n    {\"Underline\", FONT_UNDERLINE},\n    {\"Strikeout\", FONT_STRIKEOUT}\n  };\n\n  int i;\n  for (i = 0; i < STYLE_NUM_NAMES; i++)\n  {\n    /* iupStrEqualPartial(style_names[i].name, name) */\n    if (strncmp(style_names[i].name, name, len)==0)\n    {\n      *style = style_names[i].style;\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n#define is_style_sep(_x) (_x == ' ' || _x == ',')\n\n/* this code is shared between CD and IUP, must be updated on both libraries */\nstatic const char * iFontGetStyleWord(const char *str, const char *last, int *wordlen)\n{\n  const char *result;\n  \n  while (last > str && is_style_sep(*(last - 1)))\n    last--;\n\n  result = last;\n  while (result > str && !is_style_sep(*(result - 1)))\n    result--;\n\n  *wordlen = (int)(last - result);\n  \n  return result;\n}\n\n/* this code is shared between CD and IUP, must be updated on both libraries */\nint iupFontParsePango(const char *standardfont, char *typeface, int *size, int *bold, int *italic, int *underline, int *strikeout)\n{\n  const char *p, *last;\n  int len, wordlen, style;\n\n  if (standardfont[0] == '-')  /* X font, abort */\n    return 0;\n\n  len = (int)strlen(standardfont);\n  last = standardfont + len;\n  p = iFontGetStyleWord(standardfont, last, &wordlen);\n\n  /* Look for a size at the end of the string */\n  if (wordlen != 0)\n  {\n    int new_size = atoi(p);\n    if (new_size != 0)\n    {\n      *size = new_size;\n      last = p;\n    }\n  }\n\n  /* Now parse style words */\n  style = 0;\n  p = iFontGetStyleWord(standardfont, last, &wordlen);\n  while (wordlen != 0)\n  {\n    int new_style = 0;\n\n    if (!iFontFindStyleName(p, wordlen, &new_style))\n      break;\n    else\n    {\n      style |= new_style;\n\n      last = p;\n      p = iFontGetStyleWord(standardfont, last, &wordlen);\n    }\n  }\n\n  *bold = 0;\n  *italic = 0;\n  *underline = 0;\n  *strikeout = 0;\n\n  if (style&FONT_BOLD)\n    *bold = 1;\n  if (style&FONT_ITALIC)\n    *italic = 1;\n  if (style&FONT_UNDERLINE)\n    *underline = 1;\n  if (style&FONT_STRIKEOUT)\n    *strikeout = 1;\n\n  /* Remainder is font family list. */\n\n  /* Trim off trailing separators */\n  while (last > standardfont && is_style_sep(*(last - 1)))\n    last--;\n\n  /* Trim off leading separators */\n  while (last > standardfont && is_style_sep(*standardfont))\n    standardfont++;\n\n  if (standardfont != last)\n  {\n    len = (int)(last - standardfont);\n    strncpy(typeface, standardfont, len);\n    typeface[len] = 0;\n    return 1;\n  }\n  else\n    return 0;\n}\n\n/* this code is shared between CD and IUP, must be updated on both libraries */\nint iupFontParseWin(const char *value, char *typeface, int *size, int *bold, int *italic, int *underline, int *strikeout)\n{\n  int c;\n\n  if (value[0] == '-')  /* X font, abort */\n    return 0;\n\n  if (strstr(value, \":\") == NULL)  /* check for the first separator */\n    return 0;\n\n  if (value[0] == ':')  /* check for NO typeface */\n    value++;       /* skip separator */\n  else\n  {\n    c = (int)strcspn(value, \":\");      /* extract typeface */\n    if (c == 0) return 0;\n    strncpy(typeface, value, c);\n    typeface[c] = '\\0';\n    value += c+1;  /* skip typeface and separator */\n  }\n\n  if (strstr(value, \":\") == NULL)  /* check for the second separator */\n    return 0;\n\n  /* init style to none */\n  *bold = 0;\n  *italic = 0;\n  *underline = 0;\n  *strikeout = 0;\n\n  if (value[0] == ':')  /* check for NO style list */\n    value++;       /* skip separator */\n  else\n  {\n    while (strlen(value)) /* extract style (bold/italic etc) */\n    {\n      char style[30];\n\n      c = (int)strcspn(value, \":,\");\n      if (c == 0)\n        break;\n\n      strncpy(style, value, c);\n      style[c] = '\\0';\n\n      if(iupStrEqual(style, \"BOLD\"))\n        *bold = 1; \n      else if(iupStrEqual(style,\"ITALIC\"))\n        *italic = 1; \n      else if(iupStrEqual(style,\"UNDERLINE\"))\n        *underline = 1; \n      else if(iupStrEqual(style,\"STRIKEOUT\"))\n        *strikeout = 1; \n\n      value += c; /* skip only the style */\n\n      if(value[0] == ':')  /* end of style list */\n      {\n        value++;\n        break;\n      }\n\n      value++;   /* skip separator */\n    }\n  }\n\n  /* extract size in points */\n  if (!iupStrToInt(value, size))\n    return 0;\n\n  if (size == 0)\n    return 0;\n\n  return 1;\n}\n\n/* this code is shared between CD and IUP, must be updated on both libraries */\nint iupFontParseX(const char *standardfont, char *typeface, int *size, int *bold, int *italic, int *underline, int *strikeout)\n{\n  char style1[30], style2[30];\n  char* token;\n  char font[1024];\n\n  if (standardfont[0] != '-')\n    return 0;\n\n  strcpy(font, standardfont+1);  /* skip first '-' */\n\n  *bold = 0;\n  *italic = 0;\n  *underline = 0;\n  *strikeout = 0;\n\n  /* fndry */\n  token = strtok(font, \"-\");\n  if (!token) return 0;\n\n  /* fmly */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  strcpy(typeface, token);\n\n  /* wght */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  strcpy(style1, token);\n  if (strstr(\"bold\", style1))\n    *bold = 1;\n\n  /* slant */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  strcpy(style2, token);\n  if (*style2 == 'i' || *style2 == 'o')\n    *italic = 1;\n\n  /* sWdth */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  /* adstyl */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n\n  /* pxlsz */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  *size = -atoi(token); /* size in pixels */\n\n  if (*size < 0)\n    return 1;\n\n  /* ptSz */\n  token = strtok(NULL, \"-\");\n  if (!token) return 0;\n  *size = atoi(token)/10; /* size in deci-points */\n\n  if (*size > 0)\n    return 1;\n\n  return 0;\n}\n","/** \\file\n * \\brief IupFontDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n\n\nIhandle* IupFontDlg(void)\n{\n  return IupCreate(\"fontdlg\");\n}\n\nIclass* iupFontDlgNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"dialog\"));\n\n  ic->name = \"fontdlg\";\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->is_interactive = 1;\n\n  ic->New = iupFontDlgNewClass;\n\n  if (!iupStrEqualNoCase(IupGetGlobal(\"DRIVER\"), \"Motif\"))\n  {\n    /* reset not used native dialog methods */\n    ic->parent->LayoutUpdate = NULL;\n    ic->parent->SetChildrenPosition = NULL;\n    ic->parent->Map = NULL;\n    ic->parent->UnMap = NULL;\n  }\n\n  /* IupFontDialog only */\n  iupClassRegisterAttribute(ic, \"STATUS\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);\n  iupClassRegisterAttribute(ic, \"VALUE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupdrvFontDlgInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief Frame Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_frame.h\"\n\n\nint iupFrameGetTitleHeight(Ihandle* ih)\n{\n  int charheight;\n  iupdrvFontGetCharSize(ih, NULL, &charheight);\n  return charheight;\n}\n\nstatic void iFrameGetDecorSize(Ihandle* ih, int *width, int *height)\n{\n  *width  = 5;\n  *height = 5;\n\n  if (iupAttribGet(ih, \"_IUPFRAME_HAS_TITLE\") || iupAttribGet(ih, \"TITLE\"))\n    (*height) += iupFrameGetTitleHeight(ih);\n}\n\nchar* iupFrameGetBgColorAttrib(Ihandle* ih)\n{\n  if (iupAttribGet(ih, \"_IUPFRAME_HAS_BGCOLOR\"))\n    return NULL;  /* get from the hash table */\n  else\n    return iupBaseNativeParentGetBgColorAttrib(ih);\n}\n\nstatic char* iFrameGetClientSizeAttrib(Ihandle* ih)\n{\n  int width, height, decorwidth, decorheight;\n  width = ih->currentwidth;\n  height = ih->currentheight;\n  iFrameGetDecorSize(ih, &decorwidth, &decorheight);\n  width -= decorwidth;\n  height -= decorheight;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic char* iFrameGetClientOffsetAttrib(Ihandle* ih)\n{\n  int dx = 0, dy = 0;\n\n  /* In Windows the position of the child is still\n  relative to the top-left corner of the frame.\n  So we must manually add the decorations. */\n  if (!iupdrvFrameHasClientOffset())\n  {\n    iupdrvFrameGetDecorOffset(&dx, &dy);\n\n    if (iupAttribGet(ih, \"_IUPFRAME_HAS_TITLE\") || iupAttribGet(ih, \"TITLE\"))\n      dy += iupFrameGetTitleHeight(ih);\n  }\n\n  return iupStrReturnIntInt(dx, dy, 'x');\n}\n\nstatic int iFrameCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iFrameComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int decorwidth, decorheight;\n  Ihandle* child = ih->firstchild;\n\n  iFrameGetDecorSize(ih, &decorwidth, &decorheight);\n  *w = decorwidth;\n  *h = decorheight;\n\n  if (child)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    *children_expand = child->expand;\n    *w += child->naturalwidth;\n    *h += child->naturalheight;\n  }\n}\n\nstatic void iFrameSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  int width, height, decorwidth, decorheight;\n\n  iFrameGetDecorSize(ih, &decorwidth, &decorheight);\n\n  width = ih->currentwidth-decorwidth;\n  height = ih->currentheight-decorheight;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n\n  if (ih->firstchild)\n    iupBaseSetCurrentSize(ih->firstchild, width, height, shrink);\n}\n\nstatic void iFrameSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild)\n  {\n    char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n    /* Native container, position is reset */\n    x = 0;\n    y = 0;\n\n    if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n    /* In Windows the position of the child is still\n    relative to the top-left corner of the frame.\n    So we must manually add the decorations. */\n    if (iupdrvFrameHasClientOffset())\n    {\n      int dx = 0, dy = 0;\n      iupdrvFrameGetDecorOffset(&dx, &dy);\n\n      if (iupAttribGet(ih, \"_IUPFRAME_HAS_TITLE\") || iupAttribGet(ih, \"TITLE\"))\n        dy += iupFrameGetTitleHeight(ih);\n\n      x += dx;\n      y += dy;\n    }\n\n    /* Child coordinates are relative to client left-top corner. */\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupFrame(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"frame\", children);\n}\n\nIclass* iupFrameNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"frame\";\n  ic->format = \"h\"; /* one Ihandle* */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDMANY+1;   /* one child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupFrameNewClass;\n  ic->Create = iFrameCreateMethod;\n\n  ic->ComputeNaturalSize = iFrameComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iFrameSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iFrameSetChildrenPositionMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iFrameGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iFrameGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Native Container */\n  iupClassRegisterAttribute(ic, \"CHILDOFFSET\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  /* IupFrame only */\n  iupClassRegisterAttribute(ic, \"SUNKEN\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupdrvFrameInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief function table manager\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h> \n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_table.h\"\n#include \"iup_func.h\"\n#include \"iup_drv.h\"\n#include \"iup_assert.h\"\n\n\nstatic Itable *ifunc_table = NULL;   /* the function hash table indexed by the name string */\nstatic const char *ifunc_action_name = NULL;  /* name of the action being retrieved in IupGetFunction */\n\nvoid iupFuncInit(void)\n{\n  ifunc_table = iupTableCreate(IUPTABLE_STRINGINDEXED);\n}\n\nvoid iupFuncFinish(void)\n{\n  iupTableDestroy(ifunc_table);\n  ifunc_table = NULL;\n}\n\nconst char *IupGetActionName(void)\n{\n  return ifunc_action_name;\n}\n\nIcallback IupGetFunction(const char *name)\n{\n  void* value;\n  Icallback func;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  ifunc_action_name = name; /* store the retrieved name */\n\n  func = (Icallback)iupTableGetFunc(ifunc_table, name, &value);\n\n  /* if not defined and not the idle, then check for the DEFAULT_ACTION */\n  if (!func && !iupStrEqual(name, \"IDLE_ACTION\"))\n    func = (Icallback)iupTableGetFunc(ifunc_table, \"DEFAULT_ACTION\", &value);\n\n  return func;\n}\n\nIcallback IupSetFunction(const char *name, Icallback func)\n{\n  void* value;\n  Icallback old_func;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  old_func = (Icallback)iupTableGetFunc(ifunc_table, name, &value);\n\n  if (!func)\n    iupTableRemove(ifunc_table, name);\n  else\n    iupTableSetFunc(ifunc_table, name, (Ifunc)func);\n\n  /* notifies the driver if changing the Idle */\n  if (iupStrEqual(name, \"IDLE_ACTION\"))\n    iupdrvSetIdleFunction(func);\n\n  return old_func;\n}\n","/** \\file\n * \\brief global attributes enviroment\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>      \n#include <stdio.h>      \n#include <string.h>      \n\n#include \"iup.h\" \n\n#include \"iup_table.h\"\n#include \"iup_globalattrib.h\"\n#include \"iup_table.h\"\n#include \"iup_class.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_assert.h\"\n#include \"iup_str.h\"\n#include \"iup_strmessage.h\"\n\n\nstatic Itable *iglobal_table = NULL;\n\nvoid iupGlobalAttribInit(void)\n{\n  iglobal_table = iupTableCreate(IUPTABLE_STRINGINDEXED);\n}\n\nvoid iupGlobalAttribFinish(void)\n{\n  iupTableDestroy(iglobal_table);\n  iglobal_table = NULL;\n}\n\nstatic int iGlobalChangingDefaultColor(const char *name)\n{\n  if (iupClassIsGlobalDefault(name, 1))\n  {\n    char str[50] = \"_IUP_USER_DEFAULT_\";\n    strcat(str, name);\n    iupTableSet(iglobal_table, str, (void*)\"1\", IUPTABLE_POINTER);  /* mark as changed by the User */\n    return 1;\n  }\n  return 0;\n}\n\nint iupGlobalDefaultColorChanged(const char *name)\n{\n  char str[50] = \"_IUP_USER_DEFAULT_\";\n  strcat(str, name);\n  return iupTableGet(iglobal_table, str) != NULL;\n}\n\nvoid iupGlobalSetDefaultColorAttrib(const char* name, int r, int g, int b)\n{\n  if (!iupGlobalDefaultColorChanged(name))\n  {\n    char value[50];\n    sprintf(value, \"%d %d %d\", r, g, b);\n    iupTableSet(iglobal_table, name, (void*)value, IUPTABLE_STRING);\n  }\n}\n\nstatic void iGlobalTableSet(const char *name, const char *value, int store)\n{\n  if (!value)\n    iupTableRemove(iglobal_table, name);\n  else if (store)\n    iupTableSet(iglobal_table, name, (void*)value, IUPTABLE_STRING);\n  else\n    iupTableSet(iglobal_table, name, (void*)value, IUPTABLE_POINTER);\n}\n\nstatic void iGlobalSet(const char *name, const char *value, int store)\n{\n  iupASSERT(name!=NULL);\n  if (!name) return;\n\n  if (iupStrEqual(name, \"DEFAULTFONTSIZE\"))\n  {\n    iupSetDefaultFontSizeGlobalAttrib(value);\n    return;\n  }\n  if (iupStrEqual(name, \"DEFAULTFONTSTYLE\"))\n  {\n    iupSetDefaultFontStyleGlobalAttrib(value);\n    return;\n  }\n  if (iupStrEqual(name, \"DEFAULTFONTFACE\"))\n  {\n    iupSetDefaultFontFaceGlobalAttrib(value);\n    return;\n  }\n  if (iupStrEqual(name, \"KEYPRESS\"))\n  {\n    int key;\n    if (iupStrToInt(value, &key))\n      iupdrvSendKey(key, 0x01);\n    return;\n  }\n  if (iupStrEqual(name, \"KEYRELEASE\"))\n  {\n    int key;\n    if (iupStrToInt(value, &key))\n      iupdrvSendKey(key, 0x02);\n    return;\n  }\n  if (iupStrEqual(name, \"KEY\"))\n  {\n    int key;\n    if (iupStrToInt(value, &key))\n      iupdrvSendKey(key, 0x03);\n    return;\n  }\n  if (iupStrEqual(name, \"LANGUAGE\"))\n  {\n    iupStrMessageUpdateLanguage(value);\n    iGlobalTableSet(name, value, store);\n    return;\n  }\n  if (iupStrEqual(name, \"CURSORPOS\"))\n  {\n    int x, y;\n    if (iupStrToIntInt(value, &x, &y, 'x') == 2)\n      iupdrvWarpPointer(x, y);\n    return;\n  }\n  if (iupStrEqual(name, \"MOUSEBUTTON\"))\n  {\n    int x, y, status;\n    char bt; \n    if (sscanf(value, \"%dx%d %c %d\", &x, &y, &bt, &status) == 4)\n      iupdrvSendMouse(x, y, bt, status);\n    return;\n  }\n\n  if (iGlobalChangingDefaultColor(name) || \n      iupdrvSetGlobal(name, value))\n    iGlobalTableSet(name, value, store);\n}\n\nvoid IupSetGlobal(const char *name, const char *value)\n{\n  iGlobalSet(name, value, 0);\n}\n\nvoid IupStoreGlobal(const char *name, const char *value)\n{\n  iGlobalSet(name, value, 1);\n}\n\nvoid IupSetStrGlobal(const char *name, const char *value)\n{\n  iGlobalSet(name, value, 1);\n}\n\nchar* IupGetGlobal(const char *name)\n{\n  char* value;\n  \n  iupASSERT(name!=NULL);\n  if (!name) \n    return NULL;\n\n  if (iupStrEqual(name, \"DEFAULTFONTSIZE\"))\n    return iupGetDefaultFontSizeGlobalAttrib();\n  if (iupStrEqual(name, \"DEFAULTFONTSTYLE\"))\n    return iupGetDefaultFontStyleGlobalAttrib();\n  if (iupStrEqual(name, \"DEFAULTFONTFACE\"))\n    return iupGetDefaultFontFaceGlobalAttrib();\n  if (iupStrEqual(name, \"CURSORPOS\"))\n  {\n    int x, y;\n    iupdrvGetCursorPos(&x, &y);\n    return iupStrReturnIntInt(x, y, 'x');\n  }\n  if (iupStrEqual(name, \"SHIFTKEY\"))\n  {\n    char key[5];\n    iupdrvGetKeyState(key);\n    return iupStrReturnChecked(key[0] == 'S');\n  }\n  if (iupStrEqual(name, \"CONTROLKEY\"))\n  {\n    char key[5];\n    iupdrvGetKeyState(key);\n    return iupStrReturnChecked(key[1] == 'C');\n  }\n  if (iupStrEqual(name, \"MODKEYSTATE\"))\n  {\n    char *str = iupStrGetMemory(5);\n    iupdrvGetKeyState(str);\n    return str;\n  }\n  if (iupStrEqual(name, \"SCREENSIZE\"))\n  {\n    int w, h;\n    iupdrvGetScreenSize(&w, &h);\n    return iupStrReturnIntInt(w, h, 'x');\n  }\n  if (iupStrEqual(name, \"FULLSIZE\"))\n  {\n    int w, h;\n    iupdrvGetFullSize(&w, &h);\n    return iupStrReturnIntInt(w, h, 'x');\n  }\n  if (iupStrEqual(name, \"SCREENDEPTH\"))\n  {\n    int bpp = iupdrvGetScreenDepth();\n    return iupStrReturnInt(bpp);\n  }\n  if (iupStrEqual(name, \"SCREENDPI\"))\n  {\n    float dpi = iupdrvGetScreenDpi();\n    return iupStrReturnFloat(dpi);\n  }\n  if (iupStrEqual(name, \"SYSTEMLOCALE\"))\n    return iupdrvLocaleInfo();\n  if (iupStrEqual(name, \"SCROLLBARSIZE\"))\n    return iupStrReturnInt(iupdrvGetScrollbarSize());\n\n  value = iupdrvGetGlobal(name);\n\n  if (!value)\n    value = (char*)iupTableGet(iglobal_table, name);\n\n  return value;\n}\n\nint iupGlobalIsPointer(const char* name)\n{\n  static struct {\n    const char *name;\n  } ptr_table[] = {\n#ifndef GTK_MAC\n  #ifdef WIN32\n    {\"HINSTANCE\"},\n  #else\n    {\"XDISPLAY\"},\n    {\"XSCREEN\"},\n    {\"APPSHELL\"},\n  #endif\n#endif\n  };\n#define PTR_TABLE_SIZE ((sizeof ptr_table)/(sizeof ptr_table[0]))\n\n  if (name)\n  {\n    int i;\n    for (i = 0; i < PTR_TABLE_SIZE; i++)\n    {\n      if (iupStrEqualNoCase(name, ptr_table[i].name))\n        return 1;\n    }\n  }\n\n  return 0;\n}\n","/** \\file\n * \\brief GridBox Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_normalizer.h\"\n\n\n/* Orientation */\nenum {IGBOX_HORIZONTAL, IGBOX_VERTICAL};\n\nstruct _IcontrolData \n{\n  int alignment_lin, alignment_col,\n      expand_children,\n      is_homogeneous_lin, is_homogeneous_col,\n      normalize_size,\n      margin_x, margin_y,\n      size_lin, size_col,\n      gap_lin, gap_col,\n      orientation, num_div, num_lin, num_col,\n      total_natural_width, total_natural_height,   /* calculated in ComputeNaturalSize, used in SetChildrenCurrentSize */\n      homogeneous_width, homogeneous_height;       /* calculated in SetChildrenCurrentSize, used in SetChildrenPosition */\n};\n\n\nstatic void iGridBoxCalcLinCol(Ihandle* ih, int i, int *lin, int *col)\n{\n  if (ih->data->orientation == IGBOX_HORIZONTAL)\n  {\n    *lin = i / ih->data->num_col;\n    *col = i % ih->data->num_col;\n  }\n  else\n  {\n    *col = i / ih->data->num_lin;\n    *lin = i % ih->data->num_lin;\n  }\n}\n\n\n/**********************************************************************************************/\n\n\nstatic char* iGridBoxGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  width -= 2 * ih->data->margin_x;\n  height -= 2*ih->data->margin_y;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iGridBoxSetCGapColAttrib(Ihandle* ih, const char* value)\n{\n  int cgap, charheight;\n  iupStrToInt(value, &cgap);\n  iupdrvFontGetCharSize(ih, NULL, &charheight);\n  ih->data->gap_col = iupHEIGHT2RASTER(cgap, charheight);\n  return 0;\n}\n\nstatic int iGridBoxSetCGapLinAttrib(Ihandle* ih, const char* value)\n{\n  int cgap, charwidth;\n  iupStrToInt(value, &cgap);\n  iupdrvFontGetCharSize(ih, &charwidth, NULL);\n  ih->data->gap_lin = iupWIDTH2RASTER(cgap, charwidth);\n  return 0;\n}\n\nstatic char* iGridBoxGetCGapLinAttrib(Ihandle* ih)\n{\n  int charwidth;\n  iupdrvFontGetCharSize(ih, &charwidth, NULL);\n  return iupStrReturnInt(iupRASTER2WIDTH(ih->data->gap_lin, charwidth));\n}\n\nstatic char* iGridBoxGetCGapColAttrib(Ihandle* ih)\n{\n  int charheight;\n  iupdrvFontGetCharSize(ih, NULL, &charheight);\n  return iupStrReturnInt(iupRASTER2HEIGHT(ih->data->gap_col, charheight));\n}\n\nstatic int iGridBoxSetGapLinAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->gap_lin);\n  return 0;\n}\n\nstatic char* iGridBoxGetGapLinAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->gap_lin);\n}\n\nstatic int iGridBoxSetGapColAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->gap_col);\n  return 0;\n}\n\nstatic char* iGridBoxGetGapColAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->gap_col);\n}\n\nstatic int iGridBoxSetSizeLinAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->size_lin);\n  return 0;\n}\n\nstatic char* iGridBoxGetSizeLinAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->size_lin);\n}\n\nstatic int iGridBoxSetSizeColAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToInt(value, &ih->data->size_col);\n  return 0;\n}\n\nstatic char* iGridBoxGetSizeColAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->size_col);\n}\n\nstatic char* iGridBoxGetHomogeneousLinAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_homogeneous_lin); \n}\n\nstatic int iGridBoxSetHomogeneousLinAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->is_homogeneous_lin = 1;\n  else\n    ih->data->is_homogeneous_lin = 0;\n  return 0;\n}\n\nstatic char* iGridBoxGetHomogeneousColAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_homogeneous_col); \n}\n\nstatic int iGridBoxSetHomogeneousColAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->is_homogeneous_col = 1;\n  else\n    ih->data->is_homogeneous_col = 0;\n  return 0;\n}\n\nstatic int iGridBoxSetExpandChildrenAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"YES\"))\n    ih->data->expand_children = IUP_EXPAND_BOTH;\n  else if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->data->expand_children = IUP_EXPAND_WIDTH;\n  else if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    ih->data->expand_children = IUP_EXPAND_HEIGHT;\n  else\n    ih->data->expand_children = IUP_EXPAND_NONE;\n  return 0;\n}\n\nstatic char* iGridBoxGetExpandChildrenAttrib(Ihandle* ih)\n{\n  if ((ih->data->expand_children & IUP_EXPAND_WIDTH) && (ih->data->expand_children & IUP_EXPAND_HEIGHT))\n    return \"YES\";\n  else if (ih->data->expand_children & IUP_EXPAND_WIDTH)\n    return \"HORIZONTAL\";\n  else if (ih->data->expand_children & IUP_EXPAND_HEIGHT)\n    return \"VERTICAL\";\n  else\n    return \"NO\";\n}\n\nstatic int iGridBoxSetNormalizeSizeAttrib(Ihandle* ih, const char* value)\n{\n  ih->data->normalize_size = iupNormalizeGetNormalizeSize(value);\n  return 0;\n}\n\nstatic char* iGridBoxGetNormalizeSizeAttrib(Ihandle* ih)\n{\n  return iupNormalizeGetNormalizeSizeStr(ih->data->normalize_size);\n}\n\nstatic void iGridBoxFitColChildren(Ihandle* ih, int fit_col)\n{\n  /* find the largest cel in the col */\n  int max_width = 0, max, i;\n  Ihandle* child, *ref_child = NULL;\n\n  if (ih->data->num_col == 0 || ih->data->num_lin == 0)\n    return;\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      if (col == fit_col)\n      {\n        if (child->naturalwidth > max_width)\n          max_width = child->naturalwidth;\n\n        if (lin == ih->data->size_lin)\n          ref_child = child;\n      }\n\n      i++;\n    }\n  }\n\n  max = iupAttribGetIntId(ih, \"FITMAXWIDTH\", fit_col);\n  if (max && max > max_width)\n    max_width = max;\n\n  if (ref_child)\n    ref_child->userwidth = max_width;\n}\n\nstatic void iGridBoxFitLineChildren(Ihandle* ih, int fit_lin)\n{\n  /* find the highest cel in the line */\n  int max_height = 0, max, i;\n  Ihandle* child, *ref_child = NULL;\n\n  if (ih->data->num_col == 0 || ih->data->num_lin == 0)\n    return;\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      if (lin == fit_lin)\n      {\n        if (child->naturalheight > max_height)\n          max_height = child->naturalheight;\n\n        if (col == ih->data->size_col)\n          ref_child = child;\n      }\n\n      i++;\n    }\n  }\n\n  max = iupAttribGetIntId(ih, \"FITMAXHEIGHT\", fit_lin);\n  if (max && max > max_height)\n    max_height = max;\n\n  if (ref_child)\n    ref_child->userheight = max_height;\n}\n\nstatic int iGridBoxSetFitToChildrenAttrib(Ihandle* ih, const char* value)\n{\n  if (!value || value[0] == 0)\n    return 0;\n\n  if (value[0] == 'C')\n  {\n    int col;\n    if (iupStrToInt(value + 1, &col))\n    {\n      iGridBoxFitColChildren(ih, col);\n      IupRefreshChildren(ih);\n    }\n  }\n  else if (value[0] == 'L')\n  {\n    int line;\n    if (iupStrToInt(value + 1, &line))\n    {\n      iGridBoxFitLineChildren(ih, line);\n      IupRefreshChildren(ih);\n    }\n  }\n\n  return 0;\n}\n\nstatic int iGridBoxSetCMarginAttrib(Ihandle* ih, const char* value)\n{\n  int cmargin_x=-1, cmargin_y=-1;\n  int charwidth, charheight;\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  iupStrToIntInt(value, &cmargin_x, &cmargin_y, 'x');\n  if (cmargin_x!=-1)\n    ih->data->margin_x = iupWIDTH2RASTER(cmargin_x, charwidth);\n  if (cmargin_y!=-1)\n    ih->data->margin_y = iupHEIGHT2RASTER(cmargin_y, charheight);\n  return 1;\n}\n\nstatic char* iGridBoxGetCMarginAttrib(Ihandle* ih)\n{\n  int charwidth, charheight;\n  iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n  return iupStrReturnIntInt(iupRASTER2WIDTH(ih->data->margin_x, charwidth), iupRASTER2HEIGHT(ih->data->margin_y, charheight), 'x');\n}\n\nstatic int iGridBoxSetMarginAttrib(Ihandle* ih, const char* value)\n{\n  iupStrToIntInt(value, &ih->data->margin_x, &ih->data->margin_y, 'x');\n  return 0;\n}\n\nstatic char* iGridBoxGetMarginAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->margin_x, ih->data->margin_y, 'x');\n}\n\nstatic int iGridBoxSetOrientationAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    ih->data->orientation = IGBOX_VERTICAL;\n  else if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->data->orientation = IGBOX_HORIZONTAL;\n  return 0;\n}\n\nstatic char* iGridBoxGetOrientationAttrib(Ihandle* ih)\n{\n  if (ih->data->orientation==IGBOX_HORIZONTAL)\n    return \"HORIZONTAL\";\n  else\n    return \"VERTICAL\";\n}\n\nstatic int iGridBoxSetNumDivAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"AUTO\"))\n    ih->data->num_div = -1;\n  else\n  {\n    iupStrToInt(value, &ih->data->num_div);\n    if (ih->data->num_div <= 0)\n      ih->data->num_div = 1;\n  }\n  return 0;\n}\n\nstatic char* iGridBoxGetNumDivAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->num_div);\n}\n\nstatic char* iGridBoxGetNumColAttrib(Ihandle* ih)\n{\n  if (!ih->handle)\n    iupBaseComputeNaturalSize(ih);\n\n  return iupStrReturnInt(ih->data->num_col);\n}\n\nstatic char* iGridBoxGetNumLinAttrib(Ihandle* ih)\n{\n  if (!ih->handle)\n    iupBaseComputeNaturalSize(ih);\n\n  return iupStrReturnInt(ih->data->num_lin);\n}\n\nstatic int iGridBoxGetAlignmentLin(Ihandle* ih, int lin)\n{\n  int alignment_lin = ih->data->alignment_lin;\n  char *value;\n  value = iupAttribGetId(ih, \"ALIGNMENTLIN\", lin);\n  if (value)\n  {\n    if (iupStrEqualNoCase(value, \"ABOTTOM\"))\n      alignment_lin = IUP_ALIGN_ABOTTOM;\n    else if (iupStrEqualNoCase(value, \"ACENTER\"))\n      alignment_lin = IUP_ALIGN_ACENTER;\n    else\n      alignment_lin = IUP_ALIGN_ATOP;\n  }\n  return alignment_lin;\n}\n\nstatic int iGridBoxGetAlignmentCol(Ihandle* ih, int col)\n{\n  int alignment_col = ih->data->alignment_col;\n  char *value;\n  value = iupAttribGetId(ih, \"ALIGNMENTCOL\", col);\n  if (value)\n  {\n    if (iupStrEqualNoCase(value, \"ARIGHT\"))\n      alignment_col = IUP_ALIGN_ARIGHT;\n    else if (iupStrEqualNoCase(value, \"ACENTER\"))\n      alignment_col = IUP_ALIGN_ACENTER;\n    else if (iupStrEqualNoCase(value, \"ALEFT\"))\n      alignment_col = IUP_ALIGN_ALEFT;\n  }\n  return alignment_col;\n}\n\nstatic int iGridBoxSetAlignmentLinAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"ABOTTOM\"))\n    ih->data->alignment_lin = IUP_ALIGN_ABOTTOM;\n  else if (iupStrEqualNoCase(value, \"ACENTER\"))\n    ih->data->alignment_lin = IUP_ALIGN_ACENTER;\n  else if (iupStrEqualNoCase(value, \"ATOP\"))\n    ih->data->alignment_lin = IUP_ALIGN_ATOP;\n return 0;\n}\n\nstatic char* iGridBoxGetAlignmentLinAttrib(Ihandle* ih)\n{\n  static char* align2str[3] = {\"ATOP\", \"ACENTER\", \"ABOTTOM\"};\n  return align2str[ih->data->alignment_lin];\n}\n\nstatic int iGridBoxSetAlignmentColAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"ARIGHT\"))\n    ih->data->alignment_col = IUP_ALIGN_ARIGHT;\n  else if (iupStrEqualNoCase(value, \"ACENTER\"))\n    ih->data->alignment_col = IUP_ALIGN_ACENTER;\n  else if (iupStrEqualNoCase(value, \"ALEFT\"))\n    ih->data->alignment_col = IUP_ALIGN_ALEFT;\n  return 0;\n}\n\nstatic char* iGridBoxGetAlignmentColAttrib(Ihandle* ih)\n{\n  char* align2str[3] = {\"ALEFT\", \"ACENTER\", \"ARIGHT\"};\n  return iupStrReturnStr(align2str[ih->data->alignment_col]);\n}\n\nstatic int iGridBoxUpdateAttribFromFont(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"CMARGIN\");\n  if (!value)\n    value = iupAttribGet(ih, \"NCMARGIN\");\n  if (value)\n    iGridBoxSetCMarginAttrib(ih, value);\n\n  value = iupAttribGet(ih, \"CGAPLIN\");\n  if (!value)\n    value = iupAttribGet(ih, \"NCGAPLIN\");\n  if (value)\n    iGridBoxSetCGapLinAttrib(ih, value);\n\n  value = iupAttribGet(ih, \"CGAPCOL\");\n  if (!value)\n    value = iupAttribGet(ih, \"NCGAPCOL\");\n  if (value)\n    iGridBoxSetCGapColAttrib(ih, value);\n\n  return IUP_DEFAULT;\n}\n\n\n/**********************************************************************************/\n\n\nstatic int iGridBoxCalcNumDiv(Ihandle* ih)\n{\n  int num_div;\n  Ihandle* child;\n\n  if (ih->data->orientation==IGBOX_HORIZONTAL)\n  {\n    int children_w = 0;\n\n    num_div = 1;\n    for (child = ih->firstchild; child; child = child->brother)\n    {\n      if (!(child->flags & IUP_FLOATING))\n      {\n        children_w += child->naturalwidth;\n        if (children_w > ih->naturalwidth)\n          break;\n\n        num_div++;\n      }\n    }\n  }\n  else\n  {\n    int children_h = 0;\n\n    num_div = 1;\n    for (child = ih->firstchild; child; child = child->brother)\n    {\n      if (!(child->flags & IUP_FLOATING))\n      {\n        children_h += child->naturalheight;\n        if (children_h > ih->naturalheight)\n          break;\n\n        num_div++;\n      }\n    }\n  }\n\n  return num_div;\n}\n\nstatic void iGridBoxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int num_lin, num_col, num_div, i;\n  int children_natural_width = 0, children_natural_height = 0;\n\n  /* calculate total children natural size */\n  int children_natural_maxwidth = 0;\n  int children_natural_maxheight = 0;\n  int child_count = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (ih->data->expand_children)\n      child->expand = ih->data->expand_children;\n\n    /* update child natural size first */\n    if (!(child->flags & IUP_FLOATING_IGNORE))\n      iupBaseComputeNaturalSize(child);\n\n    if (!(child->flags & IUP_FLOATING))\n    {\n      *children_expand |= child->expand;\n      child_count++;\n    }\n  }\n\n  if (ih->data->num_div == -1)\n    num_div = iGridBoxCalcNumDiv(ih);\n  else\n    num_div = ih->data->num_div;\n\n  /* Notice that num_lin*num_col can be > child_count */\n  if (ih->data->orientation==IGBOX_HORIZONTAL)\n  {\n    num_lin = child_count / num_div;\n    if (child_count % num_div)\n      num_lin++;\n    num_col = num_div;\n  }\n  else\n  {\n    num_lin = num_div;\n    num_col = child_count / num_div;\n    if (child_count % num_div)\n      num_col++;\n  }\n\n  /* read only, computed only here */\n  ih->data->num_lin = num_lin;\n  ih->data->num_col = num_col;\n\n  /* IMPORTANT: the reference line defines the width of each column,\n     and the reference column defines the height of each line */\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      if (col == ih->data->size_col)\n      {\n        children_natural_height += child->naturalheight;\n        children_natural_maxheight = iupMAX(children_natural_maxheight, child->naturalheight);\n      }\n      if (lin == ih->data->size_lin)\n      {\n        children_natural_width += child->naturalwidth;\n        children_natural_maxwidth = iupMAX(children_natural_maxwidth, child->naturalwidth);\n      }\n\n      i++;\n    }\n  }\n\n  /* reset to max natural width and/or height if NORMALIZESIZE is defined */\n  if (ih->data->normalize_size)  /* this directly affects the child natural size */\n  {\n    iupNormalizeSizeBoxChild(ih, ih->data->normalize_size, children_natural_maxwidth, children_natural_maxheight);\n\n    /* must update the children natural size because\n       normalize was done after its calculation */\n    if (ih->data->normalize_size & 1) \n      children_natural_width = children_natural_maxwidth*num_col;\n    if (ih->data->normalize_size & 2)\n      children_natural_height = children_natural_maxheight*num_lin;\n  }\n\n  /* leave room at the element for the maximum natural size of the children when is_homogeneous */\n  /* this affects only the space left for the child to expand */\n  if (ih->data->is_homogeneous_col)  /* all columns with the same width */\n    children_natural_width = children_natural_maxwidth*num_col;\n  if (ih->data->is_homogeneous_lin)  /* all lines with the same height */\n    children_natural_height = children_natural_maxheight*num_lin;\n\n  /* compute the GridBox contents natural size */\n  *w = children_natural_width  + (num_col-1)*ih->data->gap_col + 2*ih->data->margin_x;\n  *h = children_natural_height + (num_lin-1)*ih->data->gap_lin + 2*ih->data->margin_y;\n\n  /* Store to be used in iGridCalcEmptyHeight */\n  ih->data->total_natural_width  = *w;\n  ih->data->total_natural_height = *h;\n}\n\nstatic int iGridBoxCalcHomogeneousWidth(Ihandle *ih)\n{\n  /* all columns with the same width */\n  int homogeneous_width = (ih->currentwidth - (ih->data->num_col-1)*ih->data->gap_col - 2*ih->data->margin_x)/ih->data->num_col;\n  if (homogeneous_width<0) homogeneous_width = 0;\n  return homogeneous_width;\n}\n\nstatic int iGridBoxCalcHomogeneousHeight(Ihandle *ih)\n{\n  /* all lines with the same height */\n  int homogeneous_height = (ih->currentheight - (ih->data->num_lin-1)*ih->data->gap_lin - 2*ih->data->margin_y)/ih->data->num_lin;\n  if (homogeneous_height < 0) homogeneous_height = 0;\n  return homogeneous_height;\n}\n\nstatic int iGridBoxCalcEmptyWidth(Ihandle *ih, int expand)\n{\n  /* This is the space that the child can be expanded. */\n  Ihandle* child;\n  int empty_width;\n\n  int expand_count=0, i=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      /* only for the reference line,\n         the reference line defines the width of each column */\n      if (lin==ih->data->size_lin &&\n          child->expand & expand)\n        expand_count++;\n\n      i++;\n    }\n  }\n  if (expand_count == 0)\n    return 0;\n\n  /* equal spaces for all expandable elements */\n  empty_width = (ih->currentwidth - ih->data->total_natural_width)/expand_count;\n  if (empty_width < 0) empty_width = 0;\n  return empty_width;\n}\n\nstatic int iGridBoxCalcEmptyHeight(Ihandle *ih, int expand)\n{\n  /* This is the space that the child can be expanded. */\n  Ihandle* child;\n  int empty_height;\n\n  int expand_count=0, i=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      /* only for the reference column,\n         the reference column defines the height of each line */\n      if (col==ih->data->size_col &&\n         child->expand & expand)\n        expand_count++;\n\n      i++;\n    }\n  }\n  if (expand_count == 0)\n    return 0;\n\n  /* equal spaces for all expandable elements */\n  empty_height = (ih->currentheight - ih->data->total_natural_height)/expand_count;  \n  if (empty_height < 0) empty_height = 0;\n  return empty_height;\n}\n\nstatic void iGridBoxCalcColWidth(Ihandle* ih, int *col_width, int empty_w0, int empty_w1)\n{\n  Ihandle* child;\n\n  int i=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      /* only for the reference line,\n         the reference line defines the width of each column */\n      if (lin==ih->data->size_lin)\n      {\n        int empty_width = (child->expand & IUP_EXPAND_W1)? empty_w1: ((child->expand & IUP_EXPAND_W0)? empty_w0: 0);\n        col_width[col] = child->naturalwidth+empty_width;\n      }\n\n      i++;\n    }\n  }\n}\n\nstatic void iGridBoxCalcLineHeight(Ihandle* ih, int *line_height, int empty_h0, int empty_h1)\n{\n  Ihandle* child;\n\n  int i=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      /* only for the reference column,\n         the reference column defines the height of each line */\n      if (col==ih->data->size_col)\n      {\n        int empty_height = (child->expand & IUP_EXPAND_H1)? empty_h1: ((child->expand & IUP_EXPAND_H0)? empty_h0: 0);\n        line_height[lin] = child->naturalheight+empty_height;\n      }\n\n      i++;\n    }\n  }\n}\n\nstatic void iGridBoxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child;\n  int *line_height=NULL, *col_width=NULL, i;\n\n  if (ih->data->is_homogeneous_lin)\n    ih->data->homogeneous_height = iGridBoxCalcHomogeneousHeight(ih);\n  else\n  {\n    int empty_h0 = 0, empty_h1 = 0;\n\n    ih->data->homogeneous_height = 0;\n\n    /* must calculate the space left for each control to grow inside the container */\n    /* H1 means there is an EXPAND enabled inside */\n    if (ih->expand & IUP_EXPAND_H1)\n      empty_h1 = iGridBoxCalcEmptyHeight(ih, IUP_EXPAND_H1);\n    /* Not H1 and H0 means that EXPAND is not enabled, but there are some IupFill inside */\n    else if (ih->expand & IUP_EXPAND_H0)\n      empty_h0 = iGridBoxCalcEmptyHeight(ih, IUP_EXPAND_H0);\n\n    line_height = (int*)malloc(ih->data->num_lin * sizeof(int));\n    iGridBoxCalcLineHeight(ih, line_height, empty_h0, empty_h1);\n  }\n\n  if (ih->data->is_homogeneous_col)\n    ih->data->homogeneous_width = iGridBoxCalcHomogeneousWidth(ih);\n  else\n  {\n    int empty_w0 = 0, empty_w1 = 0;\n\n    ih->data->homogeneous_width = 0;\n\n    /* must calculate the space left for each control to grow inside the container */\n    /* W1 means there is an EXPAND enabled inside */\n    if (ih->expand & IUP_EXPAND_W1)\n      empty_w1 = iGridBoxCalcEmptyWidth(ih, IUP_EXPAND_W1);\n    /* Not W1 and W0 means that EXPAND is not enabled but there are some IupFill inside */\n    else if (ih->expand & IUP_EXPAND_W0)\n      empty_w0 = iGridBoxCalcEmptyWidth(ih, IUP_EXPAND_W0);\n\n    col_width = (int*)malloc(ih->data->num_col * sizeof(int));\n    iGridBoxCalcColWidth(ih, col_width, empty_w0, empty_w1);\n  }\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      int lin, col;\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      if (ih->data->homogeneous_width && ih->data->homogeneous_height)\n        iupBaseSetCurrentSize(child, ih->data->homogeneous_width, ih->data->homogeneous_height, shrink);\n      else if (ih->data->homogeneous_width)\n        iupBaseSetCurrentSize(child, ih->data->homogeneous_width, line_height[lin], shrink);\n      else if (ih->data->homogeneous_height)\n        iupBaseSetCurrentSize(child, col_width[col], ih->data->homogeneous_height, shrink);\n      else\n        iupBaseSetCurrentSize(child, col_width[col], line_height[lin], shrink);\n\n      i++;\n    }\n    else if (!(child->flags & IUP_FLOATING_IGNORE))\n    {\n      /* update children to their own natural size */\n      iupBaseSetCurrentSize(child, child->naturalwidth, child->naturalheight, shrink);\n    }\n  }\n\n  if (line_height)\n    free(line_height);\n  if (col_width)\n    free(col_width);\n}\n\nstatic void iGridBoxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int dx, dy, i, *line_pos, \n      lin, col, *col_pos,\n      *alignment_col, *alignment_lin, *col_width, *line_height;\n  Ihandle* child;\n\n  col_pos = (int*)malloc(ih->data->num_col *sizeof(int));\n  line_pos = (int*)malloc(ih->data->num_lin *sizeof(int));\n  alignment_col = (int*)malloc(ih->data->num_col *sizeof(int));\n  alignment_lin = (int*)malloc(ih->data->num_lin *sizeof(int));\n  col_width = (int*)malloc(ih->data->num_col *sizeof(int));\n  line_height = (int*)malloc(ih->data->num_lin *sizeof(int));\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      /* only for the reference line,\n         the reference line defines the width of each column */\n      if (lin==ih->data->size_lin)\n      {\n        if (ih->data->homogeneous_width)\n          col_width[col] = ih->data->homogeneous_width + ih->data->gap_col;\n        else\n          col_width[col] = child->currentwidth + ih->data->gap_col;\n\n        alignment_col[col] = iGridBoxGetAlignmentCol(ih, col);\n      }\n\n      /* only for the reference column,\n         the reference column defines the height of each line */\n      if (col==ih->data->size_col)\n      {\n        if (ih->data->homogeneous_height)\n          line_height[lin] = ih->data->homogeneous_height + ih->data->gap_lin;\n        else\n          line_height[lin] = child->currentheight + ih->data->gap_lin;\n\n        alignment_lin[lin] = iGridBoxGetAlignmentLin(ih, lin);\n      }\n\n      i++;\n    }\n  }\n\n  for (col=0; col<ih->data->num_col; col++)\n  {\n    if (col==0)\n      col_pos[col] = ih->data->margin_x;\n    else\n      col_pos[col] = col_pos[col-1] + col_width[col-1];\n  }\n\n  for (lin=0; lin<ih->data->num_lin; lin++)\n  {\n    if (lin==0)\n      line_pos[lin] = ih->data->margin_y;\n    else\n      line_pos[lin] = line_pos[lin-1] + line_height[lin-1];\n  }\n\n  i = 0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      iGridBoxCalcLinCol(ih, i, &lin, &col);\n\n      if (alignment_lin[lin] == IUP_ALIGN_ACENTER)\n        dy = (line_height[lin] - child->currentheight)/2;\n      else if (alignment_lin[lin] == IUP_ALIGN_ABOTTOM)\n        dy = line_height[lin] - child->currentheight;\n      else  /* IUP_ALIGN_ATOP */\n        dy = 0;\n      if (dy<0) dy = 0;\n\n      if (alignment_col[col] == IUP_ALIGN_ACENTER)\n        dx = (col_width[col] - child->currentwidth)/2;\n      else if (alignment_col[col] == IUP_ALIGN_ARIGHT)\n        dx = col_width[col] - child->currentwidth;\n      else  /* IUP_ALIGN_ALEFT */\n        dx = 0;\n      if (dx<0) dx = 0;\n\n      /* update child */\n      iupBaseSetPosition(child, x+col_pos[col]+dx, y+line_pos[lin]+dy);\n\n      i++;\n    }\n  }\n\n  free(alignment_col);\n  free(alignment_lin);\n  free(col_width);\n  free(line_height);\n  free(col_pos);\n  free(line_pos);\n}\n\nstatic int iGridBoxCreateMethod(Ihandle* ih, void** params)\n{\n  ih->data = iupALLOCCTRLDATA();\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams) \n    {\n      IupAppend(ih, *iparams);\n      iparams++;\n    }\n  }\n\n  ih->data->num_div = -1; /* default is auto */\n\n  IupSetCallback(ih, \"UPDATEATTRIBFROMFONT\", iGridBoxUpdateAttribFromFont);\n\n  return IUP_NOERROR;\n}\n\n\n/******************************************************************************/\n\n\nIhandle *IupGridBoxv(Ihandle **children)\n{\n  return IupCreatev(\"gridbox\", (void**)children);\n}\n\nIhandle *IupGridBox(Ihandle* child, ...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"gridbox\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIclass* iupGridBoxNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"gridbox\";\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupGridBoxNewClass;\n  ic->Create = iGridBoxCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n  ic->ComputeNaturalSize = iGridBoxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iGridBoxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iGridBoxSetChildrenPositionMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iGridBoxGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* boxes */\n  iupClassRegisterAttribute(ic, \"MARGIN\", iGridBoxGetMarginAttrib, iGridBoxSetMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CMARGIN\", iGridBoxGetCMarginAttrib, iGridBoxSetCMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"NMARGIN\", iGridBoxGetMarginAttrib, iGridBoxSetMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NCMARGIN\", iGridBoxGetCMarginAttrib, iGridBoxSetCMarginAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"EXPANDCHILDREN\", iGridBoxGetExpandChildrenAttrib, iGridBoxSetExpandChildrenAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HOMOGENEOUSLIN\", iGridBoxGetHomogeneousLinAttrib, iGridBoxSetHomogeneousLinAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HOMOGENEOUSCOL\", iGridBoxGetHomogeneousColAttrib, iGridBoxSetHomogeneousColAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NORMALIZESIZE\", iGridBoxGetNormalizeSizeAttrib, iGridBoxSetNormalizeSizeAttrib, IUPAF_SAMEASSYSTEM, \"NONE\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* GridBox only */\n  iupClassRegisterAttribute(ic, \"GAPLIN\", iGridBoxGetGapLinAttrib, iGridBoxSetGapLinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CGAPLIN\", iGridBoxGetCGapLinAttrib, iGridBoxSetCGapLinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"GAPCOL\", iGridBoxGetGapColAttrib, iGridBoxSetGapColAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CGAPCOL\", iGridBoxGetCGapColAttrib, iGridBoxSetCGapColAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"NGAPLIN\", iGridBoxGetGapLinAttrib, iGridBoxSetGapLinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NCGAPLIN\", iGridBoxGetCGapLinAttrib, iGridBoxSetCGapLinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NGAPCOL\", iGridBoxGetGapColAttrib, iGridBoxSetGapColAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NCGAPCOL\", iGridBoxGetCGapColAttrib, iGridBoxSetCGapColAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"ALIGNMENTLIN\", iGridBoxGetAlignmentLinAttrib, iGridBoxSetAlignmentLinAttrib, IUPAF_SAMEASSYSTEM, \"ATOP\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ALIGNMENTCOL\", iGridBoxGetAlignmentColAttrib, iGridBoxSetAlignmentColAttrib, IUPAF_SAMEASSYSTEM, \"ALEFT\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", iGridBoxGetOrientationAttrib, iGridBoxSetOrientationAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NUMDIV\", iGridBoxGetNumDivAttrib, iGridBoxSetNumDivAttrib, IUPAF_SAMEASSYSTEM, \"AUTO\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NUMCOL\", iGridBoxGetNumColAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"NUMLIN\", iGridBoxGetNumLinAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SIZELIN\", iGridBoxGetSizeLinAttrib, iGridBoxSetSizeLinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"SIZECOL\", iGridBoxGetSizeColAttrib, iGridBoxSetSizeColAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"FITTOCHILDREN\", NULL, iGridBoxSetFitToChildrenAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_WRITEONLY | IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Hbox Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_box.h\"\n#include \"iup_normalizer.h\"\n\n\nstatic int iHboxSetRasterSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    iupStrToIntInt(value, &s, &d, 'x');  /* second value will be ignored, can NOT set height */\n    if (s > 0) \n    {\n      ih->userheight = 0;\n      ih->userwidth = s;\n    }\n  }\n  iupAttribSet(ih, \"SIZE\", NULL); /* clear SIZE in hash table */\n  return 0;\n}\n\nstatic int iHboxSetSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    iupStrToIntInt(value, &s, &d, 'x');  /* second value will be ignored, can NOT set height */\n    if (s > 0) \n    {\n      int charwidth, charheight;\n      iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n      ih->userheight = 0;\n      ih->userwidth = iupWIDTH2RASTER(s, charwidth);\n    }\n  }\n  return 1;  /* always save in the hash table, so when FONT is changed SIZE can be updated */\n}\n\nstatic int iHboxSetAlignmentAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"ABOTTOM\"))\n    ih->data->alignment = IUP_ALIGN_ABOTTOM;\n  else if (iupStrEqualNoCase(value, \"ACENTER\"))\n    ih->data->alignment = IUP_ALIGN_ACENTER;\n  else if (iupStrEqualNoCase(value, \"ATOP\"))\n    ih->data->alignment = IUP_ALIGN_ATOP;\n  return 0;\n}\n\nstatic char* iHboxGetAlignmentAttrib(Ihandle* ih)\n{\n  static char* align2str[3] = {\"ATOP\", \"ACENTER\", \"ABOTTOM\"};\n  return align2str[ih->data->alignment];\n}\n\nstatic void iHboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int total_natural_width, total_natural_height;\n\n  /* calculate total children natural size */\n  int children_count = 0;\n  int children_natural_width = 0;\n  int children_natural_maxwidth = 0;\n  int children_natural_maxheight = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (ih->data->expand_children)\n      child->expand = ih->data->expand_children;\n\n    /* update child natural size first */\n    if (!(child->flags & IUP_FLOATING_IGNORE))\n      iupBaseComputeNaturalSize(child);\n\n    if (!(child->flags & IUP_FLOATING))\n    {\n      *children_expand |= child->expand;\n      children_natural_maxwidth = iupMAX(children_natural_maxwidth, child->naturalwidth);\n      children_natural_maxheight = iupMAX(children_natural_maxheight, child->naturalheight);\n      children_count++;\n    }\n  }\n\n  /* reset to max natural width and/or height if NORMALIZESIZE is defined */\n  if (ih->data->normalize_size)\n    iupNormalizeSizeBoxChild(ih, ih->data->normalize_size, children_natural_maxwidth, children_natural_maxheight);\n\n  /* must be done after normalize */\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n      children_natural_width += child->naturalwidth;\n  }\n\n  /* leave room at the element for the maximum natural size of the children when is_homogeneous */\n  if (ih->data->is_homogeneous)\n    children_natural_width = children_natural_maxwidth*children_count;\n\n  /* compute the Hbox contents natural size */\n  total_natural_width  = children_natural_width + (children_count-1)*ih->data->gap + 2*ih->data->margin_x;\n  total_natural_height = children_natural_maxheight + 2*ih->data->margin_y;\n\n  /* Store to be used in iHboxCalcEmptyWidth */\n  ih->data->total_natural_size = total_natural_width;\n\n  *w = total_natural_width;\n  *h = total_natural_height;\n}\n\nstatic int iHboxCalcHomogeneousWidth(Ihandle *ih)\n{\n  Ihandle* child;\n  int homogeneous_width;\n\n  int children_count=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n      children_count++;\n  }\n  if (children_count == 0)\n    return 0;\n\n  /* equal spaces for all elements */\n  homogeneous_width = (ih->currentwidth - (children_count-1)*ih->data->gap - 2*ih->data->margin_x)/children_count;\n  if (homogeneous_width<0) homogeneous_width = 0;\n  return homogeneous_width;\n}\n\nstatic int iHboxCalcEmptyWidth(Ihandle *ih, int expand)\n{\n  /* This is the space that the child can be expanded. */\n  Ihandle* child;\n  int empty_width;\n\n  int expand_count=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING) && child->expand & expand)\n      expand_count++;\n  }\n  if (expand_count == 0)\n    return 0;\n\n  /* equal spaces for all expandable elements */\n  empty_width = (ih->currentwidth - ih->data->total_natural_size)/expand_count;\n  if (empty_width < 0) empty_width = 0;\n  return empty_width;\n}\n\nstatic void iHboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  /* update children */\n  Ihandle* child;\n  int empty_w0 = 0, empty_w1 = 0, client_height;\n\n  if (ih->data->is_homogeneous)\n    ih->data->homogeneous_size = iHboxCalcHomogeneousWidth(ih);\n  else\n  {\n    ih->data->homogeneous_size = 0;\n\n    /* must calculate the space left for each control to grow inside the container */\n    /* W1 means there is an EXPAND enabled inside */\n    if (ih->expand & IUP_EXPAND_W1)\n      empty_w1 = iHboxCalcEmptyWidth(ih, IUP_EXPAND_W1);\n    /* Not W1 and W0 means that EXPAND is not enabled but there are some IupFill inside */\n    else if (ih->expand & IUP_EXPAND_W0)\n      empty_w0 = iHboxCalcEmptyWidth(ih, IUP_EXPAND_W0);\n  }\n\n  client_height = ih->currentheight - 2*ih->data->margin_y;\n  if (client_height<0) client_height=0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      if (ih->data->homogeneous_size)\n        iupBaseSetCurrentSize(child, ih->data->homogeneous_size, client_height, shrink);\n      else\n      {\n        int empty = (child->expand & IUP_EXPAND_W1)? empty_w1: ((child->expand & IUP_EXPAND_W0)? empty_w0: 0);\n        char* weight_str = iupAttribGet(child, \"EXPANDWEIGHT\");\n        if (weight_str)\n        {\n          float weight; \n          if (iupStrToFloat(weight_str, &weight))\n            empty = iupRound(empty * weight);\n        }\n        iupBaseSetCurrentSize(child, child->naturalwidth+empty, client_height, shrink);\n      }\n    }\n    else if (!(child->flags & IUP_FLOATING_IGNORE))\n    {\n      /* update children to their own natural size */\n      iupBaseSetCurrentSize(child, child->naturalwidth, child->naturalheight, shrink);\n    }\n  }\n}\n\nstatic void iHboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int dy, client_height;\n  Ihandle* child;\n\n  x += ih->data->margin_x;\n  y += ih->data->margin_y;\n\n  client_height = ih->currentheight - 2*ih->data->margin_y;\n  if (client_height<0) client_height=0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      if (ih->data->alignment == IUP_ALIGN_ACENTER)\n        dy = (client_height - child->currentheight)/2;\n      else if (ih->data->alignment == IUP_ALIGN_ABOTTOM)\n        dy = client_height - child->currentheight;\n      else  /* IUP_ALIGN_ATOP */\n        dy = 0;\n      if (dy<0) dy = 0;\n                      \n      /* update child */\n      iupBaseSetPosition(child, x, y+dy);\n\n      /* calculate next */\n      if (ih->data->homogeneous_size)\n        x += ih->data->homogeneous_size + ih->data->gap;\n      else\n        x += child->currentwidth + ih->data->gap;\n    }\n  }\n}\n\n\n/******************************************************************************/\n\n\nIhandle *IupHboxv(Ihandle **children)\n{\n  return IupCreatev(\"hbox\", (void**)children);\n}\n\nIhandle *IupHbox(Ihandle* child, ...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"hbox\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIclass* iupHboxNewClass(void)\n{\n  Iclass* ic = iupBoxNewClassBase();\n\n  ic->name = \"hbox\";\n\n  /* Class functions */\n  ic->New = iupHboxNewClass;\n  ic->ComputeNaturalSize = iHboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iHboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iHboxSetChildrenPositionMethod;\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"SIZE\", iupBaseGetSizeAttrib, iHboxSetSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iupBaseGetRasterSizeAttrib, iHboxSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Hbox only */\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", iHboxGetAlignmentAttrib, iHboxSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, \"ATOP\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Image Resource.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n#include \"iup_assert.h\"\n#include \"iup_stdcontrols.h\"\n\n\ntypedef struct _IimageStock\n{\n  iupImageStockCreateFunc func;\n  Ihandle* image;            /* cache image */\n  const char* native_name;   /* used to map to GTK stock images */\n} IimageStock;\n\nstatic Itable *istock_table = NULL;   /* the image hash table indexed by the name string */\n\nvoid iupImageStockInit(void)\n{\n  istock_table = iupTableCreate(IUPTABLE_STRINGINDEXED);\n}\n\nvoid iupImageStockFinish(void)\n{\n  char* name = iupTableFirst(istock_table);\n  while (name)\n  {\n    IimageStock* istock = (IimageStock*)iupTableGetCurr(istock_table);\n    if (iupObjectCheck(istock->image))\n      IupDestroy(istock->image);\n    memset(istock, 0, sizeof(IimageStock));\n    free(istock);\n    name = iupTableNext(istock_table);\n  }\n\n  iupTableDestroy(istock_table);\n  istock_table = NULL;\n}\n\nvoid iupImageStockSet(const char *name, iupImageStockCreateFunc func, const char* native_name)\n{\n  IimageStock* istock = (IimageStock*)iupTableGet(istock_table, name);\n  if (istock)\n    free(istock);  /* overwrite a previous registration */\n\n  istock = (IimageStock*)malloc(sizeof(IimageStock));\n  istock->func = func;\n  istock->image = NULL;\n  istock->native_name = native_name;\n\n  iupTableSet(istock_table, name, (void*)istock, IUPTABLE_POINTER);\n}\n\nstatic void iImageStockGet(const char* name, Ihandle* *ih, const char* *native_name)\n{\n  IimageStock* istock = (IimageStock*)iupTableGet(istock_table, name);\n  if (istock)\n  {\n    if (istock->image)\n      *ih = istock->image;\n    else if (istock->native_name)\n        *native_name = istock->native_name;\n    else if (istock->func)\n    {\n      istock->image = istock->func();\n      *ih = istock->image;\n    }\n  }\n}\n\nstatic void iImageStockUnload(const char* name)\n{\n  IimageStock* istock = (IimageStock*)iupTableGet(istock_table, name);\n  if (istock)\n    istock->image = NULL;\n}\n\nstatic void iImageStockLoad(const char *name)\n{\n  const char* native_name = NULL;\n  Ihandle* ih = NULL;\n  iImageStockGet(name, &ih, &native_name);\n  if (ih)\n  {\n    IupSetHandle(name, ih);\n    iupAttribSetStr(ih, \"_IUPSTOCK_LOAD\", name);\n  }\n  else if (native_name)\n  {\n    /* dummy image to save the GTK stock name */\n    void* handle = iupdrvImageLoad(native_name, IUPIMAGE_IMAGE);\n    if (handle)\n    {\n      int w, h, bpp;\n      iupdrvImageGetInfo(handle, &w, &h, &bpp);\n      if (bpp == 32)\n        ih = IupImageRGBA(w,h,NULL);\n      else\n        ih = IupImageRGB(w,h,NULL);\n      iupAttribSet(ih, \"_IUPSTOCK_LOAD_HANDLE\", (char*)handle);\n      IupSetHandle(name, ih);\n    }\n  }\n}\n\nvoid iupImageStockLoadAll(void)\n{\n  /* Used only in IupView */\n  char* name = iupTableFirst(istock_table);\n  while (name)\n  {\n    iImageStockLoad(name);\n    name = iupTableNext(istock_table);\n  }\n}\n\n\n\n/**************************************************************************************************/\n/**************************************************************************************************/\n\n\nint iupImageNormBpp(int bpp)\n{\n  if (bpp <= 8) return 8;\n  if (bpp <= 24) return 24;\n  return 32;\n}\n\nstatic void iupColorSet(iupColor *c, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  c->r = r;\n  c->g = g;\n  c->b = b;\n  c->a = a;\n}\n\nint iupImageInitColorTable(Ihandle *ih, iupColor* colors, int *colors_count)\n{\n  char *value;\n  unsigned char red, green, blue;\n  int i, has_alpha = 0;\n  static iupColor default_colors[] = {\n    { 0,0,0,255 }, { 128,0,0,255 }, { 0,128,0,255 }, { 128,128,0,255 },    \n    { 0,0,128,255 }, { 128,0,128,255 }, { 0,128,128,255 }, { 192,192,192,255 },    \n    { 128,128,128,255 }, { 255,0,0,255 }, { 0,255,0,255 }, { 255,255,0,255 },\n    { 0,0,255,255 }, { 255,0,255,255 }, { 0,255,255,255 }, { 255,255,255,255 } };\n\n  memset(colors, 0, sizeof(iupColor)*256);\n\n  for (i=0;i<16;i++)\n  {\n    value = iupAttribGetId(ih, \"\", i);\n\n    if (value)\n    {\n      if (iupStrEqual(value, \"BGCOLOR\"))\n      {\n        iupColorSet(&colors[i], 0, 0, 0, 0);\n        has_alpha = 1;\n      }\n      else\n      {\n        if (!iupStrToRGB(value, &red, &green, &blue))\n          iupColorSet(&colors[i], default_colors[i].r, default_colors[i].g, default_colors[i].b, 255);\n        else\n          iupColorSet(&colors[i], red, green, blue, 255);\n      }\n    }\n    else\n    {\n      iupColorSet(&colors[i], default_colors[i].r, default_colors[i].g, default_colors[i].b, 255);\n    }\n  }\n\n  for (;i<256;i++)\n  {\n    value = iupAttribGetId(ih, \"\", i);\n    if (!value)\n      break;\n\n    if (iupStrEqual(value, \"BGCOLOR\"))\n    {\n      iupColorSet(&colors[i], 0, 0, 0, 0);\n      has_alpha = 1;\n    }\n    else\n    {\n      if (!iupStrToRGB(value, &red, &green, &blue))\n        break;\n\n      iupColorSet(&colors[i], red, green, blue, 255);\n    }\n  }\n\n  if (colors_count) *colors_count = i;\n\n  return has_alpha;\n}\n\nvoid iupImageInitNonBgColors(Ihandle* ih, unsigned char *colors)\n{\n  char *value;\n  int i;\n\n  memset(colors, 0, 256);\n\n  for (i=0;i<16;i++)\n  {\n    value = iupAttribGetId(ih, \"\", i);\n    if (!iupStrEqual(value, \"BGCOLOR\"))\n      colors[i] = 1;\n  }\n\n  for (;i<256;i++)\n  {\n    value = iupAttribGetId(ih, \"\", i);\n    if (!value)\n      break;\n\n    if (!iupStrEqual(value, \"BGCOLOR\"))\n      colors[i] = 1;\n  }\n}\n\nvoid iupImageColorMakeInactive(unsigned char *r, unsigned char *g, unsigned char *b, unsigned char bg_r, unsigned char bg_g, unsigned char bg_b)\n{\n  if (*r==bg_r && *g==bg_g && *b==bg_b)  /* preserve colors identical to the background color */\n  {\n    *r = bg_r; \n    *g = bg_g; \n    *b = bg_b; \n  }\n  else\n  {\n    int ir = 0, ig = 0, ib = 0, \n      i = (*r+*g+*b)/3,\n      bg_i = (bg_r+bg_g+bg_b)/3;\n\n    if (bg_i)\n    {\n      ir = (bg_r*i)/bg_i; \n      ig = (bg_g*i)/bg_i; \n      ib = (bg_b*i)/bg_i; \n    }\n\n#define LIGHTER(_c) ((255 + _c)/2)\n    ir = LIGHTER(ir);\n    ig = LIGHTER(ig);\n    ib = LIGHTER(ib);\n\n    *r = iupBYTECROP(ir);\n    *g = iupBYTECROP(ig);\n    *b = iupBYTECROP(ib);\n  }\n}\n\n\n/**************************************************************************************************/\n/**************************************************************************************************/\n\n\nvoid* iupImageGetMask(const char* name)\n{\n  void* mask;\n  Ihandle *ih;\n\n  if (!name)\n    return NULL;\n\n  /* get handle from name */\n  ih = IupGetHandle(name);\n  if (!ih)\n    return NULL;\n  \n  /* Check for an already created icon */\n  mask = iupAttribGet(ih, \"_IUPIMAGE_MASK\");\n  if (mask)\n    return mask;\n\n  /* Not created, tries to create the mask */\n  mask = iupdrvImageCreateMask(ih);\n\n  /* save the mask */\n  iupAttribSet(ih, \"_IUPIMAGE_MASK\", (char*)mask);\n\n  return mask;\n}\n\nvoid* iupImageGetIcon(const char* name)\n{\n  void* icon;\n  Ihandle *ih;\n\n  if (!name)\n    return NULL;\n\n  /* get handle from name */\n  ih = IupGetHandle(name);\n  if (!ih)\n  {\n    /* Check in the system resources. */\n    icon = iupdrvImageLoad(name, IUPIMAGE_ICON);\n    if (icon) \n      return icon;\n\n    return NULL;\n  }\n  \n  /* Check for an already created icon */\n  icon = iupAttribGet(ih, \"_IUPIMAGE_ICON\");\n  if (icon)\n    return icon;\n\n  /* Not created, tries to create the icon */\n  icon = iupdrvImageCreateIcon(ih);\n\n  /* save the icon */\n  iupAttribSet(ih, \"_IUPIMAGE_ICON\", (char*)icon);\n\n  return icon;\n}\n\nvoid* iupImageGetCursor(const char* name)\n{\n  void* cursor;\n  Ihandle *ih;\n\n  if (!name)\n    return NULL;\n\n  /* get handle from name */\n  ih = IupGetHandle(name);\n  if (!ih)\n  {\n    /* Check in the system resources. */\n    cursor = iupdrvImageLoad(name, IUPIMAGE_CURSOR);\n    if (cursor) \n      return cursor;\n\n    return NULL;\n  }\n  \n  /* Check for an already created cursor */\n  cursor = iupAttribGet(ih, \"_IUPIMAGE_CURSOR\");\n  if (cursor)\n    return cursor;\n\n  /* Not created, tries to create the cursor */\n  cursor = iupdrvImageCreateCursor(ih);\n\n  /* save the cursor */\n  iupAttribSet(ih, \"_IUPIMAGE_CURSOR\", (char*)cursor);\n\n  return cursor;\n}\n\nvoid iupImageGetInfo(const char* name, int *w, int *h, int *bpp)\n{\n  void* handle;\n  Ihandle *ih;\n\n  if (!name)\n    return;\n\n  /* get handle from name */\n  ih = IupGetHandle(name);\n  if (!ih)\n  {\n    const char* native_name = NULL;\n\n    /* Check in the system resources. */\n    handle = iupdrvImageLoad(name, IUPIMAGE_IMAGE);\n    if (handle)\n    {\n      iupdrvImageGetInfo(handle, w, h, bpp);\n      return;\n    }\n\n    /* Check in the stock images. */\n    iImageStockGet(name, &ih, &native_name);\n    if (native_name) \n    {\n      handle = iupdrvImageLoad(native_name, IUPIMAGE_IMAGE);\n      if (handle) \n      {\n        iupdrvImageGetInfo(handle, w, h, bpp);\n        return;\n      }\n    }\n\n    if (!ih)\n      return;\n  }\n\n  if (w) *w = ih->currentwidth;\n  if (h) *h = ih->currentheight;\n  if (bpp) *bpp = IupGetInt(ih, \"BPP\");\n}\n\nvoid* iupImageGetImage(const char* name, Ihandle* ih_parent, int make_inactive)\n{\n  char cache_name[100] = \"_IUPIMAGE_IMAGE\";\n  char* bgcolor;\n  void* handle;\n  Ihandle *ih;\n  int bg_concat = 0;\n\n  if (!name)\n    return NULL;\n\n  /* get handle from name */\n  ih = IupGetHandle(name);\n  if (!ih)\n  {\n    const char* native_name = NULL;\n\n    /* Check in the system resources. */\n    handle = iupdrvImageLoad(name, IUPIMAGE_IMAGE);\n    if (handle) \n      return handle;\n\n    /* Check in the stock images. */\n    iImageStockGet(name, &ih, &native_name);\n    if (native_name) \n    {\n      handle = iupdrvImageLoad(native_name, IUPIMAGE_IMAGE);\n      if (handle) \n        return handle;\n    }\n\n    if (!ih)\n      return NULL;\n  }\n\n  handle = iupAttribGet(ih, \"_IUPSTOCK_LOAD_HANDLE\");\n  if (handle)\n    return handle;\n\n  bgcolor = iupAttribGet(ih, \"BGCOLOR\");\n  if (ih_parent && !bgcolor)\n    bgcolor = IupGetAttribute(ih_parent, \"BGCOLOR\"); /* Use IupGetAttribute to use inheritance and native implementation */\n\n  if (make_inactive)\n    strcat(cache_name, \"_INACTIVE\");\n\n  if (iupAttribGet(ih, \"_IUP_BGCOLOR_DEPEND\") && bgcolor)\n  {\n    strcat(cache_name, \"(\");\n    strcat(cache_name, bgcolor);\n    strcat(cache_name, \")\");\n    bg_concat = 1;\n  }\n  \n  /* Check for an already created native image */\n  handle = (void*)iupAttribGet(ih, cache_name);\n  if (handle)\n    return handle;\n\n  if (ih_parent && iupAttribGetStr(ih_parent, \"FLAT_ALPHA\"))\n    iupAttribSet(ih, \"FLAT_ALPHA\", \"1\");\n\n  /* Creates the native image */\n  handle = iupdrvImageCreateImage(ih, bgcolor, make_inactive);\n\n  if (ih_parent && iupAttribGetStr(ih_parent, \"FLAT_ALPHA\"))\n    iupAttribSet(ih, \"FLAT_ALPHA\", NULL);\n\n  if (iupAttribGet(ih, \"_IUP_BGCOLOR_DEPEND\") && bgcolor && !bg_concat)  /* _IUP_BGCOLOR_DEPEND could be set during creation */\n  {\n    strcat(cache_name, \"(\");\n    strcat(cache_name, bgcolor);\n    strcat(cache_name, \")\");\n  }\n\n  /* save the native image in the cache */\n  iupAttribSet(ih, cache_name, (char*)handle);\n\n  return handle;\n}\n\nvoid iupImageUpdateParent(Ihandle *ih)  /* ih here is the element that contains images */\n{\n  /* Called when BGCOLOR is changed */\n  /* it will re-create the image, if the case */\n\n  char* value = iupAttribGet(ih, \"IMAGE\");\n  if (value) \n    iupAttribSetClassObject(ih, \"IMAGE\", value);\n\n  value = iupAttribGet(ih, \"IMINACTIVE\");\n  if (value) \n    iupAttribSetClassObject(ih, \"IMINACTIVE\", value);\n\n  value = iupAttribGet(ih, \"IMPRESS\");\n  if (value) \n    iupAttribSetClassObject(ih, \"IMPRESS\", value);\n}\n\nstatic char* iImageGetWidthAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->currentwidth);\n}\n\nstatic char* iImageGetHeightAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->currentheight);\n}\n\nvoid iupImageClearFromCache(Ihandle* ih, void* handle)\n{\n  char *name;\n  void* cur_handle;\n\n  name = iupTableFirst(ih->attrib);\n  while (name)\n  {\n    if (iupStrEqualPartial(name, \"_IUPIMAGE_\"))\n    {\n      cur_handle = iupTableGetCurr(ih->attrib);\n      if (cur_handle == handle)\n      {\n        iupTableRemoveCurr(ih->attrib);\n        return;\n      }\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n}\n\nstatic void iImageClearCache(Ihandle* ih)\n{\n  char *name;\n  void* handle;\n\n  handle = iupAttribGet(ih, \"_IUPIMAGE_MASK\");\n  if (handle)\n  {\n    iupdrvImageDestroy(handle, IUPIMAGE_IMAGE);\n    iupAttribSet(ih, \"_IUPIMAGE_MASK\", NULL);\n  }\n\n  handle = iupAttribGet(ih, \"_IUPIMAGE_ICON\");\n  if (handle) \n  {\n    iupdrvImageDestroy(handle, IUPIMAGE_ICON);\n    iupAttribSet(ih, \"_IUPIMAGE_ICON\", NULL);\n  }\n\n  handle = iupAttribGet(ih, \"_IUPIMAGE_CURSOR\");\n  if (handle) \n  {\n    iupdrvImageDestroy(handle, IUPIMAGE_CURSOR);\n    iupAttribSet(ih, \"_IUPIMAGE_CURSOR\", NULL);\n  }\n\n  /* the remaining native images are all IUPIMAGE_IMAGE(*) - depends on BGCOLOR/INACTIVE/etc  */\n  name = iupTableFirst(ih->attrib);\n  while (name)\n  {\n    if (iupStrEqualPartial(name, \"_IUPIMAGE_IMAGE\"))\n    {\n      handle = iupTableGetCurr(ih->attrib);\n      if (handle)\n      {\n        iupdrvImageDestroy(handle, IUPIMAGE_IMAGE);\n        iupTableSetCurr(ih->attrib, NULL, IUPTABLE_POINTER);\n      }\n    }\n\n    name = iupTableNext(ih->attrib);\n  }\n\n  /* additional image buffer when an IupImage is converted to one (CD, OpenGL, etc) */\n  handle = iupAttribGet(ih, \"_IUPIMAGE_BUFFER\");\n  if (handle)\n  {\n    iupAttribSet(ih, \"_IUPIMAGE_BUFFER\", NULL);\n    free(handle);\n  }\n\n  handle = iupAttribGet(ih, \"_IUPIMAGE_BUFFER_INACTIVE\");\n  if (handle)\n  {\n    iupAttribSet(ih, \"_IUPIMAGE_BUFFER_INACTIVE\", NULL);\n    free(handle);\n  }\n}\n\nstatic int iImageCreate(Ihandle* ih, void** params, int bpp)\n{\n  int width, height, channels, count;\n  unsigned char *imgdata;\n\n  iupASSERT(params!=NULL);\n  if (!params)\n    return IUP_ERROR;\n\n  width = (int)(params[0]);\n  height = (int)(params[1]);\n\n  iupASSERT(width>0);\n  iupASSERT(height>0);\n\n  if (width <= 0 || height <= 0)\n    return IUP_ERROR;\n\n  ih->currentwidth = width;\n  ih->currentheight = height;\n\n  channels = 1;\n  if (bpp == 24)\n    channels = 3;\n  else if (bpp == 32)\n    channels = 4;\n\n  count = width*height*channels;\n  imgdata = (unsigned char *)malloc(count);\n\n  if (((int)(params[2])==-1) || ((int)(params[3])==-1)) /* compacted in one pointer */\n  {\n    if ((int)(params[2])!=-1)\n      memcpy(imgdata, params[2], count);\n  }\n  else /* one param for each pixel/plane */\n  {\n    int i;\n    for(i=0; i<count; i++)\n    {\n      imgdata[i] = (unsigned char)((int)(params[i+2]));\n    }\n  }\n\n  iupAttribSet(ih, \"WID\", (char*)imgdata);\n  iupAttribSetInt(ih, \"BPP\", bpp);\n  iupAttribSetInt(ih, \"CHANNELS\", channels);\n\n  return IUP_NOERROR;\n}\n\nstatic int iImageCreateMethod(Ihandle* ih, void** params)\n{\n  return iImageCreate(ih, params, 8);\n}\n\nstatic int iImageRGBCreateMethod(Ihandle* ih, void** params)\n{\n  return iImageCreate(ih, params, 24);\n}\n\nstatic int iImageRGBACreateMethod(Ihandle* ih, void** params)\n{\n  return iImageCreate(ih, params, 32);\n}\n\nstatic void iImageDestroyMethod(Ihandle* ih)\n{\n  char* stock_name;\n\n  unsigned char* imgdata = (unsigned char*)iupAttribGetStr(ih, \"WID\");\n  if (imgdata)\n  {\n    iupAttribSet(ih, \"WID\", NULL);\n    free(imgdata);\n  }\n\n  stock_name = iupAttribGet(ih, \"_IUPSTOCK_LOAD\");\n  if (stock_name)\n    iImageStockUnload(stock_name);\n\n  iImageClearCache(ih);\n}\n\n/******************************************************************************/\n\nIhandle* IupImage(int width, int height, const unsigned char *imgdata)\n{\n  void *params[4];\n  params[0] = (void*)width;\n  params[1] = (void*)height;\n  params[2] = imgdata? (void*)imgdata: (void*)-1;\n  params[3] = (void*)-1;\n  return IupCreatev(\"image\", params);\n}\n\nIhandle* IupImageRGB(int width, int height, const unsigned char *imgdata)\n{\n  void *params[4];\n  params[0] = (void*)width;\n  params[1] = (void*)height;\n  params[2] = imgdata? (void*)imgdata: (void*)-1;\n  params[3] = (void*)-1;\n  return IupCreatev(\"imagergb\", params);\n}\n\nIhandle* IupImageRGBA(int width, int height, const unsigned char *imgdata)\n{\n  void *params[4];\n  params[0] = (void*)width;\n  params[1] = (void*)height;\n  params[2] = imgdata? (void*)imgdata: (void*)-1;\n  params[3] = (void*)-1;\n  return IupCreatev(\"imagergba\", params);\n}\n\nstatic Iclass* iImageNewClassBase(char* name)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = name;\n  ic->format = \"iic\"; /* (int,int,unsigned char*) */\n  ic->nativetype = IUP_TYPEIMAGE;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->Destroy = iImageDestroyMethod;\n\n  /* Attribute functions */\n  iupClassRegisterAttribute(ic, \"WID\", NULL, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"WIDTH\", iImageGetWidthAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"HEIGHT\", iImageGetHeightAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iupBaseGetRasterSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"BPP\",      NULL, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CHANNELS\", NULL, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"HOTSPOT\", NULL, NULL, \"0:0\", NULL, IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIclass* iupImageNewClass(void)\n{\n  Iclass* ic = iImageNewClassBase(\"image\");\n  ic->New = iupImageNewClass;\n  ic->Create = iImageCreateMethod;\n  return ic;\n}\n\nIclass* iupImageRGBNewClass(void)\n{\n  Iclass* ic = iImageNewClassBase(\"imagergb\");\n  ic->New = iupImageRGBNewClass;\n  ic->Create = iImageRGBCreateMethod;\n  return ic;\n}\n\nIclass* iupImageRGBANewClass(void)\n{\n  Iclass* ic = iImageNewClassBase(\"imagergba\");\n  ic->New = iupImageRGBANewClass;\n  ic->Create = iImageRGBACreateMethod;\n  return ic;\n}\n\nstatic int SaveImageC(const char* file_name, Ihandle* ih, const char* name, FILE* packfile)\n{\n  int y, x, width, height, channels, linesize;\n  unsigned char* data;\n  FILE* file;\n\n  if (packfile)\n    file = packfile;\n  else\n    file = fopen(file_name, \"wb\");\n\n  if (!file)\n    return 0;\n\n  width = IupGetInt(ih, \"WIDTH\");\n  height = IupGetInt(ih, \"HEIGHT\");\n  channels = IupGetInt(ih, \"CHANNELS\");\n  linesize = width*channels;\n\n  data = (unsigned char*)IupGetAttribute(ih, \"WID\");\n\n  if (fprintf(file, \"static Ihandle* load_image_%s(void)\\n\", name)<0)\n  {\n    if (!packfile)\n      fclose(file);\n    return 0;\n  }\n\n  fprintf(file, \"{\\n\");\n  fprintf(file, \"  unsigned char imgdata[] = {\\n\");\n\n  for (y = 0; y < height; y++)\n  {\n    fprintf(file, \"    \");\n\n    for (x = 0; x < linesize; x++)\n    {\n      if (x != 0)\n        fprintf(file, \", \");\n\n      fprintf(file, \"%d\", (int)data[y*linesize+x]);\n    }\n\n    if (y == height-1)\n      fprintf(file, \"};\\n\\n\");\n    else\n      fprintf(file, \",\\n\");\n  }\n\n  if (channels == 1)\n  {\n    int c;\n    char* color;\n\n    fprintf(file, \"  Ihandle* image = IupImage(%d, %d, imgdata);\\n\\n\", width, height);\n\n    for (c = 0; c < 256; c++)\n    {\n      color = IupGetAttributeId(ih, \"\", c);\n      if (!color)\n        break;\n\n      fprintf(file, \"  IupSetAttribute(image, \\\"%d\\\", \\\"%s\\\");\\n\", c, color);\n    }\n\n    fprintf(file, \"\\n\");\n  }\n  else if (channels == 3)\n    fprintf(file, \"  Ihandle* image = IupImageRGB(%d, %d, imgdata);\\n\", width, height);\n  else /* channels == 4 */\n    fprintf(file, \"  Ihandle* image = IupImageRGBA(%d, %d, imgdata);\\n\", width, height);\n\n  fprintf(file, \"  return image;\\n\");\n  fprintf(file, \"}\\n\\n\");\n\n  if (!packfile)\n    fclose(file);\n\n  return 1;\n}\n\nstatic int SaveImageLua(const char* file_name, Ihandle* ih, const char* name, FILE* packfile)\n{\n  int y, x, width, height, channels, linesize;\n  unsigned char* data;\n  FILE* file;\n\n  if (packfile)\n    file = packfile;\n  else\n    file = fopen(file_name, \"wb\");\n\n  if (!file)\n    return 0;\n  \n  width = IupGetInt(ih, \"WIDTH\");\n  height = IupGetInt(ih, \"HEIGHT\");\n  channels = IupGetInt(ih, \"CHANNELS\");\n  linesize = width*channels;\n\n  data = (unsigned char*)IupGetAttribute(ih, \"WID\");\n\n  if (fprintf(file, \"function load_image_%s()\\n\", name)<0)\n  {\n    if (!packfile)\n      fclose(file);\n    return 0;\n  }\n\n  if (channels == 1)\n    fprintf(file, \"  local %s = iup.image\\n\", name);\n  else if (channels == 3)\n    fprintf(file, \"  local %s = iup.imagergb\\n\", name);\n  else /* channels == 4 */\n    fprintf(file, \"  local %s = iup.imagergba\\n\", name);\n\n  fprintf(file, \"  {\\n\");\n\n  fprintf(file, \"    width = %d,\\n\", width);\n  fprintf(file, \"    height = %d,\\n\", height);\n  fprintf(file, \"    pixels = {\\n\");\n\n  for (y = 0; y < height; y++)\n  {\n    fprintf(file, \"      \");\n    for (x = 0; x < linesize; x++)\n    {\n      fprintf(file, \"%d, \", (int)data[y*linesize+x]);\n    }\n    fprintf(file, \"\\n\");\n  }\n\n  fprintf(file, \"    },\\n\");\n\n  if (channels == 1)\n  {\n    int c;\n    char* color;\n    unsigned char r, g, b;\n\n    fprintf(file, \"    colors = {\\n\");\n\n    for(c = 0; c < 256; c++)\n    {\n      color = IupGetAttributeId(ih, \"\", c);\n      if (!color)\n        break;\n\n      if (iupStrEqualNoCase(color, \"BGCOLOR\"))\n        fprintf(file, \"      \\\"BGCOLOR\\\",\\n\");\n      else\n      {\n        iupStrToRGB(color, &r, &g, &b);\n        fprintf(file, \"      \\\"%d %d %d\\\",\\n\", (int)r, (int)g, (int)b);\n      }\n    }\n\n    fprintf(file, \"    }\\n\");\n  }\n\n  fprintf(file, \"  }\\n\");\n\n  fprintf(file, \"  return %s\\n\", name);\n  fprintf(file, \"end\\n\\n\");\n\n  if (!packfile)\n    fclose(file);\n\n  return 1;\n}\n\nstatic int SaveImageLED(const char* file_name, Ihandle* ih, const char* name, FILE* packfile)\n{\n  int y, x, width, height, channels, linesize;\n  unsigned char* data;\n  FILE* file;\n\n  if (packfile)\n    file = packfile;\n  else\n    file = fopen(file_name, \"wb\");\n\n  if (!file)\n    return 0;\n\n  width = IupGetInt(ih, \"WIDTH\");\n  height = IupGetInt(ih, \"HEIGHT\");\n  channels = IupGetInt(ih, \"CHANNELS\");\n  linesize = width*channels;\n\n  data = (unsigned char*)IupGetAttribute(ih, \"WID\");\n\n  if (channels == 1)\n  {\n    int c;\n    unsigned char r, g, b;\n    char* color;\n\n    if (fprintf(file, \"%s = IMAGE\\n\", name)<0)\n    {\n      if (!packfile)\n        fclose(file);\n      return 0;\n    }\n\n    fprintf(file, \"[\\n\");\n    for(c = 0; c < 256; c++)\n    {\n      color = IupGetAttributeId(ih, \"\", c);\n      if (!color)\n      {\n        if (c < 16)\n          continue;\n        else\n          break;\n      }\n\n      if (c != 0)\n        fprintf(file, \",\\n\");\n\n      if (iupStrEqualNoCase(color, \"BGCOLOR\"))\n        fprintf(file, \"  %d = \\\"BGCOLOR\\\"\", c);\n      else\n      {\n        iupStrToRGB(color, &r, &g, &b);\n        fprintf(file, \"  %d = \\\"%d %d %d\\\"\", c, (int)r, (int)g, (int)b);\n      }\n    }\n    fprintf(file, \"\\n]\\n\");\n  }\n  else if (channels == 3)\n  {\n    if (fprintf(file, \"%s = IMAGERGB\\n\", name)<0)\n    {\n      if (!packfile)\n        fclose(file);\n      return 0;\n    }\n  }\n  else /* channels == 4 */\n  {\n    if (fprintf(file, \"%s = IMAGERGBA\\n\", name)<0)\n    {\n      if (!packfile)\n        fclose(file);\n      return 0;\n    }\n  }\n\n  fprintf(file, \"(%d, %d,\\n\", width, height);\n\n  for (y = 0; y < height; y++)\n  {\n    fprintf(file, \"  \");\n    for (x = 0; x < linesize; x++)\n    {\n      if (y == height-1 && x==linesize-1)\n        fprintf(file, \"%d\", (int)data[y*linesize+x]);\n      else\n        fprintf(file, \"%d, \", (int)data[y*linesize+x]);\n    }\n    fprintf(file, \"\\n\");\n  }\n\n  fprintf(file, \")\\n\\n\");\n\n  if (!packfile)\n    fclose(file);\n\n  return 1;\n}\n\nint iupSaveImageAsText(Ihandle* ih, FILE* packfile, const char* format, const char* name)\n{\n  int ret = 0;\n  if (iupStrEqualNoCase(format, \"LED\"))\n    ret = SaveImageLED(NULL, ih, name, packfile);\n  else if (iupStrEqualNoCase(format, \"LUA\"))\n    ret = SaveImageLua(NULL, ih, name, packfile);\n  else if (iupStrEqualNoCase(format, \"C\") || iupStrEqualNoCase(format, \"H\"))\n    ret = SaveImageC(NULL, ih, name, packfile);\n  return ret;\n}\n\nint IupSaveImageAsText(Ihandle* ih, const char* file_name, const char* format, const char* name)\n{\n  int ret = 0;\n  if (!name)\n  {\n    name = IupGetName(ih);\n    if (!name)\n      name = \"image\";\n  }\n  if (iupStrEqualNoCase(format, \"LED\"))\n    ret = SaveImageLED(file_name, ih, name, NULL);\n  else if (iupStrEqualNoCase(format, \"LUA\"))\n    ret = SaveImageLua(file_name, ih, name, NULL);\n  else if (iupStrEqualNoCase(format, \"C\") || iupStrEqualNoCase(format, \"H\"))\n    ret = SaveImageC(file_name, ih, name, NULL);\n  return ret;\n}\n","/** \\file\n * \\brief Manage keys encoding and decoding.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <memory.h>\n#include <stdio.h> \n#include <string.h> \n\n#include \"iup.h\"\n#include \"iupkey.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_key.h\"\n#include \"iup_str.h\"\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_focus.h\"\n#include \"iup_attrib.h\"\n\n\ntypedef struct _IkeyMapASCII {\n  const char* name;\n  unsigned char mod;\n} IkeyMapASCII;\n\nstatic IkeyMapASCII ikey_map_ascii[126-32+1] = {  /* from 32 to 126 (inclusive) */\n  {\"K_SP\",                  0},\n  {\"K_exclam\",              2}, /* NO shift */\n  {\"K_quotedbl\",            2}, /* NO shift */\n  {\"K_numbersign\",          2}, /* NO shift */\n  {\"K_dollar\",              2}, /* NO shift */\n  {\"K_percent\",             2}, /* NO shift */\n  {\"K_ampersand\",           2}, /* NO shift */\n  {\"K_apostrophe\",          2}, /* NO shift */\n  {\"K_parentleft\",          2}, /* NO shift */\n  {\"K_parentright\",         2}, /* NO shift */\n  {\"K_asterisk\",            0},                                 /* when in the numeric keypad have all the modifiers */\n  {\"K_plus\",                0},\n  {\"K_comma\",               0},\n  {\"K_minus\",               0},\n  {\"K_period\",              0},\n  {\"K_slash\",               0},\n  {\"K_0\",                   2}, /* NO shift */\n  {\"K_1\",                   2}, /* NO shift */\n  {\"K_2\",                   2}, /* NO shift */\n  {\"K_3\",                   2}, /* NO shift */\n  {\"K_4\",                   2}, /* NO shift */\n  {\"K_5\",                   2}, /* NO shift */\n  {\"K_6\",                   2}, /* NO shift */\n  {\"K_7\",                   2}, /* NO shift */\n  {\"K_8\",                   2}, /* NO shift */\n  {\"K_9\",                   2}, /* NO shift */\n  {\"K_colon\",               2}, /* NO shift */\n  {\"K_semicolon\",           2}, /* NO shift */\n  {\"K_less\",                2}, /* NO shift */\n  {\"K_equal\",               2}, /* NO shift */\n  {\"K_greater\",             2}, /* NO shift */\n  {\"K_question\",            2}, /* NO shift */\n  {\"K_at\",                  2}, /* NO shift */\n  {\"K_A\",                   2}, /* NO shift */\n  {\"K_B\",                   2}, /* NO shift */\n  {\"K_C\",                   2}, /* NO shift */\n  {\"K_D\",                   2}, /* NO shift */\n  {\"K_E\",                   2}, /* NO shift */\n  {\"K_F\",                   2}, /* NO shift */\n  {\"K_G\",                   2}, /* NO shift */\n  {\"K_H\",                   2}, /* NO shift */\n  {\"K_I\",                   2}, /* NO shift */\n  {\"K_J\",                   2}, /* NO shift */\n  {\"K_K\",                   2}, /* NO shift */\n  {\"K_L\",                   2}, /* NO shift */\n  {\"K_M\",                   2}, /* NO shift */\n  {\"K_N\",                   2}, /* NO shift */\n  {\"K_O\",                   2}, /* NO shift */\n  {\"K_P\",                   2}, /* NO shift */\n  {\"K_Q\",                   2}, /* NO shift */\n  {\"K_R\",                   2}, /* NO shift */\n  {\"K_S\",                   2}, /* NO shift */\n  {\"K_T\",                   2}, /* NO shift */\n  {\"K_U\",                   2}, /* NO shift */\n  {\"K_V\",                   2}, /* NO shift */\n  {\"K_W\",                   2}, /* NO shift */\n  {\"K_X\",                   2}, /* NO shift */\n  {\"K_Y\",                   2}, /* NO shift */\n  {\"K_Z\",                   2}, /* NO shift */\n  {\"K_bracketleft\",         2}, /* NO shift */\n  {\"K_backslash\",           2}, /* NO shift */\n  {\"K_bracketright\",        2}, /* NO shift */\n  {\"K_circum\",              2}, /* NO shift */\n  {\"K_underscore\",          2}, /* NO shift */\n  {\"K_grave\",               2}, /* NO shift */\n  {\"K_a\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_b\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_c\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_d\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_e\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_f\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_g\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_h\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_i\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_j\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_k\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_l\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_m\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_n\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_o\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_p\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_q\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_r\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_s\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_t\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_u\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_v\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_w\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_x\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_y\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_z\",                   1}, /* NO shift,ctrl,alt,sys */\n  {\"K_braceleft\",           2}, /* NO shift */\n  {\"K_bar\",                 2}, /* NO shift */\n  {\"K_braceright\",          2}, /* NO shift */\n  {\"K_tilde\",               2}, /* NO shift */\n};\n\nstatic const char* ikey_map_ext[256];\n\nvoid iupKeyInit(void)\n{\n  memset((void*)ikey_map_ext, 0, 256*sizeof(char*));\n\n  ikey_map_ext[0x0B] = \"K_MIDDLE\";\n  ikey_map_ext[0x13] = \"K_PAUSE\";\n  ikey_map_ext[0x14] = \"K_SCROLL\";\n  ikey_map_ext[0x1B] = \"K_ESC\";\n  ikey_map_ext[0x50] = \"K_HOME\";\n  ikey_map_ext[0x51] = \"K_LEFT\";\n  ikey_map_ext[0x52] = \"K_UP\";\n  ikey_map_ext[0x53] = \"K_RIGHT\";\n  ikey_map_ext[0x54] = \"K_DOWN\";\n  ikey_map_ext[0x55] = \"K_PGUP\";\n  ikey_map_ext[0x56] = \"K_PGDN\";\n  ikey_map_ext[0x57] = \"K_END\";\n  ikey_map_ext[0x61] = \"K_Print\";\n  ikey_map_ext[0x63] = \"K_INS\";\n  ikey_map_ext[0x67] = \"K_Menu\";\n  ikey_map_ext[0x7F] = \"K_NUM\";   \n\n  ikey_map_ext[0xBE] = \"K_F1\";\n  ikey_map_ext[0xBF] = \"K_F2\";\n  ikey_map_ext[0xC0] = \"K_F3\";\n  ikey_map_ext[0xC1] = \"K_F4\";\n  ikey_map_ext[0xC2] = \"K_F5\";\n  ikey_map_ext[0xC3] = \"K_F6\";\n  ikey_map_ext[0xC4] = \"K_F7\";\n  ikey_map_ext[0xC5] = \"K_F8\";\n  ikey_map_ext[0xC6] = \"K_F9\";\n  ikey_map_ext[0xC7] = \"K_F10\";\n  ikey_map_ext[0xC8] = \"K_F11\";\n  ikey_map_ext[0xC9] = \"K_F12\";       \n\n  ikey_map_ext[0xE1] = \"K_LSHIFT\";\n  ikey_map_ext[0xE2] = \"K_RSHIFT\"; \n  ikey_map_ext[0xE3] = \"K_LCTRL\";  \n  ikey_map_ext[0xE4] = \"K_RCTRL\"; \n  ikey_map_ext[0xE5] = \"K_CAPS\"; \n  ikey_map_ext[0xE9] = \"K_LALT\";   \n  ikey_map_ext[0xEA] = \"K_RALT\";      \n\n  ikey_map_ext[0xFF] = \"K_DEL\";\n}\n\nstatic const char* iKeyBaseCodeToName(int code, unsigned char *mod)\n{\n  *mod = 0;  /* all modifiers */\n  if (code == K_BS)\n    return \"K_BS\";\n  if (code == K_TAB)\n    return \"K_TAB\";\n  if (code == K_CR)\n    return \"K_CR\";\n  if (code < 32 || code==127)\n    return NULL;\n  if (code >= 32 && code <= 126)\n  {\n    *mod = ikey_map_ascii[code-32].mod;\n    return ikey_map_ascii[code-32].name;\n  }\n  if (code <= 0xFFFF && ((0xFF00&code) == 0xFF00))\n  {\n    if (ikey_map_ext[0x00FF&code])\n    {\n      if ((code >= K_LSHIFT && code <= K_RALT) ||\n           code == K_NUM || code == K_SCROLL)\n        *mod = 1;  /* NO shift,ctrl,alt,sys */\n      return ikey_map_ext[0x00FF&code];\n    }\n  }\n  if (code == K_ccedilla)\n  {\n    *mod = 1; /* NO shift,ctrl,alt,sys */\n    return \"K_ccedilla\";\n  }\n  if (code == K_Ccedilla)\n  {\n    *mod = 2; /* NO shift */\n    return \"K_Ccedilla\";\n  }\n  if (code == K_acute)\n  {\n    *mod = 1; /* NO shift,ctrl,alt,sys */\n    return \"K_acute\";\n  }\n  if (code == K_diaeresis)\n  {\n    *mod = 1; /* NO shift,ctrl,alt,sys */\n    return \"K_diaeresis\";\n  }\n  return NULL;\n}\n\n#define iStrUpper(_c)  ((_c >= 'a' && _c <= 'z')? (_c - 'a') + 'A': _c)\n\n#define iKeyMakeXName(_name, _prefix, _base_name) \\\n{                                                 \\\n  strcpy(_name, _prefix);                         \\\n  _name[3] = iStrUpper(_base_name[2]);            \\\n  strcpy(_name+4, _base_name+3);                  \\\n}\n\n#define iKeyReturnXName(_prefix, _base_name) \\\n{                                            \\\n  static char name[30];                      \\\n  iKeyMakeXName(name, _prefix, _base_name);  \\\n  return name;                               \\\n}\n\nchar* iupKeyCodeToName(int code)\n{\n  unsigned char mod = 0;\n  const char* base_name;\n\n  if (code <= 0)\n    return NULL;\n  \n  base_name = iKeyBaseCodeToName(iup_XkeyBase(code), &mod);\n  if (!base_name)\n  {\n    static char code_name[30];\n    sprintf(code_name, \"K_0x%X\", iup_XkeyBase(code));\n    base_name = code_name;\n  }\n\n  if (iup_XkeyBase(code)==code)  /* no modifiers */\n    return (char*)base_name;\n\n  if (iup_isShiftXkey(code) && mod==0)\n    iKeyReturnXName(\"K_s\", base_name);\n\n  if (mod==1)\n    return (char*)base_name;\n\n  if (iup_isCtrlXkey(code)) \n    iKeyReturnXName(\"K_c\", base_name);\n  if (iup_isAltXkey(code))  \n    iKeyReturnXName(\"K_m\", base_name);\n  if (iup_isSysXkey(code))\n    iKeyReturnXName(\"K_y\", base_name);\n\n  return (char*)base_name;\n}\n\nstatic void iKeyCallFunc(void (*func)(const char *name, int code, void* user_data), void* user_data, const char *name, int code, unsigned char mod)\n{\n  char mod_name[30];\n\n  func(name, code, user_data);\n\n  if (mod==0)\n  {\n    iKeyMakeXName(mod_name, \"K_s\", name);\n    func(mod_name, iup_XkeyShift(code), user_data);\n  }\n\n  if (mod!=1) \n  {\n    iKeyMakeXName(mod_name, \"K_c\", name);\n    func(mod_name, iup_XkeyCtrl(code), user_data);\n\n    iKeyMakeXName(mod_name, \"K_m\", name);\n    func(mod_name, iup_XkeyAlt(code), user_data);\n\n    iKeyMakeXName(mod_name, \"K_y\", name);\n    func(mod_name, iup_XkeySys(code), user_data);\n  }\n}\n\nvoid iupKeyForEach(void (*func)(const char *name, int code, void* user_data), void* user_data)\n{\n  /* Used only by the IupLua binding. */\n  int code, map;\n\n  iKeyCallFunc(func, user_data, \"K_BS\", K_BS, 0);\n  iKeyCallFunc(func, user_data, \"K_TAB\", K_TAB, 0);\n  iKeyCallFunc(func, user_data, \"K_CR\", K_CR, 0);\n\n  for (code=32; code <= 126; code++)\n    iKeyCallFunc(func, user_data, ikey_map_ascii[code-32].name, code, ikey_map_ascii[code-32].mod);\n\n  for (map=0; map < 256; map++)\n  {\n    if (ikey_map_ext[map])\n    {\n      unsigned char mod = 0;\n\n      if (((0xFF00|map) >= K_LSHIFT && (0xFF00|map) <= K_RALT) ||\n           (0xFF00|map) == K_NUM || (0xFF00|map) == K_SCROLL)\n        mod=1;  /* NO shift,ctrl,alt,sys */\n\n      iKeyCallFunc(func, user_data, ikey_map_ext[map], 0xFF00|map, mod);\n    }\n  }\n\n  iKeyCallFunc(func, user_data, \"K_ccedilla\", K_ccedilla, 1);  /* NO modifiers */\n  iKeyCallFunc(func, user_data, \"K_Ccedilla\", K_Ccedilla, 2);  /* NO shift */\n\n  iKeyCallFunc(func, user_data, \"K_acute\", K_acute, 1);\n  iKeyCallFunc(func, user_data, \"K_diaeresis\", K_diaeresis, 1);\n}\n\nint iupKeyCallKeyCb(Ihandle *ih, int code)\n{\n  char* name = iupKeyCodeToName(code);\n  for (; ih; ih = ih->parent)\n  {\n    IFni cb = NULL;\n    if (name)\n      cb = (IFni)IupGetCallback(ih, name);\n    if (!cb)\n      cb = (IFni)IupGetCallback(ih, \"K_ANY\");\n\n    if (cb)\n    {\n      int ret = cb(ih, code);\n      if (ret != IUP_CONTINUE)\n        return ret;\n    }\n  }\n  return IUP_DEFAULT;\n}\n\nint iupKeyCallKeyPressCb(Ihandle *ih, int code, int press)\n{\n  IFnii cb = (IFnii)IupGetCallback(ih, \"KEYPRESS_CB\");\n  if (cb) return cb(ih, code, press);\n  return IUP_DEFAULT;\n}\n\nint iupKeyProcessNavigation(Ihandle* ih, int code, int shift)\n{\n  /* this is called after K_ANY is processed, \n     so the user may change its behavior */\n\n  if (code == K_cTAB)\n  {\n    int is_multiline = iupAttribGetInt(ih, \"_IUP_MULTILINE_TEXT\");\n    if (is_multiline)\n    {\n      if (shift)\n        IupPreviousField(ih);\n      else\n        IupNextField(ih);\n      return 1;\n    }\n  }\n  else if (code == K_TAB || code == K_sTAB)\n  {\n    int is_multiline = iupAttribGetInt(ih, \"_IUP_MULTILINE_TEXT\");\n    if (!is_multiline)\n    {\n      if (code == K_sTAB || shift)\n        IupPreviousField(ih);\n      else\n        IupNextField(ih);\n      return 1;\n    }\n  }\n  else if (code == K_UP || code == K_DOWN)\n  {\n    int is_button = (IupClassMatch(ih, \"button\") || \n                     IupClassMatch(ih, \"toggle\"));\n    if (is_button)\n    {\n      if (code == K_UP)\n        iupFocusPrevious(ih);\n      else\n        iupFocusNext(ih);\n      return 1;\n    }\n  }\n  else if (code==K_ESC)\n  {\n    Ihandle* bt = IupGetAttributeHandle(IupGetDialog(ih), \"DEFAULTESC\");\n    if (iupObjectCheck(bt) && IupClassMatch(bt, \"button\"))\n      iupdrvActivate(bt);\n    return 1;\n  }\n  else if (code==K_CR || code==K_cCR)\n  {\n    int is_multiline = iupAttribGetInt(ih, \"_IUP_MULTILINE_TEXT\");\n    if ((code==K_CR && !is_multiline) || (code==K_cCR && is_multiline))\n    {\n      Ihandle* bt = IupGetAttributeHandle(IupGetDialog(ih), \"DEFAULTENTER\");\n      if (iupObjectCheck(bt) && IupClassMatch(bt, \"button\"))\n        iupdrvActivate(bt);\n      return 1;\n    }\n  }\n  else if (iup_isCtrlXkey(code) && iup_isShiftXkey(code) && iup_isAltXkey(code) && iup_XkeyBase(code) == K_L)\n  {\n    /* Ctrl+Shift+Alt+L */\n    IupShow(IupLayoutDialog(IupGetDialog(ih)));\n  }\n\n  return 0;\n}\n\nint iupKeyProcessMnemonic(Ihandle* ih, int code)\n{\n  Ihandle *ih_mnemonic, *dialog = IupGetDialog(ih);\n  char attrib[16] = \"_IUP_MNEMONIC_ \";\n  attrib[14] = (char)code;\n  iupStrUpper(attrib, attrib);\n  ih_mnemonic = (Ihandle*)IupGetAttribute(dialog, attrib);\n  if (iupObjectCheck(ih_mnemonic))\n  {\n    if (IupClassMatch(ih_mnemonic, \"label\"))\n    {\n      Ihandle* ih_next = iupFocusNextInteractive(ih_mnemonic);\n      if (ih_next)\n      {\n        if (IupClassMatch(ih_next, \"button\") || IupClassMatch(ih_next, \"toggle\"))\n          iupdrvActivate(ih_next);\n        else\n          IupSetFocus(ih_next);\n      }\n    }\n    else if (IupClassMatch(ih_mnemonic, \"tabs\"))\n      IupSetAttribute(ih_mnemonic, \"VALUEPOS\", IupGetAttribute(ih_mnemonic, attrib));\n    else if (ih_mnemonic->handle)  /* button or toggle */\n      iupdrvActivate(ih_mnemonic);\n\n    return 1;\n  }\n\n  return 0;\n}\n\nvoid iupKeySetMnemonic(Ihandle* ih, int code, int pos)\n{\n  Ihandle* ih_dialog = IupGetDialog(ih);\n  char attrib[16] = \"_IUP_MNEMONIC_ \";\n  attrib[14] = (char)code;\n  iupStrUpper(attrib, attrib);\n\n  IupSetAttribute(ih_dialog, attrib, (char*)ih);\n  if (IupClassMatch(ih, \"tabs\"))\n    IupSetInt(ih, attrib, pos);\n}\n","/** \\file\n * \\brief Label Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_label.h\"\n#include \"iup_image.h\"\n\n\nstatic int iLabelSetSeparatorAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (value)\n  {\n    if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    {\n      if (!(ih->expand & IUP_EXPAND_WIDTH))\n        ih->expand = IUP_EXPAND_WFREE;\n    }\n    else if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    {\n      if (!(ih->expand & IUP_EXPAND_HEIGHT))\n        ih->expand = IUP_EXPAND_HFREE;\n    }\n    else\n      return 0;\n  }\n\n  return 1;\n}\n\nstatic char* iLabelGetSeparatorAttrib(Ihandle* ih)\n{\n  if (ih->handle)\n  {\n    if (ih->data->type == IUP_LABEL_SEP_HORIZ)\n      return \"HORIZONTAL\";\n    else if (ih->data->type == IUP_LABEL_SEP_VERT)\n      return \"VERTICAL\";\n  }\n  return NULL;\n}\n\nint iupLabelGetTypeBeforeMap(Ihandle* ih)\n{\n  int type = ih->data->type;\n\n  if (!ih->handle)\n  {\n    /* if not mapped must initialize the internal values */\n    char* value = iupAttribGet(ih, \"SEPARATOR\");\n    if (value)\n    {\n      if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n        type = IUP_LABEL_SEP_HORIZ;\n      else /* \"VERTICAL\" */\n        type = IUP_LABEL_SEP_VERT;\n    }\n    else\n    {\n      value = iupAttribGet(ih, \"IMAGE\");\n      if (value)\n        type = IUP_LABEL_IMAGE;\n      else\n        type = IUP_LABEL_TEXT;\n    }\n  }\n\n  return type;\n}\n\nchar* iupLabelGetPaddingAttrib(Ihandle* ih)\n{\n  /* this method can be called before map */\n  int type = iupLabelGetTypeBeforeMap(ih);\n  if (type != IUP_LABEL_SEP_HORIZ && type != IUP_LABEL_SEP_VERT)\n    return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n  else\n    return NULL;\n}\n\n\n/**************************************************************************************/\n\n\nstatic int iLabelCreateMethod(Ihandle* ih, void** params)\n{\n  if (params && params[0])\n    iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n  \n  ih->data = iupALLOCCTRLDATA();\n\n  /* used only by the Windows driver */\n  ih->data->vert_alignment = IUP_ALIGN_ACENTER;\n  return IUP_NOERROR;\n}\n\nstatic void iLabelComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0, \n      type = iupLabelGetTypeBeforeMap(ih);\n  (void)children_expand; /* unset if not a container */\n\n  if (type == IUP_LABEL_SEP_HORIZ)\n    natural_h = 2;\n  else if (type == IUP_LABEL_SEP_VERT)\n    natural_w = 2;\n  else if (type == IUP_LABEL_IMAGE)\n  {\n    iupImageGetInfo(iupAttribGet(ih, \"IMAGE\"), &natural_w, &natural_h, NULL);\n\n    natural_w += 2*ih->data->horiz_padding;\n    natural_h += 2*ih->data->vert_padding;\n  }\n  else /* IUP_LABEL_TEXT */\n  {\n    /* must use IupGetAttribute to check from the native implementation */\n    char* title = IupGetAttribute(ih, \"TITLE\");\n    char* str = iupStrProcessMnemonic(title, NULL, 0);   /* remove & */\n    iupdrvFontGetMultiLineStringSize(ih, str, &natural_w, &natural_h);\n    if (str && str!=title) free(str);\n\n    natural_w += 2*ih->data->horiz_padding;\n    natural_h += 2*ih->data->vert_padding;\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupLabel(const char* title)\n{\n  void *params[2];\n  params[0] = (void*)title;\n  params[1] = NULL;\n  return IupCreatev(\"label\", params);\n}\n\nIclass* iupLabelNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"label\";\n  ic->format = \"s\"; /* one string */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupLabelNewClass;\n  ic->Create = iLabelCreateMethod;\n  ic->ComputeNaturalSize = iLabelComputeNaturalSizeMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Manually register the Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"ENTERWINDOW_CB\", \"\");\n  iupClassRegisterCallback(ic, \"LEAVEWINDOW_CB\", \"\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* IupLabel only */\n  iupClassRegisterAttribute(ic, \"SEPARATOR\", iLabelGetSeparatorAttrib, iLabelSetSeparatorAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvLabelInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief Abstract Layout Management\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>  \n#include <stdio.h>  \n#include <stdarg.h>  \n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_layout.h\"\n#include \"iup_assert.h\" \n\n \nvoid IupRefreshChildren(Ihandle* ih)\n{\n  int shrink;\n  Ihandle *dialog, *child;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  /* must be mapped */\n  if (!ih->handle)\n    return;\n\n  /* must have children */\n  if (!ih->firstchild)\n    return;\n\n  /* must be inside a dialog */\n  /* it can not be a dialog */\n  dialog = IupGetDialog(ih);\n  if (!dialog || dialog==ih)\n    return;\n\n  /****** local iupLayoutCompute,\n     but ih will not be changed, only its children. */\n\n  shrink = iupAttribGetBoolean(dialog, \"SHRINK\");\n\n  /* children only iupBaseComputeNaturalSize */\n  {\n    int w=0, h=0, children_expand=ih->expand;\n    iupClassObjectComputeNaturalSize(ih, &w, &h, &children_expand);\n\n    /* If the container natural size changed from inside, simply ignore the change */\n  }\n\n  /* children only iupBaseSetCurrentSize */\n  iupClassObjectSetChildrenCurrentSize(ih, shrink);\n\n  /* children only iupBaseSetPosition */\n  iupClassObjectSetChildrenPosition(ih, ih->x, ih->y);\n\n\n  /****** local iupLayoutUpdate,\n     but ih will not be changed, only its children. */\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (child->handle)\n      iupLayoutUpdate(child);\n  }\n}\n\nvoid IupRefresh(Ihandle* ih)\n{\n  Ihandle* dialog;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  dialog = IupGetDialog(ih);\n  if (dialog)\n  {\n    iupLayoutCompute(dialog);\n\n    if (dialog->handle)\n      iupLayoutUpdate(dialog);\n  }\n}\n\nvoid IupUpdate(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (ih->handle && ih->iclass->nativetype != IUP_TYPEVOID)\n    iupdrvPostRedraw(ih);\n}\n\nstatic void iLayoutDisplayUpdateChildren(Ihandle *ih)\n{\n  Ihandle* child;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    iLayoutDisplayUpdateChildren(child);\n    IupUpdate(child);\n  }\n}\n\nvoid IupUpdateChildren(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  iLayoutDisplayUpdateChildren(ih);\n}\n\nstatic void iLayoutDisplayRedrawChildren(Ihandle *ih)\n{\n  Ihandle* child;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    iLayoutDisplayRedrawChildren(child);\n\n    if (child->handle && child->iclass->nativetype != IUP_TYPEVOID)\n      iupdrvRedrawNow(child);\n  }\n}\n\nvoid IupRedraw(Ihandle* ih, int children)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (ih->handle && ih->iclass->nativetype != IUP_TYPEVOID)\n    iupdrvRedrawNow(ih);\n\n  if (children)\n    iLayoutDisplayRedrawChildren(ih);\n}\n\nvoid iupLayoutUpdate(Ihandle* ih)\n{\n  Ihandle* child;\n\n  if (ih->flags & IUP_FLOATING_IGNORE)\n    return;\n\n  /* update size and position of the native control */\n  iupClassObjectLayoutUpdate(ih);\n\n  /* update its children */\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (child->handle)\n      iupLayoutUpdate(child);\n  }\n}\n\nvoid iupLayoutCompute(Ihandle* ih)\n{\n  /* usually called only for the dialog */\n\n  int shrink = iupAttribGetBoolean(ih, \"SHRINK\");\n\n  /* Compute the natural size for all elements in the dialog,   \n     using the minimum visible size and the defined user size.\n     The minimum visible size is the size where all the controls can display\n     all their contents.\n     The defined user size is used to increase the value of the minimum visible size for containers,\n     for standard controls will replace the minimum visible size.\n     So the native size will be the maximum value between \n     minimum visible size and defined user size.\n     Also calculates the expand configuration for each element, but expand is used only in SetChildrenCurrentSize.\n     SEQUENCE: will first calculate the native size for the children, then for the element. */\n  iupBaseComputeNaturalSize(ih);\n\n  /* Set the current size (not reflected in the native element yet) based on\n     the natural size and the expand configuration. \n     If shrink is 0 (default) the current size of containers can be only larger than the natural size,\n     the result will depend on the EXPAND attribute.\n     If shrink is 1 the containers can be resized to sizes smaller than the natural size.\n     SEQUENCE: will first calculate the current size of the element, then for the children. */\n  iupBaseSetCurrentSize(ih, 0, 0, shrink);\n\n  /* Now that the current size is known, set the position of the elements \n     relative to the parent.\n     SEQUENCE: will first set the position of the element, then for the children. */\n  iupBaseSetPosition(ih, 0, 0);\n}\n\nvoid iupLayoutApplyMinMaxSize(Ihandle* ih, int *w, int *h)\n{\n  if (ih->flags & IUP_MINSIZE)\n  {\n    char* value = iupAttribGet(ih, \"MINSIZE\");\n    int min_w = 0, min_h = 0;          /* MINSIZE default value */\n    iupStrToIntInt(value, &min_w, &min_h, 'x');\n    if (w && *w < min_w) *w = min_w;\n    if (h && *h < min_h) *h = min_h;\n  }\n\n  if (ih->flags & IUP_MAXSIZE)\n  {\n    char* value = iupAttribGet(ih, \"MAXSIZE\");\n    int max_w = 65535, max_h = 65535;  /* MAXSIZE default value */\n    iupStrToIntInt(value, &max_w, &max_h, 'x');\n    if (w && *w > max_w) *w = max_w;\n    if (h && *h > max_h) *h = max_h;\n  }\n}\n\nvoid iupBaseComputeNaturalSize(Ihandle* ih)\n{\n  /* always initialize the natural size using the user size */\n  ih->naturalwidth = ih->userwidth;\n  ih->naturalheight = ih->userheight;\n\n  if (ih->iclass->childtype != IUP_CHILDNONE || \n      ih->iclass->nativetype == IUP_TYPEDIALOG)  /* pre-defined dialogs can restrict the number of children */\n  {\n    int w=0, h=0, children_expand=0;  /* if there is no children will not expand, when not a dialog */\n\n    /* If a container then update the \"expand\" member from the EXPAND attribute.\n       The ih->expand member can not be used for the container attribute because\n       it is used to combine the container value with the children value. */\n    iupBaseContainerUpdateExpand(ih);\n\n    /* for containers always compute */\n    iupClassObjectComputeNaturalSize(ih, &w, &h, &children_expand);\n\n    if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n    {\n      /* only update the natural size if user size is not defined. */\n      /* IupDialog is the only container where this must be done */ \n      /* if the natural size is bigger than the actual dialog size then\n         the dialog will be resized, if smaller then the dialog remains with the same size. */\n      ih->expand |= children_expand;\n      if (ih->naturalwidth <= 0) ih->naturalwidth = iupMAX(ih->currentwidth, w);\n      if (ih->naturalheight <= 0) ih->naturalheight = iupMAX(ih->currentheight, h);\n    }\n    else\n    {\n      /* combine to only expand if the children can expand */\n      ih->expand &= children_expand; \n      ih->naturalwidth = iupMAX(ih->naturalwidth, w);\n      ih->naturalheight = iupMAX(ih->naturalheight, h);\n    }\n  }\n  else \n  {\n    /* for non-container only compute if user size is not defined */\n    if (ih->naturalwidth <= 0 || ih->naturalheight <= 0)\n    {\n      int w=0, h=0, \n          children_expand;  /* unused if not a container */\n      iupClassObjectComputeNaturalSize(ih, &w, &h, &children_expand);\n\n      if (ih->naturalwidth <= 0) ih->naturalwidth = w;\n      if (ih->naturalheight <= 0) ih->naturalheight = h;\n    }\n  }\n\n  /* crop the natural size */\n  iupLayoutApplyMinMaxSize(ih, &(ih->naturalwidth), &(ih->naturalheight));\n}\n\nvoid iupBaseSetCurrentSize(Ihandle* ih, int w, int h, int shrink)\n{\n  if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n  {\n    /* w and h parameters here are ignored, because they are always 0 for the dialog. */\n\n    /* current size is zero before map and when reset by the application */\n    /* after that the current size must follow the actual size of the dialog */\n    if (!ih->currentwidth)  ih->currentwidth  = ih->naturalwidth;\n    if (!ih->currentheight) ih->currentheight = ih->naturalheight;\n  }\n  else\n  {\n    if (ih->iclass->childtype != IUP_CHILDNONE && !shrink)\n    {\n      /* shrink is only used by containers, usually is 0 */\n      /* for non containers is always 1, so they always can be smaller than the natural size */\n      w = iupMAX(ih->naturalwidth, w);\n      h = iupMAX(ih->naturalheight, h);\n    }\n\n    /* if expand use the given size, else use the natural size */\n    ih->currentwidth = (ih->expand & IUP_EXPAND_WIDTH || ih->expand & IUP_EXPAND_WFREE) ? w : ih->naturalwidth;\n    ih->currentheight = (ih->expand & IUP_EXPAND_HEIGHT || ih->expand & IUP_EXPAND_HFREE) ? h : ih->naturalheight;\n  }\n\n  /* crop also the current size if some expanded */\n  if (ih->expand & IUP_EXPAND_WIDTH || ih->expand & IUP_EXPAND_HEIGHT ||\n      ih->expand & IUP_EXPAND_WFREE || ih->expand & IUP_EXPAND_HFREE)\n    iupLayoutApplyMinMaxSize(ih, &(ih->currentwidth), &(ih->currentheight));\n\n  if (ih->firstchild)\n    iupClassObjectSetChildrenCurrentSize(ih, shrink);\n}\n\nvoid iupBaseSetPosition(Ihandle* ih, int x, int y)\n{\n  ih->x = x;\n  ih->y = y;\n\n  if (ih->firstchild)\n    iupClassObjectSetChildrenPosition(ih, x, y);\n}\n","/** \\file\n * \\brief Link Button Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n\n\nstatic int iLinkButton_CB(Ihandle* ih, int button, int pressed, int x, int y, char* status)\n{\n  if (button==IUP_BUTTON1 && pressed)\n  {\n    IFns cb = (IFns)IupGetCallback(ih, \"ACTION\");\n    char* url = iupAttribGetStr(ih, \"URL\");\n    if (cb)\n    {\n      int ret = cb(ih, url);\n      if (ret == IUP_CLOSE) \n        IupExitLoop();\n      else if (ret == IUP_DEFAULT && url)\n        IupHelp(url);\n    }\n    else\n      IupHelp(url);\n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iLinkEnterWindow_CB(Ihandle* ih)\n{\n  IupSetAttribute(ih, \"CURSOR\", \"HAND\");\n  return IUP_DEFAULT;\n}\n\nstatic int iLinkLeaveWindow_CB(Ihandle* ih)\n{\n  IupSetAttribute(ih, \"CURSOR\", \"ARROW\");\n  return IUP_DEFAULT;\n}\n\nstatic int iLinkMapMethod(Ihandle* ih)\n{\n  IupSetAttribute(ih, \"FONTSTYLE\", \"Underline\");\n  return IUP_NOERROR;\n}\n\nstatic int iLinkCreateMethod(Ihandle* ih, void **params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"URL\", (char*)(params[0]));\n    if (params[1]) iupAttribSetStr(ih, \"TITLE\", (char*)(params[1]));\n  }\n\n  IupSetCallback(ih, \"BUTTON_CB\", (Icallback)iLinkButton_CB);\n  IupSetCallback(ih, \"ENTERWINDOW_CB\", iLinkEnterWindow_CB);\n  IupSetCallback(ih, \"LEAVEWINDOW_CB\", iLinkLeaveWindow_CB);\n\n  return IUP_NOERROR; \n}\n\nIclass* iupLinkNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"label\"));\n\n  ic->name = \"link\";\n  ic->format = \"ss\"; /* two strings */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupLinkNewClass;\n  ic->Create = iLinkCreateMethod;\n  ic->Map = iLinkMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"ACTION\", \"s\");\n\n  /* attributes */\n  iupClassRegisterAttribute(ic, \"URL\", NULL, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CURSOR\", NULL, iupdrvBaseSetCursorAttrib, IUPAF_SAMEASSYSTEM, \"ARROW\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n\n  iupClassRegisterReplaceAttribDef(ic, \"FGCOLOR\", \"LINKFGCOLOR\", NULL);\n\n  return ic;\n}\n\nIhandle *IupLink(const char *url, const char * title)\n{\n  void *params[3];\n  params[0] = (void*)url;\n  params[1] = (void*)title;\n  params[2] = NULL;\n  return IupCreatev(\"link\", params);\n}\n","/** \\file\n * \\brief List Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_assert.h\"\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_mask.h\"\n#include \"iup_image.h\"\n#include \"iup_list.h\"\n\n\nvoid iupListSingleCallDblClickCb(Ihandle* ih, IFnis cb, int pos)\n{\n  char *text;\n\n  if (pos<=0)\n    return;\n\n  text = IupGetAttributeId(ih, \"\", pos);\n\n  if (cb(ih, pos, text) == IUP_CLOSE)\n    IupExitLoop();\n}\n\nstatic void iListCallActionCallback(Ihandle* ih, IFnsii cb, int pos, int state)\n{\n  char *text;\n\n  if (pos<=0)\n    return;\n\n  text = IupGetAttributeId(ih, \"\", pos);\n\n  if (cb(ih, text, pos, state) == IUP_CLOSE)\n    IupExitLoop();\n}\n\nvoid iupListUpdateOldValue(Ihandle* ih, int pos, int removed)\n{\n  if (!ih->data->has_editbox)\n  {\n    char* old_value = iupAttribGet(ih, \"_IUPLIST_OLDVALUE\");\n    if (old_value)\n    {\n      int old_pos = atoi(old_value)-1; /* was in IUP reference, starting at 1 */\n      if (ih->data->is_dropdown || !ih->data->is_multiple)\n      {\n        if (old_pos >= pos)\n        {\n          if (removed && old_pos == pos)\n          {\n            /* when the current item is removed nothing remains selected */\n            iupAttribSet(ih, \"_IUPLIST_OLDVALUE\", NULL);\n          }\n          else\n            iupAttribSetInt(ih, \"_IUPLIST_OLDVALUE\", removed? old_pos-1: old_pos+1);\n        }\n      }\n      else\n      {\n        /* multiple selection on a non drop-down list. */\n        char* value = IupGetAttribute(ih, \"VALUE\");\n        iupAttribSetStr(ih, \"_IUPLIST_OLDVALUE\", value);\n      }\n    }\n  }\n}\n\nvoid iupListSingleCallActionCb(Ihandle* ih, IFnsii cb, int pos)\n{\n  char* old_str = iupAttribGet(ih, \"_IUPLIST_OLDVALUE\");\n  if (old_str)\n  {\n    int oldpos = atoi(old_str);\n    if (oldpos != pos)\n    {\n      iListCallActionCallback(ih, cb, oldpos, 0);\n      iupAttribSetInt(ih, \"_IUPLIST_OLDVALUE\", pos);\n      iListCallActionCallback(ih, cb, pos, 1);\n    }\n  }\n  else\n  {\n    iupAttribSetInt(ih, \"_IUPLIST_OLDVALUE\", pos);\n    iListCallActionCallback(ih, cb, pos, 1);\n  }\n}\n\nvoid iupListMultipleCallActionCb(Ihandle* ih, IFnsii cb, IFns multi_cb, int* pos, int sel_count)\n{\n  int i, count = iupdrvListGetCount(ih);\n\n  char* old_str = iupAttribGet(ih, \"_IUPLIST_OLDVALUE\");\n  int old_count = old_str? (int)strlen(old_str): 0;\n\n  char* str = malloc(count+1);\n  memset(str, '-', count);\n  str[count]=0;\n  for (i=0; i<sel_count; i++)\n    str[pos[i]] = '+';\n\n  if (old_count != count)\n  {\n    old_count = 0;\n    old_str = NULL;\n  }\n\n  if (multi_cb)\n  {\n    int unchanged = 1;\n\n    for (i=0; i<count && old_str; i++)\n    {\n      if (str[i] == old_str[i])\n        str[i] = 'x';    /* mark unchanged values */\n      else\n        unchanged = 0;\n    }\n\n    if (old_str && unchanged)\n    {\n      free(str);\n      return;\n    }\n\n    if (multi_cb(ih, str) == IUP_CLOSE)\n      IupExitLoop();\n\n    for (i=0; i<count && old_str; i++)\n    {\n      if (str[i] == 'x')\n        str[i] = old_str[i];    /* restore unchanged values */\n    }\n  }\n  else\n  {\n    /* must simulate the click on each item */\n    for (i=0; i<count; i++)\n    {\n      if (i >= old_count)  /* new items, if selected then call the callback */\n      {\n        if (str[i] == '+')\n          iListCallActionCallback(ih, cb, i+1, 1);\n      }\n      else if (str[i] != old_str[i])\n      {\n        if (str[i] == '+')\n          iListCallActionCallback(ih, cb, i+1, 1);\n        else\n          iListCallActionCallback(ih, cb, i+1, 0);\n      }\n    }\n  }\n\n  iupAttribSetStr(ih, \"_IUPLIST_OLDVALUE\", str);\n  free(str);\n}\n\nint iupListGetPosAttrib(Ihandle* ih, int pos)\n{\n  int count;\n\n  pos--; /* IUP items start at 1 */\n\n  if (pos < 0) \n    return -1;\n\n  count = iupdrvListGetCount(ih);\n\n  if (pos == count) return -2;\n  if (pos > count) return -1;\n\n  return pos;\n}\n\nvoid iupListSetInitialItems(Ihandle* ih)\n{\n  char *value;\n  int i = 1;\n  while ((value = iupAttribGetId(ih, \"\", i))!=NULL)\n  {\n    iupdrvListAppendItem(ih, value);\n    iupAttribSetId(ih, \"\", i, NULL);\n\n    i++;\n  }\n}\n\nchar* iupListGetSpacingAttrib(Ihandle* ih)\n{\n  if (!ih->data->is_dropdown)\n    return iupStrReturnInt(ih->data->spacing);\n  else\n    return NULL;\n}\n\nchar* iupListGetPaddingAttrib(Ihandle* ih)\n{\n  if (ih->data->has_editbox)\n    return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n  else\n    return NULL;\n}\n\nchar* iupListGetNCAttrib(Ihandle* ih)\n{\n  if (ih->data->has_editbox)\n    return iupStrReturnInt(ih->data->nc);\n  else\n    return NULL;\n}\n\nint iupListSetIdValueAttrib(Ihandle* ih, int pos, const char* value)\n{\n  int count = iupdrvListGetCount(ih);\n\n  pos--; /* IUP starts at 1 */\n\n  if (!value)\n  {\n    if (pos >= 0 && pos <= count-1)\n    {\n      if (pos == 0)\n      {\n        iupdrvListRemoveAllItems(ih);\n        iupAttribSet(ih, \"_IUPLIST_OLDVALUE\", NULL);\n      }\n      else\n      {\n        int i = pos;\n        while (i < count)\n        {\n          iupdrvListRemoveItem(ih, pos);\n          i++;\n        }\n      }\n    }\n  }\n  else\n  {\n    if (pos >= 0 && pos <= count-1)\n    {\n      iupdrvListRemoveItem(ih, pos);\n      iupdrvListInsertItem(ih, pos, value);\n    }\n    else if (pos == count)\n      iupdrvListAppendItem(ih, value);\n  }\n  return 0;\n}\n\nstatic int iListSetAppendItemAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  if (value)\n    iupdrvListAppendItem(ih, value);\n  return 0;\n}\n\nstatic int iListSetInsertItemAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  if (value)\n  {\n    int pos = iupListGetPosAttrib(ih, id);\n    if (pos >= 0)\n      iupdrvListInsertItem(ih, pos, value);\n    else if (pos == -2)\n      iupdrvListAppendItem(ih, value);\n  }\n  return 0;\n}\n\nstatic int iListSetRemoveItemAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  if (!value || iupStrEqualNoCase(value, \"ALL\"))\n  {\n    iupdrvListRemoveAllItems(ih);\n    iupAttribSet(ih, \"_IUPLIST_OLDVALUE\", NULL);\n  }\n  else\n  {\n    int id;\n    if (iupStrToInt(value, &id))\n    {\n      int pos = iupListGetPosAttrib(ih, id);\n      if (pos >= 0)\n        iupdrvListRemoveItem(ih, pos);\n    }\n  }\n  return 0;\n}\n\nstatic int iListGetCount(Ihandle* ih)\n{\n  int count;\n  if (ih->handle)\n    count = iupdrvListGetCount(ih);\n  else\n  {\n    count = 0;\n    while (iupAttribGetId(ih, \"\", count+1))\n      count++;\n  }\n  return count;\n}\n\nstatic char* iListGetCountAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(iListGetCount(ih));\n}\n\nstatic int iListSetDropdownAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n  {\n    ih->data->is_dropdown = 1;\n    ih->data->is_multiple = 0;\n  }\n  else\n    ih->data->is_dropdown = 0;\n\n  return 0;\n}\n\nstatic char* iListGetDropdownAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_dropdown); \n}\n\nstatic int iListSetMultipleAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n  {\n    ih->data->is_multiple = 1;\n    ih->data->is_dropdown = 0;\n    ih->data->has_editbox = 0;\n  }\n  else\n    ih->data->is_multiple = 0;\n\n  return 0;\n}\n\nstatic char* iListGetMultipleAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_multiple); \n}\n\nstatic int iListSetEditboxAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n  {\n    ih->data->has_editbox = 1;\n    ih->data->is_multiple = 0;\n  }\n  else\n    ih->data->has_editbox = 0;\n\n  return 0;\n}\n\nstatic char* iListGetEditboxAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->has_editbox); \n}\n\nstatic int iListSetScrollbarAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  else if (iupStrBoolean(value))\n    ih->data->sb = 1;\n  else\n    ih->data->sb = 0;\n\n  return 0;\n}\n\nstatic char* iListGetScrollbarAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->sb); \n}\n\nstatic char* iListGetMaskDataAttrib(Ihandle* ih)\n{\n  if (!ih->data->has_editbox)\n    return NULL;\n\n  /* Used only by the OLD iupmask API */\n  return (char*)ih->data->mask;\n}\n\nstatic char* iListGetMaskAttrib(Ihandle* ih)\n{\n  if (!ih->data->has_editbox)\n    return NULL;\n\n  if (ih->data->mask)\n    return iupMaskGetStr(ih->data->mask);\n  else\n    return NULL;\n}\n\nstatic int iListSetValueMaskedAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox)\n    return 0;\n\n  if (value)\n  {\n    if (ih->data->mask && iupMaskCheck(ih->data->mask, value) == 0)\n      return 0; /* abort */\n    IupStoreAttribute(ih, \"VALUE\", value);\n  }\n  return 0;\n}\n\nstatic int iListSetMaskAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox)\n    return 0;\n\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    int casei = iupAttribGetInt(ih, \"MASKCASEI\");\n    Imask* mask = iupMaskCreate(value,casei);\n    if (mask)\n    {\n      if (ih->data->mask)\n        iupMaskDestroy(ih->data->mask);\n\n      ih->data->mask = mask;\n      return 0;\n    }\n  }\n\n  return 0;\n}\n\nstatic int iListSetMaskIntAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox)\n    return 0;\n\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    int min, max;\n\n    if (iupStrToIntInt(value, &min, &max, ':')!=2)\n      return 0;\n\n    mask = iupMaskCreateInt(min,max);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iListSetMaskFloatAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox)\n    return 0;\n\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    float min, max;\n    char* decimal_symbol = iupAttribGet(ih, \"MASKDECIMALSYMBOL\");\n\n    if (iupStrToFloatFloat(value, &min, &max, ':')!=2)\n      return 0;\n\n    mask = iupMaskCreateFloat(min, max, decimal_symbol);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iListSetMaskRealAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox)\n    return 0;\n\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    char* decimal_symbol = iupAttribGet(ih, \"MASKDECIMALSYMBOL\");\n    int positive = 0;\n\n    if (iupStrEqualNoCase(value, \"UNSIGNED\"))\n      positive = 1;\n\n    mask = iupMaskCreateReal(positive, decimal_symbol);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iListSetShowImageAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n    ih->data->show_image = 1;\n  else\n    ih->data->show_image = 0;\n\n  return 0;\n}\n\nstatic char* iListGetShowImageAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->show_image); \n}\n\nint iupListCallDragDropCb(Ihandle* ih, int drag_id, int drop_id, int *is_ctrl)\n{\n  IFniiii cbDragDrop = (IFniiii)IupGetCallback(ih, \"DRAGDROP_CB\");\n  int is_shift = 0;\n  char key[5];\n  iupdrvGetKeyState(key);\n  if (key[0] == 'S')\n    is_shift = 1;\n  if (key[1] == 'C')\n    *is_ctrl = 1;\n  else\n    *is_ctrl = 0;\n\n  /* ignore a drop that will do nothing */\n  if ((*is_ctrl)==0 && (drag_id+1 == drop_id || drag_id == drop_id))\n    return IUP_DEFAULT;\n  if ((*is_ctrl)!=0 && drag_id == drop_id)\n    return IUP_DEFAULT;\n\n  drag_id++;\n  if (drop_id < 0)\n    drop_id = -1;\n  else\n    drop_id++;\n\n  if (cbDragDrop)\n    return cbDragDrop(ih, drag_id, drop_id, is_shift, *is_ctrl);  /* starts at 1 */\n\n  return IUP_CONTINUE; /* allow to move/copy by default if callback not defined */\n}\n\nstatic char* iListGetShowDragDropAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->show_dragdrop); \n}\n\nstatic int iListSetShowDragDropAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n    ih->data->show_dragdrop = 1;\n  else\n    ih->data->show_dragdrop = 0;\n\n  return 0;\n}\n\n\n/*****************************************************************************************/\n\n\nstatic int iListDropData_CB(Ihandle *ih, char* type, void* data, int len, int x, int y)\n{\n  int pos = IupConvertXYToPos(ih, x, y);\n  int is_ctrl = 0;\n  char key[5];\n\n  /* Data is not the pointer, it contains the pointer */\n  Ihandle* ih_source;\n  memcpy((void*)&ih_source, data, len);\n\n  /* A copy operation is enabled with the CTRL key pressed, or else a move operation will occour.\n     A move operation will be possible only if the attribute DRAGSOURCEMOVE is Yes.\n     When no key is pressed the default operation is copy when DRAGSOURCEMOVE=No and move when DRAGSOURCEMOVE=Yes. */\n  iupdrvGetKeyState(key);\n  if (key[1] == 'C')\n    is_ctrl = 1;\n\n  if (ih_source->data->is_multiple)\n  {\n    char *buffer = IupGetAttribute(ih_source, \"VALUE\");\n\n    /* Copy all selected items */\n    int i = 1;  /* IUP starts at 1 */\n    while(buffer[i-1] != '\\0')\n    {\n      if(buffer[i-1] == '+')\n      {\n        iupdrvListInsertItem(ih, pos, IupGetAttribute(ih_source, iupStrReturnInt(i)));\n        iupdrvListSetImageHandle(ih, ++pos, iupdrvListGetImageHandle(ih_source, i));\n      }\n\n      i++;\n    }\n\n    if (IupGetInt(ih_source, \"DRAGSOURCEMOVE\") && !is_ctrl)\n    {\n      /* Remove all item from source if MOVE */\n      i = 1;  /* IUP starts at 1 */\n      while(*buffer != '\\0')\n      {\n        if (*buffer == '+')\n          iupdrvListRemoveItem(ih_source, --i);  /* update index in the source */\n\n        i++;\n        buffer++;\n      }\n    }\n  }\n  else\n  {\n    iupdrvListInsertItem(ih, pos, IupGetAttribute(ih_source, IupGetAttribute(ih_source, \"VALUE\")));\n    iupdrvListSetImageHandle(ih, ++pos, iupdrvListGetImageHandle(ih_source, IupGetInt(ih_source, \"VALUE\")));\n\n    if(IupGetInt(ih_source, \"DRAGSOURCEMOVE\") && !is_ctrl)\n    {\n      int srcPos = iupAttribGetInt(ih_source, \"_IUP_LIST_SOURCEPOS\");\n      iupdrvListRemoveItem(ih_source, --srcPos);  /* IUP starts at 1 */\n    }\n  }\n\n  (void)type;\n  return IUP_DEFAULT;\n}\n\nstatic int iListDragData_CB(Ihandle *ih, char* type, void *data, int len)\n{\n  int pos = iupAttribGetInt(ih, \"_IUP_LIST_SOURCEPOS\");\n  if (pos < 1)\n    return IUP_DEFAULT;\n\n  if (ih->data->is_multiple)\n  {\n    char *buffer = IupGetAttribute(ih, \"VALUE\");\n\n    /* It will not drag all selected items only\n       when the user begins to drag an item not selected.\n       In this case, unmark all and mark only this item.  */\n    if(buffer[pos-1] == '-')\n    {\n      int len = (int)strlen(buffer);\n      IupSetAttribute(ih, \"SELECTION\", \"NONE\");\n      memset(buffer, '-', len);\n      buffer[pos-1] = '+';\n      IupSetAttribute(ih, \"VALUE\", buffer);\n    }\n  }\n  else\n  {\n    /* Single selection */\n    IupSetInt(ih, \"VALUE\", pos);\n  }\n\n  /* Copy source handle */\n  memcpy(data, (void*)&ih, len);\n \n  (void)type;\n  return IUP_DEFAULT;\n}\n\nstatic int iListDragDataSize_CB(Ihandle* ih, char* type)\n{\n  (void)ih;\n  (void)type;\n  return sizeof(Ihandle*);\n}\n\nstatic int iListDragEnd_CB(Ihandle *ih, int del)\n{\n  iupAttribSetInt(ih, \"_IUP_LIST_SOURCEPOS\", 0);\n  (void)del;\n  return IUP_DEFAULT;\n}\n\nstatic int iListDragBegin_CB(Ihandle* ih, int x, int y)\n{\n  int pos = IupConvertXYToPos(ih, x, y);\n  iupAttribSetInt(ih, \"_IUP_LIST_SOURCEPOS\", pos);\n  return IUP_DEFAULT;\n}\n\nstatic int iListSetDragDropListAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n  {\n    /* Register callbacks to enable drag and drop between lists */\n    IupSetCallback(ih, \"DRAGBEGIN_CB\",    (Icallback)iListDragBegin_CB);\n    IupSetCallback(ih, \"DRAGDATASIZE_CB\", (Icallback)iListDragDataSize_CB);\n    IupSetCallback(ih, \"DRAGDATA_CB\",     (Icallback)iListDragData_CB);\n    IupSetCallback(ih, \"DRAGEND_CB\",      (Icallback)iListDragEnd_CB);\n    IupSetCallback(ih, \"DROPDATA_CB\",     (Icallback)iListDropData_CB);\n  }\n  else\n  {\n    /* Unregister callbacks */\n    IupSetCallback(ih, \"DRAGBEGIN_CB\",    NULL);\n    IupSetCallback(ih, \"DRAGDATASIZE_CB\", NULL);\n    IupSetCallback(ih, \"DRAGDATA_CB\",     NULL);\n    IupSetCallback(ih, \"DRAGEND_CB\",      NULL);\n    IupSetCallback(ih, \"DROPDATA_CB\",     NULL);\n  }\n\n  return 1;\n}\n\nstatic char* iListGetValueStringAttrib(Ihandle* ih)\n{\n  if (!ih->data->has_editbox && (ih->data->is_dropdown || !ih->data->is_multiple))\n  {\n    int i = IupGetInt(ih, \"VALUE\");\n    return IupGetAttributeId(ih, \"\", i);\n  }\n  return NULL;\n}\n\nstatic int iListSetValueStringAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->data->has_editbox && (ih->data->is_dropdown || !ih->data->is_multiple))\n  {\n    int i, count = iListGetCount(ih);\n\n    for (i = 1; i <= count; i++)\n    {\n      char* item = IupGetAttributeId(ih, \"\", i);\n      if (iupStrEqual(value, item))\n      {\n        IupSetInt(ih, \"VALUE\", i);\n        return 0;\n      }\n    }\n  }\n\n  return 0;\n}\n\n\n/*****************************************************************************************/\n\n\nstatic int iListCreateMethod(Ihandle* ih, void** params)\n{\n  if (params && params[0])\n    iupAttribSetStr(ih, \"ACTION\", (char*)(params[0]));\n\n  ih->data = iupALLOCCTRLDATA();\n  ih->data->sb = 1;\n\n  return IUP_NOERROR;\n}\n\nstatic void iListGetItemImageInfo(Ihandle *ih, int id, int *img_w, int *img_h)\n{\n  *img_w = 0;\n  *img_h = 0;\n\n  if (!ih->handle)\n  {\n    char *value = iupAttribGetId(ih, \"IMAGE\", id);\n    if (value)\n      iupImageGetInfo(value, img_w, img_h, NULL);\n  }\n  else\n  {\n    void* handle = iupdrvListGetImageHandle(ih, id);\n    if (handle)\n    {\n      int bpp;\n      iupdrvImageGetInfo(handle, img_w, img_h, &bpp);\n    }\n  }\n}\n\nstatic void iListGetNaturalItemsSize(Ihandle *ih, int *w, int *h)\n{\n  char *value;\n  int max_w = 0, max_h = 0;\n  int visiblecolumns, i, \n      count = iListGetCount(ih);\n\n  *w = 0;\n  *h = 0;\n\n  iupdrvFontGetCharSize(ih, w, h);   /* one line height, and one character width */\n\n  visiblecolumns = iupAttribGetInt(ih, \"VISIBLECOLUMNS\");\n  if (visiblecolumns)\n  {\n    *w = iupdrvFontGetStringWidth(ih, \"WWWWWWWWWW\");\n    *w = (visiblecolumns*(*w))/10;\n  }\n  else\n  {\n    int item_w;\n\n    for (i=1; i<=count; i++)\n    {\n      item_w = 0;\n\n      value = IupGetAttributeId(ih, \"\", i);  /* must use IupGetAttribute to check the native system */\n      if (value)\n        item_w = iupdrvFontGetStringWidth(ih, value);\n\n      if (item_w > *w)\n        *w = item_w;\n    }\n\n    if (*w == 0) /* default is 5 characters in 1 item */\n      *w = iupdrvFontGetStringWidth(ih, \"WWWWW\");\n  }\n\n  if (ih->data->show_image)\n  {\n    for (i=1; i<=count; i++)\n    {\n      int img_w, img_h;\n      iListGetItemImageInfo(ih, i, &img_w, &img_h);\n      if (img_w > max_w)\n        max_w = img_w;\n      if (img_h > max_h)\n        max_h = img_h;\n    }\n\n    /* Used only in Windows */\n    ih->data->maximg_w = max_w;\n    ih->data->maximg_h = max_h;\n\n    *w += max_w;\n  }\n\n  /* compute height for multiple lines, dropdown is just 1 line */\n  if (!ih->data->is_dropdown)\n  {\n    int visiblelines, num_lines, \n        edit_line_size = *h;  /* don't include the highest image */\n\n    if (ih->data->show_image && max_h > *h)  /* use the highest image to compute the natural size */\n      *h = max_h;\n\n    iupdrvListAddItemSpace(ih, h);  /* this independs from spacing */\n\n    *h += 2*ih->data->spacing;  /* this will be multiplied by the number of lines */\n    *w += 2*ih->data->spacing;  /* include also horizontal spacing */\n\n    num_lines = count;\n    if (num_lines == 0) num_lines = 1;\n\n    visiblelines = iupAttribGetInt(ih, \"VISIBLELINES\");\n    if (visiblelines)\n      num_lines = visiblelines;   \n\n    *h = *h * num_lines;\n\n    if (ih->data->has_editbox) \n      *h += edit_line_size;\n  }\n  else\n  {\n    if (!ih->data->has_editbox)\n    {\n      if (ih->data->show_image && max_h > *h)  /* use the highest image to compute the natural size */\n        *h = max_h;\n    }\n  }\n}\n\nstatic void iListComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w, natural_h;\n  int sb_size = iupdrvGetScrollbarSize();\n  (void)children_expand; /* unset if not a container */\n\n  iListGetNaturalItemsSize(ih, &natural_w, &natural_h);\n\n  /* compute the borders space */\n  iupdrvListAddBorders(ih, &natural_w, &natural_h);\n\n  if (ih->data->is_dropdown)\n  {\n    /* add room for dropdown box */\n    natural_w += sb_size;\n\n    if (natural_h < sb_size)\n      natural_h = sb_size;\n  }\n  else\n  {\n    /* add room for scrollbar */\n    if (ih->data->sb)\n    {\n      natural_h += sb_size;\n      natural_w += sb_size;\n    }\n  }\n\n  if (ih->data->has_editbox)\n  {\n    natural_w += 2*ih->data->horiz_padding;\n    natural_h += 2*ih->data->vert_padding;\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\nstatic void iListDestroyMethod(Ihandle* ih)\n{\n  if (ih->data->mask)\n    iupMaskDestroy(ih->data->mask);\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupList(const char* action)\n{\n  void *params[2];\n  params[0] = (void*)action;\n  params[1] = NULL;\n  return IupCreatev(\"list\", params);\n}\n\nIclass* iupListNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"list\";\n  ic->format = \"a\"; /* one ACTION callback name */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n  ic->has_attrib_id = 1;\n\n  /* Class functions */\n  ic->New = iupListNewClass;\n  ic->Create = iListCreateMethod;\n  ic->Destroy = iListDestroyMethod;\n  ic->ComputeNaturalSize = iListComputeNaturalSizeMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"ACTION\", \"sii\");\n  iupClassRegisterCallback(ic, \"MULTISELECT_CB\", \"s\");\n  iupClassRegisterCallback(ic, \"DROPDOWN_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"DBLCLICK_CB\", \"is\");\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n  iupClassRegisterCallback(ic, \"MOTION_CB\", \"iis\");\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"DRAGDROP_CB\", \"iiii\");\n\n  iupClassRegisterCallback(ic, \"EDIT_CB\", \"is\");\n  iupClassRegisterCallback(ic, \"CARET_CB\", \"iii\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* IupList only */\n  iupClassRegisterAttribute(ic, \"SCROLLBAR\", iListGetScrollbarAttrib, iListSetScrollbarAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"AUTOHIDE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"MULTIPLE\", iListGetMultipleAttrib, iListSetMultipleAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DROPDOWN\", iListGetDropdownAttrib, iListSetDropdownAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EDITBOX\", iListGetEditboxAttrib, iListSetEditboxAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"COUNT\", iListGetCountAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUESTRING\", iListGetValueStringAttrib, iListSetValueStringAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttributeId(ic, \"INSERTITEM\", NULL, iListSetInsertItemAttrib, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"APPENDITEM\", NULL, iListSetAppendItemAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"REMOVEITEM\", NULL, iListSetRemoveItemAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"VALUEMASKED\", NULL, iListSetValueMaskedAttrib, NULL, NULL, IUPAF_WRITEONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKCASEI\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKDECIMALSYMBOL\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASK\", iListGetMaskAttrib, iListSetMaskAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKINT\", NULL, iListSetMaskIntAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKFLOAT\", NULL, iListSetMaskFloatAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKREAL\", NULL, iListSetMaskRealAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"OLD_MASK_DATA\", iListGetMaskDataAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"VISIBLECOLUMNS\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VISIBLELINES\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"SHOWIMAGE\", iListGetShowImageAttrib, iListSetShowImageAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWDRAGDROP\", iListGetShowDragDropAttrib, iListSetShowDragDropAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DRAGDROPLIST\", NULL, iListSetDragDropListAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupdrvListInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief mask pattern matching\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\n#include \"iup_maskparse.h\"\n#include \"iup_mask.h\"\n#include \"iup_str.h\"\n\n/* redefine here to avoid include iup.h */\n#define IUP_MASK_FLOAT        \"[+/-]?(/d+/.?/d*|/./d+)\"\n#define IUP_MASK_UFLOAT             \"(/d+/.?/d*|/./d+)\"\n#define IUP_MASK_FLOATCOMMA   \"[+/-]?(/d+/,?/d*|/,/d+)\"\n#define IUP_MASK_UFLOATCOMMA        \"(/d+/,?/d*|/,/d+)\"\n#define IUP_MASK_INT           \"[+/-]?/d+\"\n#define IUP_MASK_UINT                \"/d+\"\n\nstruct _Imask\n{\n  char* mask_str;\n  ImaskParsed* fsm;\n  int casei;\n  char type;\n  float fmin, \n        fmax;\n  int   imin,\n        imax;\n};\n\n\nint iupMaskCheck(Imask* mask, const char *val)\n{\n  int ret;\n\n  /* empty text or no mask */\n  if (!val || !(*val) || !mask) \n    return 1;\n\n  ret = iupMaskMatch(val,mask->fsm,0,NULL,NULL,NULL,mask->casei);\n  if (ret == IMASK_PARTIALMATCH)\n    return -1;\n  if (ret != (int)strlen(val))\n    return 0;\n\n  switch(mask->type)\n  {\n  case 'I':\n    {\n      int ival = 0;\n      iupStrToInt(val, &ival);\n      if(ival < mask->imin || ival > mask->imax)\n        return 0;\n      break;\n    }\n  case 'F':\n    {\n      float fval = 0;\n      iupStrToFloat(val, &fval);\n      if(fval < mask->fmin || fval > mask->fmax)\n        return 0;\n      break;\n    }\n  }\n\n  return 1;\n}\n\nImask* iupMaskCreate(const char* mask_str, int casei)\n{\n  ImaskParsed* fsm;\n  Imask* mask;\n  char* copy_mask_str;\n\n  if (!mask_str)\n    return NULL;\n\n  /* Parse the mask first */\n  copy_mask_str = iupStrDup(mask_str);\n  if (iupMaskParse(copy_mask_str, &fsm) != IMASK_PARSE_OK)\n  {\n    free(copy_mask_str);\n    return NULL;\n  }\n\n  mask = (Imask*)malloc(sizeof(Imask));\n  memset(mask, 0, sizeof(Imask));\n\n  mask->mask_str = copy_mask_str;\n  mask->casei = casei;\n  mask->fsm = fsm;\n\n  return mask;\n}\n\nImask* iupMaskCreateInt(int min, int max)\n{\n  Imask* mask;\n\n  if (min < 0)\n    mask = iupMaskCreate(IUP_MASK_INT, 0);\n  else\n    mask = iupMaskCreate(IUP_MASK_UINT, 0);\n\n  if (mask)\n  {\n    mask->imin = min;\n    mask->imax = max;\n    mask->type = 'I';\n  }\n\n  return mask;\n}\n\nImask* iupMaskCreateReal(int positive, const char* decimal_symbol)\n{\n  Imask* mask;\n  int use_comma = 0;\n\n  if (decimal_symbol)\n  {\n    if (decimal_symbol[0] == ',')\n      use_comma = 1;\n  }\n  else\n  {\n    struct lconv* locale_info = localeconv();\n    if (locale_info->decimal_point[0] == ',')\n      use_comma = 1;\n  }\n\n  if (use_comma)\n  {\n    if (positive)\n      mask = iupMaskCreate(IUP_MASK_UFLOATCOMMA, 0);\n    else\n      mask = iupMaskCreate(IUP_MASK_FLOATCOMMA, 0);\n  }\n  else\n  {\n    if (positive)\n      mask = iupMaskCreate(IUP_MASK_UFLOAT, 0);\n    else\n      mask = iupMaskCreate(IUP_MASK_FLOAT, 0);\n  }\n\n  return mask;\n}\n\nImask* iupMaskCreateFloat(float min, float max, const char* decimal_symbol)\n{\n  Imask* mask = iupMaskCreateReal(min >= 0, decimal_symbol);\n\n  if (mask)\n  {\n    mask->fmin = min;\n    mask->fmax = max;\n    mask->type = 'F';\n  }\n\n  return mask;\n}\n\nvoid iupMaskDestroy(Imask* mask)\n{\n  free(mask->mask_str); \n  free(mask->fsm); \n  free(mask); \n}\n\nchar* iupMaskGetStr(Imask* mask)\n{\n  return mask->mask_str;\n}\n","/** \\file\n * \\brief iupmask imask_match_functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"iup_maskparse.h\"\n#include \"iup_maskmatch.h\"\n\n\n#define IMASK_MIN_STACK_ELEMENTS 1000\nenum {IMASK_CAPT_OPEN, IMASK_CAPT_CLOSE};\n\ntypedef struct _ImaskCapt\n{\n  struct _ImaskCapt* next_one;\n  int type;\n  short which_one;\n  long pos;\n} ImaskCapt;\n\ntypedef struct _ImaskMatchVars\n{\n  const char *text;\n  ImaskParsed *fsm;\n  iMaskMatchFunc function;\n  short *tested;\n  void *user;\n} ImaskMatchVars;\n\n\ntypedef struct _ImaskStack\n{\n  short *stack;\n  short size;\n} ImaskStack;\n\n\n#define isalphanum(_x) (isalnum((int)(_x)) || ((_x) == '_'))\n\n\n/* match functions corresponding to regular expressions */\n\nstatic int match_blanks (const char *text, long j)\n{\n  return (((text[j] == '\\t') || (text[j] == '\\xff') || (text[j] == ' ') ||\n     (text[j] == '\\n'))) ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_non_blanks (const char *text, long j)\n{\n  return (!((text[j] == '\\t') || (text[j] == '\\xff') ||\n      (text[j] == ' ') || (text[j] == '\\n')))\n    ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_alpha (const char *text, long j)\n{\n  return (isalpha((int)text[j])) ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_non_alpha (const char *text, long j)\n{\n  return (!isalpha((int)text[j]) && (text[j] != '\\0'))\n    ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_digit (const char *text, long j)\n{\n  return (isdigit((int)text[j])) ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_non_digit (const char *text, long j)\n{\n  return (!isdigit((int)text[j]) && (text[j] != '\\0'))\n    ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_alphanum (const char *text, long j)\n{\n  return isalphanum (text[j]) ? IMASK_NORMAL_MATCH : IMASK_NO_MATCH;\n}\n\nstatic int match_non_alphanum (const char *text, long j)\n{\n  return (isalphanum (text[j]) || (text[j] == '\\0'))\n    ? IMASK_NO_MATCH : IMASK_NORMAL_MATCH;\n}\n\nstatic int match_word_boundary (const char *text, long j)\n{\n  if ((j == 0) && isalphanum (text[j]))\n    return IMASK_NO_CHAR_MATCH;\n\n  else if (isalphanum (text[j - 1]) && !isalphanum (text[j]))\n    return IMASK_NO_CHAR_MATCH;\n\n  else if (isalphanum (text[j]) && !isalphanum (text[j - 1]))\n    return IMASK_NO_CHAR_MATCH;\n\n  return IMASK_NO_MATCH;\n\n}\n\nstatic ImaskMatchFunc imask_match_functions[] =\n{\n  {'w', &match_alphanum},\n  {'W', &match_non_alphanum},\n  {'d', &match_digit},\n  {'D', &match_non_digit},\n  {'S', &match_non_blanks},\n  {'s', &match_blanks},\n  {'b', &match_word_boundary},\n  {'l', &match_alpha},\n  {'L', &match_non_alpha},\n  {'\\0', NULL}\n};\n\nImaskMatchFunc* iupMaskMatchGetFuncs(void)\n{\n  return imask_match_functions;\n}\n\nstatic void iMaskMatchCaptureResult (ImaskMatchVars * vars, ImaskCapt * capture)\n{\n  ImaskCapt *next = NULL;\n\n  while (capture != NULL)\n  {\n    ImaskCapt *cap = capture->next_one;\n\n    capture->next_one = next;\n    next = capture;\n    capture = cap;\n  }\n\n  capture = next;\n  next = NULL;\n\n  while (capture != NULL)\n  {\n    if (capture->type == IMASK_CAPT_OPEN)\n    {\n      ImaskCapt *cap = capture->next_one;\n\n      capture->next_one = next;\n      next = capture;\n      capture = cap;\n    }\n    else\n    {\n      if (capture->pos >= next->pos)\n        (*vars->function)((char)capture->which_one, next->pos, capture->pos, vars->text, vars->user);\n\n      next = next->next_one;\n      capture = capture->next_one;\n    }\n  }\n}\n\nstatic long iMaskMatchRecursive (ImaskMatchVars * vars, long j, int state, ImaskCapt * capture, int size)\n{\n  switch (vars->fsm[state].command)\n  {\n  case IMASK_NULL_CMD:\n    if (vars->fsm[state].next1 == 0)    /*se chegou ao fim da maquina de estados */\n    {\n      if (vars->function != NULL)\n        iMaskMatchCaptureResult (vars, capture);         /* guarda capturas */\n\n      return j;\n    }\n\n    /* verifica o estado atual ja foi avaliado antes */\n    {\n      int count;\n      for (count = 0; count < size; count++)\n        if (vars->tested[count] == state)\n          return IMASK_NOMATCH;\n    }\n\n    vars->tested[size++] = (short)state;       /* indicada que o estado foi testado */\n\n    /* se houverem dois ramos, chama a funcao recursivamente,\n    retornando com o primeiro que completar a maquina */\n\n    if (vars->fsm[state].next1 != vars->fsm[state].next2)\n    {\n      long a;\n\n      a = iMaskMatchRecursive (vars, j, vars->fsm[state].next2, capture, size);\n\n      if (a != IMASK_NOMATCH)         /* se deu match */\n        return a;\n\n      a = iMaskMatchRecursive (vars, j, vars->fsm[state].next1, capture, size);\n\n      return a;\n    }\n    break;\n\n  case IMASK_CAP_OPEN_CMD:\n    {\n      long a;\n      ImaskCapt new_cap;\n\n      new_cap.next_one = capture;\n      new_cap.type = IMASK_CAPT_OPEN;\n      new_cap.pos = j;\n      new_cap.which_one = vars->fsm[state].ch;\n\n      a = iMaskMatchRecursive (vars, j, vars->fsm[state].next1, &new_cap, size);\n\n      return a;\n    }\n    break;\n\n  case IMASK_CAP_CLOSE_CMD:\n    {\n      long a;\n      ImaskCapt new_cap;\n\n      new_cap.next_one = capture;\n      new_cap.type = IMASK_CAPT_CLOSE;\n      new_cap.pos = j - 1;\n      new_cap.which_one = vars->fsm[state].ch;\n\n      a = iMaskMatchRecursive (vars, j, vars->fsm[state].next1, &new_cap, size);\n\n      return a;\n    }\n\n  case IMASK_CLASS_CMD:\n    {\n      int temp, found = 0, negate;\n\n      temp = vars->fsm[state].next1;\n      negate = vars->fsm[state].next2;\n      state++;\n\n      while (vars->fsm[state].command != IMASK_NULL_CMD)\n      {\n        if (vars->fsm[state].command == IMASK_CLASS_CMD_RANGE)\n        {\n          if ((vars->text[j] >= vars->fsm[state].ch) &&\n            (vars->text[j] <= vars->fsm[state].next1))\n          {\n            found = 1;\n            break;\n          }\n        }\n\n        else if ((vars->fsm[state].command == IMASK_CLASS_CMD_CHAR) &&\n          (vars->text[j] == vars->fsm[state].ch))\n        {\n          found = 1;\n          break;\n        };\n        state++;\n      }\n\n      if (found ^ negate)\n      {\n        if (vars->text[j] == '\\0')\n          return IMASK_NOMATCH;\n        j++;\n        vars->tested = &vars->tested[size + 1];\n        size = 0;\n        return iMaskMatchRecursive (vars, j, temp, capture, size);\n      }\n      else\n        return IMASK_NOMATCH;\n    }\n\n  case IMASK_CHAR_CMD:\n    if (vars->text[j] != vars->fsm[state].ch)\n      return IMASK_NOMATCH;\n    j++;\n    vars->tested = &vars->tested[size + 1];\n    size = 0;\n    break;\n\n  case IMASK_ANY_CMD:\n    if ((vars->text[j] == '\\0') || (vars->text[j] == '\\n'))\n      return IMASK_NOMATCH;\n    j++;\n    vars->tested = &vars->tested[size + 1];\n    size = 0;\n    break;\n\n  case IMASK_SPC_CMD:\n    {\n      long a;\n\n      a = (*imask_match_functions[(int) vars->fsm[state].ch].function) (vars->text, j);\n\n      switch (a)\n      {\n      case IMASK_NO_MATCH:\n        return IMASK_NOMATCH;\n\n      case IMASK_NORMAL_MATCH:\n        j++;\n        vars->tested = &vars->tested[size + 1];\n        size = 0;\n        break;\n\n      case IMASK_NO_CHAR_MATCH:;  /* does nothing */\n      }\n    }\n    break;\n\n  case IMASK_BEGIN_CMD:\n    if (!((vars->text[j - 1] == '\\n') || (j == 0)))\n      return IMASK_NOMATCH;\n\n    break;\n\n  case IMASK_END_CMD:\n    if (!((vars->text[j] == '\\n') || (vars->text[j] == '\\0')))\n      return IMASK_NOMATCH;\n\n    break;\n  }\n\n  return iMaskMatchRecursive (vars, j, vars->fsm[state].next1, capture, size);\n}\n\nstatic int iMaskInStack (ImaskStack * stack, int state)\n{\n  int a;\n  for (a = 0; a < stack->size; a++)\n    if (stack->stack[a] == state)\n      return 1;\n\n  return 0;\n}\n\nstatic void iMaskNewStack (ImaskStack * new_stack, short *stack)\n{\n  new_stack->size = 0;\n  new_stack->stack = stack;\n}\n\nstatic void iMaskPushStack (ImaskStack * stack, int value)\n{\n  stack->stack[stack->size++] = (short)value;\n}\n\nstatic void iMaskMoveStack (ImaskStack * dest, ImaskStack * source)\n{\n  short *temp = dest->stack;\n  dest->stack = source->stack;\n  source->stack = temp;\n\n  dest->size = source->size;\n  source->size = 0;\n}\n\n/* non recursive */\nstatic long iMaskMatchLocal (const char *text, ImaskParsed * fsm, long start, char *addchar, int casei)\n{\n  int finished = IMASK_NOMATCH;\n  ImaskStack now, next;\n  short a1[IMASK_MIN_STACK_ELEMENTS];\n  short a2[IMASK_MIN_STACK_ELEMENTS];\n  int state;\n  int j = 0;\n  int pos;\n\n  if (addchar) addchar[0] = 0;   \n\n  j = start;\n\n  iMaskNewStack(&now, a1);\n  iMaskNewStack(&next, a2);\n\n  iMaskPushStack (&now, fsm[0].next1);\n\n  for (;;)\n  {\n    for (pos = 0; pos < now.size; pos++)\n    {\n      state = now.stack[pos];\n\n      if (state == 0)\n      {\n        finished = j - start;\n        continue;\n      }\n\n      if (fsm[state].command == IMASK_NULL_CMD)\n      {\n        if(!iMaskInStack (&now, fsm[state].next2))\n          iMaskPushStack (&now, fsm[state].next2);\n\n        if(fsm[state].next1 != fsm[state].next2)\n        {\n          if(!iMaskInStack (&now, fsm[state].next1))\n            iMaskPushStack (&now, fsm[state].next1);\n        }\n      }\n      else if (text[j] == '\\0');  /* ignore \\0 */\n      else if (((fsm[state].command == IMASK_CHAR_CMD) &&\n        ((!casei && fsm[state].ch == text[j]) ||\n        (casei && tolower(fsm[state].ch) == tolower(text[j]))\n        )\n        ) ||\n        ((fsm[state].command == IMASK_ANY_CMD) &&\n        (text[j] != '\\n')\n        )\n        )\n        iMaskPushStack (&next, fsm[state].next1);\n      else if (fsm[state].command == IMASK_SPC_CMD)\n      {\n        int ret;\n\n        ret = (*(imask_match_functions[(int) fsm[state].ch].function))(text, j);\n        switch (ret)\n        {\n        case IMASK_NO_MATCH:\n          break;\n\n        case IMASK_NORMAL_MATCH:\n          iMaskPushStack (&next, fsm[state].next1);\n          break;\n\n        case IMASK_NO_CHAR_MATCH:\n          iMaskPushStack (&now, fsm[state].next1);\n          break;\n        }\n      }\n      else if (fsm[state].command == IMASK_CLASS_CMD)\n      {\n        int temp, found = 0, negate;\n\n        temp = fsm[state].next1;\n        negate = fsm[state].next2;\n        state++;\n\n        while (fsm[state].command != IMASK_NULL_CMD)\n        {\n          if (fsm[state].command == IMASK_CLASS_CMD_RANGE)\n          {\n            if((!casei && (text[j]>=fsm[state].ch) &&\n              (text[j]<=fsm[state].next1)\n              ) ||\n              (casei && (tolower(text[j])>=tolower(fsm[state].ch)) &&\n              (tolower(text[j])<=tolower(fsm[state].next1))\n              )\n              )\n            {\n              found = 1;\n              break;\n            }\n          }\n          else if ((fsm[state].command == IMASK_CLASS_CMD_CHAR) &&\n            ((!casei && text[j] == fsm[state].ch) ||\n            (casei && tolower(text[j]) == tolower(fsm[state].ch))\n            )\n            )\n          {\n            found = 1;\n            break;\n          }\n          state++;\n        }\n\n        if(found ^ negate)\n        {\n          iMaskPushStack (&next, temp);\n          state = temp;\n        }\n      }\n      else if (fsm[state].command == IMASK_BEGIN_CMD)\n      {\n        if (text[j - 1] == '\\n' || j == 0)\n          iMaskPushStack (&now, fsm[state].next1);\n      }\n      else if (fsm[state].command == IMASK_END_CMD)\n      {\n        if (text[j] == '\\n' || text[j] == '\\0')\n          iMaskPushStack (&now, fsm[state].next1);\n      }\n    }\n\n    if (text[j] == '\\0')\n    {\n      if(next.size == 0 && finished == j)\n      {\n        return finished;\n      }\n      else if(addchar)\n      {\n        int pos;\n\n        for (pos = 0; pos < now.size; pos++)\n        {\n          state = now.stack[pos];\n          if (fsm[state].command == IMASK_CHAR_CMD)\n          {\n            iMaskPushStack (&next, state);\n          }\n          else if (fsm[state].command != IMASK_NULL_CMD)\n          {\n            next.size = 0;\n            break;\n          }\n          else\n          {\n            if (!iMaskInStack (&now, fsm[state].next2))\n              iMaskPushStack (&now, fsm[state].next2);\n\n            if (fsm[state].next1 != fsm[state].next2)\n            {\n              if (!iMaskInStack (&now, fsm[state].next1))\n                iMaskPushStack (&now, fsm[state].next1);\n            }\n          }           \n        }\n\n        iMaskMoveStack (&now, &next);\n\n        if (now.size == 1)\n        {\n          int inx=0;\n          state = now.stack[0];\n          while(fsm[state].next1 == fsm[state].next2)\n          {\n            if(fsm[state].command == IMASK_CHAR_CMD)\n              addchar[inx++] = fsm[state].ch;\n            else if(fsm[state].command != IMASK_NULL_CMD)\n              break;\n\n            state = fsm[state].next1;\n          }\n          addchar[inx]=0;\n        }\n      }\n      return IMASK_PARTIALMATCH;\n    }\n\n    j++;\n\n    if (next.size == 0)\n    {\n      if (finished > IMASK_NOMATCH)\n        return finished;\n\n      return IMASK_NOMATCH;\n    }\n\n    iMaskMoveStack (&now, &next);\n  }\n}\n\nint iupMaskMatch (const char *text, ImaskParsed * fsm, long start, iMaskMatchFunc function, void *user, char *addchar, int icase)\n{\n  long ret;\n  short tested[10000];  /* to be eliminated */\n  ImaskMatchVars vars;\n\n  /* use recursive only for standard capture */\n\n  if (fsm[0].ch == IMASK_NOCAPTURE)\n    return iMaskMatchLocal (text, fsm, start, addchar, icase);\n\n  vars.text = text;\n  vars.fsm = fsm;\n  vars.tested = tested;\n  vars.function = function;\n  vars.user = user;\n\n  ret = iMaskMatchRecursive (&vars, start, fsm[0].next1, NULL, 0);\n\n  return (int)((ret >= start) ? ret - start : ret);\n}\n","/** \\file\n * \\brief imask parser\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <setjmp.h>\n\n#include \"iup_maskparse.h\"\n#include \"iup_maskmatch.h\"\n\n/*\n * Table of characters (customizaveis atraves de iupMaskSetChar)\n */\n\nstatic char* imask_parse_chars = \"|*+()[]-^/.?^${}~\";\n/*                                01234567890123456     */\n\n#define OR_CH        imask_parse_chars[0]  /* OR CHaracter      */\n#define CL_CH        imask_parse_chars[1]  /* CLosure CHaracter    */\n#define OOM_CH       imask_parse_chars[2]  /* One Or More CHaracter  */\n#define OPGR_CH      imask_parse_chars[3]  /* OPen  GRoup CHaracter  */\n#define CLGR_CH      imask_parse_chars[4]  /* CLose GRoup CHaracter  */\n#define OPCL_CH      imask_parse_chars[5]  /* OPen CLass CHaracter    */\n#define CLCL_CH      imask_parse_chars[6]  /* CLose CLass CHaracter  */\n#define SEPCL_CH     imask_parse_chars[7]  /* SEParate CLass CHaracter  */\n#define NEGCL_CH     imask_parse_chars[8]  /* NEGation CLass CHaracter  */\n#define SPC_CH       imask_parse_chars[9]  /* SPeCial function CHaracter  */\n#define ANY_CH       imask_parse_chars[10]  /* ANY CHaracter    */\n#define ONE_CH       imask_parse_chars[11]  /* ONE or no CHaracter    */\n#define BEGIN_CH     imask_parse_chars[12]  /* BEGINning of a line CHaracter*/\n#define END_CH       imask_parse_chars[13]  /* END of a line CHaracter  */\n#define CAP_OPEN_CH  imask_parse_chars[14]  /* CAPture OPEN CHaracter  */\n#define CAP_CLOSE_CH imask_parse_chars[15]  /* CAPture CLOSE CHaracter  */\n#define NEG_CH       imask_parse_chars[16]  /* NEGation CHaracter    */\n\n#define SPC2_CH  '\\\\'    /* SPeCial 2 CHaracter */\n\n#define isvalid(c) (c != 0 && c != OR_CH && c != OPGR_CH && c != CLGR_CH &&\\\n                         c != CL_CH && c != OPCL_CH && c != CLCL_CH &&\\\n                         c != CAP_OPEN_CH && c != CAP_CLOSE_CH && c != OOM_CH)\n\n#define STATE_BLOCK        30\n\ntypedef struct _ImaskParseVars\n{\n  const char *string;\n  int state, j, num_states;\n  ImaskParsed *fsm;\n  short capture[30];\n  short size;\n  char nextcap;\n  jmp_buf env;\n} ImaskParseVars;\n\nstatic int iMaskParseExpression (ImaskParseVars * vars);\nstatic int iMaskParseTerm (ImaskParseVars * vars);\nstatic int iMaskParseFactor (ImaskParseVars * vars);\nstatic void iMaskParseError (ImaskParseVars *vars);\nstatic void iMaskParseNewState (ImaskParseVars * vars);\nstatic void iMaskParseSetState (ImaskParseVars * vars, int state, char ch, char command, int next1, int next2);\n\nint iupMaskSetChar (int char_number, char new_char)\n{\n  if ((char_number < 0) || (char_number > (int)strlen(imask_parse_chars)))\n    return 0;\n\n  imask_parse_chars[char_number] = new_char;\n\n  return 1;\n}\n\n    /*\n     * Funcao de interface, recebe padrao e retorna array contendo as finite\n     * state machines (fsm) construidas a partir do padrao\n     */\n\nint iupMaskParse(const char *text, ImaskParsed ** fsm)\n{\n  int t;\n  ImaskParseVars vars;\n\n  /* inicializacao das variaveis */\n\n  vars.state = 1;\n  vars.j = 0;\n  vars.num_states = 0;\n  vars.size = 0;\n  vars.nextcap = 0;\n  vars.string = text;\n\n  if ((vars.fsm = (ImaskParsed *) malloc (STATE_BLOCK * sizeof (ImaskParsed))) == NULL)\n    return IMASK_MEM_ERROR;\n\n  memset(vars.fsm, 0, STATE_BLOCK*sizeof (ImaskParsed));\n  vars.num_states = STATE_BLOCK;\n\n  /* a principio, nao ha captura. Se ocorrer uma, ele e setado\n     para IMASK_CAPTURE */\n\n  vars.fsm[0].ch = IMASK_NOCAPTURE;\n\n  if (setjmp (vars.env) == 0)\n    t = iMaskParseExpression (&vars);\n\n  else\n  {\n    free (vars.fsm);\n    return IMASK_PARSE_ERROR;\n  }\n\n  /* seta os estados inicial e final, guardando no inicial\n     (fsm[0].next1) o tamanho da maquina */\n\n  iMaskParseSetState (&vars, 0, vars.fsm[0].ch, IMASK_NULL_CMD, t, vars.state + 1);\n  iMaskParseSetState (&vars, vars.state, 0, IMASK_NULL_CMD, 0, 0);\n\n  *fsm = vars.fsm;\n\n  return IMASK_PARSE_OK;\n}\n\nstatic int iMaskParseExpression (ImaskParseVars * vars)\n{\n  int r, t1;\n  int last_state = vars->state - 1;\n\n  t1 = iMaskParseTerm (vars);\n  r = t1;\n\n  if (vars->string[vars->j] == OR_CH)\n  {\n    int t2 = vars->state;\n    int t3;\n\n    r = t2;\n\n    vars->j++;\n    iMaskParseNewState (vars);\n\n    t3 = iMaskParseExpression (vars);  /* pega o 2o ramo do OR */\n\n    /* faz o primeiro state antes do OR apontar para o state de entrada\n     * do OR */\n\n    if (vars->fsm[last_state].next1 == t1)\n      vars->fsm[last_state].next1 = t2;\n\n    if (vars->fsm[last_state].next2 == t1)\n      vars->fsm[last_state].next2 = t2;\n\n    /* faz o ultimo state do primeiro ramo do OR apontar para o\n     * state de saida do OR */\n\n    if (vars->fsm[t2 - 1].next1 == t2)\n      vars->fsm[t2 - 1].next1 = vars->state;\n\n    if (vars->fsm[t2 - 1].next2 == t2)\n      vars->fsm[t2 - 1].next2 = vars->state;\n\n    iMaskParseSetState (vars, t2, 0, IMASK_NULL_CMD, t1, t3);\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1,\n        vars->state + 1);\n\n    iMaskParseNewState (vars);\n  }\n  return r;\n}\n\nstatic int iMaskParseTerm (ImaskParseVars * vars)\n{\n  int r;\n\n  r = iMaskParseFactor (vars);\n\n  if ((vars->string[vars->j] == OPGR_CH) ||\n      (isvalid (vars->string[vars->j])) ||\n      (vars->string[vars->j] == OPCL_CH) ||\n      (vars->string[vars->j] == CAP_OPEN_CH) ||\n      (vars->string[vars->j] == NEG_CH))\n    iMaskParseTerm (vars);\n\n  if (!((vars->string[vars->j] == OR_CH) ||\n        (vars->string[vars->j] == CLGR_CH) ||\n        (vars->string[vars->j] == '\\0') ||\n        (vars->string[vars->j] == CAP_CLOSE_CH)))\n    iMaskParseError (vars);\n\n  return r;\n}\n\nstatic int iMaskParseFactor (ImaskParseVars * vars)\n{\n  int r, t1, t2 = 0;\n\n  t1 = vars->state;\n\n  if (vars->string[vars->j] == OPGR_CH)\n  {\n    vars->j++;\n    t2 = iMaskParseExpression (vars);\n\n    if (vars->string[vars->j] == CLGR_CH)\n      vars->j++;\n    else\n      iMaskParseError (vars);\n  }\n\n  else if (vars->string[vars->j] == CAP_OPEN_CH)\n  {\n    vars->fsm[0].ch = IMASK_CAPTURE;\n    iMaskParseSetState (vars, vars->state, vars->nextcap, \n                 IMASK_CAP_OPEN_CMD, vars->state + 1, vars->state + 1);\n    t2 = vars->state;\n    iMaskParseNewState (vars);\n    vars->capture[++vars->size] = vars->nextcap++;\n    vars->j++;\n\n    iMaskParseExpression (vars);\n\n    if (vars->string[vars->j] == CAP_CLOSE_CH)\n    {\n      iMaskParseSetState (vars, vars->state, (char)vars->capture[vars->size--],\n                   IMASK_CAP_CLOSE_CMD, vars->state + 1, vars->state + 1);\n\n      iMaskParseNewState (vars);\n      vars->j++;\n    }\n    else\n      iMaskParseError (vars);\n\n  }\n\n  else if (vars->string[vars->j] == ANY_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 1, IMASK_ANY_CMD, vars->state + 1, vars->state + 1);\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n\n  else if (vars->string[vars->j] == NEG_CH)\n  {\n    int t6;\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n    t6 = iMaskParseFactor (vars);\n    iMaskParseSetState (vars, t2, 1, IMASK_NEG_OPEN_CMD, t6, vars->state);\n    iMaskParseSetState (vars, vars->state, 1, IMASK_NEG_CLOSE_CMD, vars->state + 1, vars->state + 1);\n    iMaskParseNewState (vars);\n  }\n\n  else if (vars->string[vars->j] == BEGIN_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 1, IMASK_BEGIN_CMD, vars->state + 1,\n      vars->state + 1);\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n  else if (vars->string[vars->j] == END_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 1, IMASK_END_CMD, vars->state + 1,\n      vars->state + 1);\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n\n  else if (isvalid (vars->string[vars->j]) && (vars->string[vars->j]\n  != SPC_CH) && (vars->string[vars->j] != ANY_CH))\n  {\n    iMaskParseSetState (vars, vars->state, vars->string[vars->j], \n                 IMASK_CHAR_CMD, vars->state + 1, vars->state + 1);\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n\n  else if (vars->string[vars->j] == OPCL_CH)\n  {\n    vars->j++;\n    iMaskParseSetState (vars, vars->state, 0, IMASK_CLASS_CMD, 0, 0);\n\n    if (vars->string[vars->j] == NEGCL_CH)\n    {\n      vars->fsm[vars->state].next2 = 1;\n      vars->j++;\n    }\n\n    t2 = vars->state;\n    iMaskParseNewState (vars);\n\n    if (vars->string[vars->j] == SEPCL_CH)\n      iMaskParseError (vars);\n\n    while ((vars->string[vars->j] != CLCL_CH) && (vars->string[vars->j] != '\\n')\n      && (vars->string[vars->j] != '\\0'))\n    {\n      if (vars->string[vars->j] == SPC_CH)\n      {\n        char temp;\n\n        vars->j++;\n        switch (vars->string[vars->j])\n        {\n        case 'n':\n          temp = '\\n';\n          break;\n\n        case 't':\n          temp = '\\t';\n          break;\n\n        case 'e':\n          temp = 27;\n          break;\n\n        default:\n          temp = vars->string[vars->j];\n        }\n        iMaskParseSetState (vars, vars->state, temp, IMASK_CLASS_CMD_CHAR, 0, 0);\n        vars->j++;\n        iMaskParseNewState (vars);\n      }\n      else if (vars->string[vars->j] == SEPCL_CH)\n      {\n        char temp = 0;\n\n        vars->j++;\n\n        if (vars->string[vars->j] == SPC_CH)\n        {\n          vars->j++;\n          switch (vars->string[vars->j])\n          {\n          case 'n':\n            temp = '\\n';\n            break;\n\n          case 't':\n            temp = '\\t';\n            break;\n\n          case 'e':\n            temp = 27;\n            break;\n\n          default:\n            temp = vars->string[vars->j];\n          }\n        }\n        else if (vars->string[vars->j] != CLCL_CH)\n          temp = vars->string[vars->j];\n\n        else\n          iMaskParseError (vars);\n\n        iMaskParseSetState (vars, vars->state - 1, vars->fsm[vars->state - 1].ch,\n                     IMASK_CLASS_CMD_RANGE, temp, 0);\n        vars->j++;\n      }\n      else if (vars->string[vars->j] == BEGIN_CH)\n      {\n        iMaskParseSetState (vars, vars->state, 1, IMASK_BEGIN_CMD, vars->state + 1, vars->state + 1);\n        t2 = vars->state;\n        vars->j++;\n        iMaskParseNewState (vars);\n      }\n      else if (vars->string[vars->j] == END_CH)\n      {\n        iMaskParseSetState (vars, vars->state, 1, IMASK_END_CMD, vars->state + 1, vars->state + 1);\n        t2 = vars->state;\n        vars->j++;\n        iMaskParseNewState (vars);\n      }\n\n      else\n      {\n        iMaskParseSetState (vars, vars->state, vars->string[vars->j], IMASK_CLASS_CMD_CHAR, 0, 0);\n        vars->j++;\n        iMaskParseNewState (vars);\n      }\n\n    }\n    if (vars->string[vars->j] != CLCL_CH)\n      iMaskParseError (vars);\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1, vars->state + 1);\n    vars->fsm[t2].next1 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n\n  }\n\n  else if (vars->string[vars->j] == SPC_CH)\n  {\n    int loop1 = 0;\n    ImaskMatchFunc* match_functions = iupMaskMatchGetFuncs();\n\n    vars->j++;\n\n    while (match_functions[loop1].ch != '\\0' && \n           match_functions[loop1].ch != vars->string[vars->j])\n      loop1++;\n\n    if (match_functions[loop1].ch == '\\0')\n    {\n      int temp;\n\n      switch (vars->string[vars->j])\n      {\n      case 'n':\n        temp = '\\n';\n        break;\n\n      case 't':\n        temp = '\\t';\n        break;\n\n      case 'e':\n        temp = 27;\n        break;\n\n      case 'x':\n        vars->j++;\n        sscanf (&vars->string[vars->j], \"%2x\", &temp);\n        vars->j++;\n        break;\n\n      case 'o':\n        vars->j++;\n        sscanf (&vars->string[vars->j], \"%3o\", &temp);\n        vars->j += 2;\n        break;\n\n      default:\n        if (isdigit((int)vars->string[vars->j]))\n        {\n          sscanf (&vars->string[vars->j], \"%3d\", &temp);\n          if (temp > 255)\n          {\n            iMaskParseError (vars);\n          }\n          vars->j += 2;\n        }\n        else\n          temp = vars->string[vars->j];\n      }\n      iMaskParseSetState (vars, vars->state, (char)temp, IMASK_CHAR_CMD, vars->state + 1, vars->state + 1);\n    }\n\n    else\n    {\n      iMaskParseSetState (vars, vars->state, (char)loop1, IMASK_SPC_CMD, vars->state + 1, vars->state + 1);\n    }\n\n    t2 = vars->state;\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n  else\n    iMaskParseError (vars);\n\n  if (vars->string[vars->j] == CL_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1, t2);\n    r = vars->state;\n\n    if (vars->fsm[t1 - 1].next1 == t1)\n      vars->fsm[t1 - 1].next1 = vars->state;\n\n    if (vars->fsm[t1 - 1].next2 == t1)\n      vars->fsm[t1 - 1].next2 = vars->state;\n\n    vars->j++;\n    iMaskParseNewState (vars);\n  }\n\n  else if (vars->string[vars->j] == ONE_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1, t2);\n    r = vars->state;\n\n    if (vars->fsm[t1 - 1].next1 == t1)\n      vars->fsm[t1 - 1].next1 = vars->state;\n\n    if (vars->fsm[t1 - 1].next2 == t1)\n      vars->fsm[t1 - 1].next2 = vars->state;\n\n    if (vars->fsm[vars->state - 1].next1 == vars->state)\n      vars->fsm[vars->state - 1].next1 = vars->state + 1;\n\n    if (vars->fsm[vars->state - 1].next2 == vars->state)\n      vars->fsm[vars->state - 1].next2 = vars->state + 1;\n\n    vars->j++;\n    iMaskParseNewState (vars);\n\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1, vars->state + 1);\n\n    iMaskParseNewState (vars);\n  }\n  else if (vars->string[vars->j] == OOM_CH)\n  {\n    iMaskParseSetState (vars, vars->state, 0, IMASK_NULL_CMD, vars->state + 1, t2);\n    r = t2;\n\n    vars->j++;\n\n    iMaskParseNewState (vars);\n\n  }\n  else\n    r = t2;\n\n  return r;\n}\n\nstatic void iMaskParseError (ImaskParseVars * vars)\n{\n  longjmp (vars->env, 1);\n}\n\nstatic void iMaskParseNewState (ImaskParseVars * vars)\n{\n\n  if (vars->state >= vars->num_states - 1)\n  {\n    ImaskParsed *new_fsm = (ImaskParsed*) realloc (vars->fsm, (vars->num_states + STATE_BLOCK) * sizeof (ImaskParsed));\n    memset(new_fsm + vars->num_states, 0, STATE_BLOCK*sizeof(ImaskParsed));\n    vars->fsm = new_fsm;\n    vars->num_states += STATE_BLOCK;\n  }\n\n  vars->state++;\n}\n\nstatic void iMaskParseSetState (ImaskParseVars * vars, int state, char ch, char command, int next1, int next2)\n{\n  vars->fsm[state].ch = ch;\n  vars->fsm[state].command = command;\n  vars->fsm[state].next1 = next1;\n  vars->fsm[state].next2 = next2;\n}\n","/** \\file\n * \\brief Menu Resources.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_dialog.h\"\n#include \"iup_str.h\"\n#include \"iup_assert.h\"\n#include \"iup_key.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_menu.h\"\n\n\nstruct _IcontrolData \n{\n  int child_id;       /* serial number used by child controls */\n};\n\nstatic Ihandle* iMenuGetTopMenu(Ihandle* ih)\n{\n  for (; ih->parent; ih = ih->parent)\n    ; /* empty*/\n  return ih;\n}\n\nint iupMenuGetChildId(Ihandle* ih)\n{\n  Ihandle* dlg = IupGetDialog(ih);\n  if (dlg)\n    return iupDialogGetChildId(ih);\n  else\n  {\n    int id;\n    ih = iMenuGetTopMenu(ih);\n    if (!ih) return -1;\n    id = ih->data->child_id;\n    if (id == 0) id = 100; /* initial number */\n    ih->data->child_id = id+1;\n    return id;\n  }\n}\n\nchar* iupMenuGetChildIdStr(Ihandle* ih)\n{\n  Ihandle* dlg = IupGetDialog(ih);\n  if (dlg)\n    return iupDialogGetChildIdStr(ih);\n  else\n  {\n    Ihandle* dialog = iMenuGetTopMenu(ih);\n    return iupStrReturnStrf(\"iup-%s-%d\", ih->iclass->name, dialog->data->child_id);\n  }\n}\n\nint iupMenuIsMenuBar(Ihandle* ih)\n{\n  if (ih->parent && ih->parent->iclass->nativetype == IUP_TYPEDIALOG)\n    return 1;\n  else\n    return 0;\n}\n\nstatic void iMenuAdjustPos(int *x, int *y)\n{\n  int cursor_x = 0, cursor_y = 0;\n  int screen_width = 0, screen_height = 0;\n\n  if (*x == IUP_CENTER || *y == IUP_CENTER ||\n      *x == IUP_RIGHT  || *y == IUP_RIGHT ||\n      *x == IUP_CENTERPARENT || *y == IUP_CENTERPARENT)\n    iupdrvGetScreenSize(&screen_width, &screen_height);\n\n  if (*x == IUP_MOUSEPOS || *y == IUP_MOUSEPOS)\n    iupdrvGetCursorPos(&cursor_x, &cursor_y);\n\n  switch (*x)\n  {\n  case IUP_CENTER:\n    *x = screen_width/2;\n    break;\n  case IUP_LEFT:\n    *x = 0;\n    break;\n  case IUP_RIGHT:\n    *x = screen_width;\n    break;\n  case IUP_MOUSEPOS:\n    *x = cursor_x;\n    break;\n  }\n\n  switch (*y)\n  {\n  case IUP_CENTER:\n    *y = screen_height/2;\n    break;\n  case IUP_LEFT:\n    *y = 0;\n    break;\n  case IUP_RIGHT:\n    *y = screen_height;\n    break;\n  case IUP_MOUSEPOS:\n    *y = cursor_y;\n    break;\n  }\n\n  iupdrvAddScreenOffset(x, y, 1);\n}\n\nchar* iupMenuProcessTitle(Ihandle* ih, const char* title)\n{\n  char* str;\n\n  char* key = iupAttribGet(ih, \"KEY\");  /* NOT the same definition as the global KEY attribute */\n  if (!key) return (char*)title;\n\n  str = strchr(title, (int)(*key));\n  if (str)\n  {\n    int len = strlen(title);\n    char *new_title = malloc(len+1+1);\n    int pos = str-title;\n    memcpy(new_title, title, pos);\n    new_title[pos] = '&';\n    memcpy(new_title+pos+1, title+pos, len-pos+1);\n    return new_title;\n  }\n\n  return (char*)title;\n}\n\nint iupMenuPopup(Ihandle* ih, int x, int y)\n{\n  iMenuAdjustPos(&x, &y);\n  return iupdrvMenuPopup(ih, x, y);\n}\n\n\n/******************************************************************/\n\n\nstatic int iItemCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n    if (params[1]) iupAttribSetStr(ih, \"ACTION\", (char*)(params[1]));\n  }\n  return IUP_NOERROR;\n}\n\nstatic int iSubmenuCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n    if (params[1]) \n    {\n      Ihandle* child = (Ihandle*)(params[1]);\n      if (child->iclass->nativetype == IUP_TYPEMENU)\n        IupAppend(ih, child);\n    }\n  }\n  return IUP_NOERROR;\n}\n\nstatic int iMenuCreateMethod(Ihandle* ih, void** params)\n{\n  ih->data = iupALLOCCTRLDATA();\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams) \n    {\n      Ihandle* child = (Ihandle*)(*iparams);\n      if (child->iclass->nativetype == IUP_TYPEMENU)\n        IupAppend(ih, child);\n      iparams++;\n    }\n  }\n\n  return IUP_NOERROR;\n}\n\n\n/******************************************************************************************/\n\n\nIclass* iupSeparatorNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"separator\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPEMENU;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  ic->New = iupSeparatorNewClass;\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"WID\", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"NAME\", NULL, iupBaseSetNameAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvSeparatorInitClass(ic);\n\n  return ic;\n}\n\nIclass* iupItemNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"item\";\n  ic->format = \"sa\";  /* one string and one ACTION callback name */\n  ic->nativetype = IUP_TYPEMENU;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupItemNewClass;\n  ic->Create = iItemCreateMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"HIGHLIGHT_CB\", \"\");\n  iupClassRegisterCallback(ic, \"ACTION\", \"\");\n\n  /* Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"HELP_CB\", \"\");\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"WID\", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"NAME\", NULL, iupBaseSetNameAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"AUTOTOGGLE\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"KEY\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvItemInitClass(ic);\n\n  return ic;\n}\n\nIclass* iupSubmenuNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"submenu\";\n  ic->format = \"sh\"; /* one string and one Ihandle */\n  ic->nativetype = IUP_TYPEMENU;\n  ic->childtype = IUP_CHILDMANY+1;  /* one child */\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupSubmenuNewClass;\n  ic->Create = iSubmenuCreateMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"HIGHLIGHT_CB\", \"\");\n\n  /* Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"WID\", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"NAME\", NULL, iupBaseSetNameAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"KEY\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvSubmenuInitClass(ic);\n\n  return ic;\n}\n\nIclass* iupMenuNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"menu\";\n  ic->format = \"g\"; /* (Ihandle**) */\n  ic->nativetype = IUP_TYPEMENU;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupMenuNewClass;\n  ic->Create = iMenuCreateMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"OPEN_CB\", \"\");\n  iupClassRegisterCallback(ic, \"MENUCLOSE_CB\", \"\");\n\n  /* Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"WID\", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"NAME\", NULL, iupBaseSetNameAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"RADIO\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvMenuInitClass(ic);\n\n  return ic;\n}\n\n/************************************************************************/\n\nIhandle* IupItem(const char* title, const char* action)\n{\n  void *params[2];\n  params[0] = (void*)title;\n  params[1] = (void*)action;\n  return IupCreatev(\"item\", params);\n}\n\nIhandle* IupSubmenu(const char* title, Ihandle* child)\n{\n  void *params[2];\n  params[0] = (void*)title;\n  params[1] = (void*)child;\n  return IupCreatev(\"submenu\", params);\n}\n\nIhandle *IupMenuv(Ihandle **children)\n{\n  return IupCreatev(\"menu\", (void**)children);\n}\n\nIhandle *IupMenu(Ihandle *child, ...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"menu\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIhandle* IupSeparator(void)\n{\n  return IupCreate(\"separator\");\n}\n","/** \\file\n * \\brief IupMessageDlg class\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n#include \"iup_str.h\"\n\n\nIhandle* IupMessageDlg(void)\n{\n  return IupCreate(\"messagedlg\");\n}\n\nIclass* iupMessageDlgNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"dialog\"));\n\n  ic->name = \"messagedlg\";\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->is_interactive = 1;\n\n  ic->New = iupMessageDlgNewClass;\n\n  /* reset not used native dialog methods */\n  ic->parent->LayoutUpdate = NULL;\n  ic->parent->SetChildrenPosition = NULL;\n  ic->parent->Map = NULL;\n  ic->parent->UnMap = NULL;\n\n  iupdrvMessageDlgInitClass(ic);\n\n  /* only the default values */\n  iupClassRegisterAttribute(ic, \"DIALOGTYPE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"MESSAGE\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BUTTONS\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"OK\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BUTTONDEFAULT\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BUTTONRESPONSE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nvoid IupMessage(const char* title, const char* message)\n{\n  Ihandle* dlg = IupCreate(\"messagedlg\");\n\n  IupSetAttribute(dlg, \"TITLE\", (char*)title);\n  IupSetAttribute(dlg, \"VALUE\", (char*)message);\n  IupSetAttribute(dlg, \"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n\n  IupPopup(dlg, IUP_CENTER, IUP_CENTER);\n  IupDestroy(dlg);\n}\n\nvoid IupMessagef(const char *title, const char *format, ...)\n{\n  int size;\n  char* str = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, format);\n  vsnprintf(str, size, format, arglist);\n  va_end (arglist);\n  IupMessage(title, str);\n}\n","/** \\file\n * \\brief Ihandle <-> Name table manager.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_table.h\"\n#include \"iup_names.h\"\n#include \"iup_object.h\"\n#include \"iup_class.h\"\n#include \"iup_assert.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n\n\nstatic Itable *inames_strtable = NULL;   /* table indexed by name containing Ihandle* address */\n\nvoid iupNamesInit(void)\n{\n  inames_strtable = iupTableCreate(IUPTABLE_STRINGINDEXED);\n}\n\nvoid iupNamesFinish(void)\n{\n  iupTableDestroy(inames_strtable);\n  inames_strtable = NULL;\n}\n\nstatic Ihandle* iNameGetTopParent(Ihandle* ih)\n{\n  Ihandle* parent = ih;\n  while (parent->parent)\n    parent = parent->parent;\n  return parent;\n}\n\nstatic int iNameCheckArray(Ihandle** ih_array, int count, Ihandle* ih)\n{\n  int i;\n  for (i = 0; i < count; i++)\n  {\n    if (ih_array[i] == ih)\n      return 0;\n  }\n  return 1;\n}\n\nvoid iupNamesDestroyHandles(void)\n{\n  char *name;\n  Ihandle** ih_array, *ih;\n  int count, i = 0;\n\n  count = iupTableCount(inames_strtable);\n  if (!count)\n    return;\n\n  ih_array = (Ihandle**)malloc(count * sizeof(Ihandle*));\n\n  /* store the names before updating so we can remove elements in the loop */\n  name = iupTableFirst(inames_strtable);\n  while (name)\n  {\n    ih = (Ihandle*)iupTableGetCurr(inames_strtable);\n    if (iupObjectCheck(ih))   /* here must be a handle */\n    {\n      ih = iNameGetTopParent(ih);\n      if (iNameCheckArray(ih_array, i, ih))\n      {\n        ih_array[i] = ih;\n        i++;\n      }\n    }\n    name = iupTableNext(inames_strtable);\n  }\n\n  count = i;\n  for (i = 0; i < count; i++)\n  {\n    if (iupObjectCheck(ih_array[i]))  /* here must be a handle */\n      IupDestroy(ih_array[i]);\n  }\n\n  free(ih_array);\n}\n\nvoid iupRemoveNames(Ihandle* ih)\n{\n  char *name;\n\n  /* clear the cache */\n  name = iupAttribGet(ih, \"_IUP_LASTHANDLENAME\");\n  if (name)\n    iupTableRemove(inames_strtable, name);\n\n  /* check for an internal name */\n  name = iupAttribGetHandleName(ih);\n  if (name)\n    iupTableRemove(inames_strtable, name);\n\n  iupBaseSetNameAttrib(ih, NULL);\n\n  /* Do NOT search for other names */\n}\n\nIhandle *IupGetHandle(const char *name)\n{\n  if (!name) /* no iupASSERT needed here */\n    return NULL;\n  return (Ihandle*)iupTableGet (inames_strtable, name);\n}\n\nIhandle* IupSetHandle(const char *name, Ihandle *ih)\n{\n  Ihandle *old_ih;\n\n  iupASSERT(name!=NULL);\n  if (!name)\n    return NULL;\n\n  old_ih = iupTableGet(inames_strtable, name);\n\n  if (ih != NULL)\n  {\n    iupTableSet(inames_strtable, name, ih, IUPTABLE_POINTER);\n\n    /* save the name in the cache if it is a valid handle */\n    if (iupObjectCheck(ih))\n      iupAttribSetStr(ih, \"_IUP_LASTHANDLENAME\", name);\n  }\n  else\n  {\n    iupTableRemove(inames_strtable, name);\n\n    /* clear the name from the cache if it is a valid handle */\n    if (iupObjectCheck(old_ih))\n      iupAttribSet(old_ih, \"_IUP_LASTHANDLENAME\", NULL);\n  }\n\n  return old_ih;\n}\n\nint IupGetAllNames(char** names, int n)\n{\n  int i = 0;\n  char* name;\n\n  if (!names || !n)\n    return iupTableCount(inames_strtable);\n\n  name = iupTableFirst(inames_strtable);\n  while (name)\n  {\n    names[i] = name;\n    i++;\n    if (i == n)\n      break;\n\n    name = iupTableNext(inames_strtable);\n  }\n  return i;\n}\n\nstatic int iNamesCountDialogs(void)\n{\n  int i = 0;\n  char* name = iupTableFirst(inames_strtable);\n  while (name)\n  {\n    Ihandle* dlg = (Ihandle*)iupTableGetCurr(inames_strtable);\n    if (iupObjectCheck(dlg) &&  /* here must be a handle */\n        dlg->iclass->nativetype == IUP_TYPEDIALOG)\n      i++;\n\n    name = iupTableNext(inames_strtable);\n  }\n  return i;\n}\n\nint IupGetAllDialogs(char** names, int n)\n{\n  int i = 0;\n  char* name;\n\n  if (!names || !n)\n    return iNamesCountDialogs();\n\n  name = iupTableFirst(inames_strtable);\n  while (name)\n  {\n    Ihandle* dlg = (Ihandle*)iupTableGetCurr(inames_strtable);\n    if (iupObjectCheck(dlg) &&  /* here must be a handle */\n        dlg->iclass->nativetype == IUP_TYPEDIALOG)\n    {\n      names[i] = name;\n      i++;\n      if (i == n)\n        break;\n    }\n\n    name = iupTableNext(inames_strtable);\n  }\n  return i;\n}\n\nchar* IupGetName(Ihandle* ih)\n{\n  char *name;\n  if (!ih) /* no iupASSERT needed here */\n    return NULL;\n\n  if (iupObjectCheck(ih))\n  {\n    /* check the cache first, but must be a handle */\n    name = iupAttribGet(ih, \"_IUP_LASTHANDLENAME\");\n    if (name)\n      return name;\n  }\n\n  /* check for an internal name */\n  name = iupAttribGetHandleName(ih);\n  if (name)\n    return name;\n                               \n  /* search for the name */\n  name = iupTableFirst(inames_strtable);\n  while (name)\n  {\n    if ((Ihandle*)iupTableGetCurr(inames_strtable) == ih)\n      return name;\n\n    name = iupTableNext(inames_strtable);\n  }\n\n  return NULL;\n}\n","/** \\file\n * \\brief Normalizer Element.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_array.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_normalizer.h\"\n\n\nenum {NORMALIZE_NONE, NORMALIZE_WIDTH, NORMALIZE_HEIGHT};\n\nstruct _IcontrolData \n{\n  Iarray* ih_array;\n};\n\nint iupNormalizeGetNormalizeSize(const char* value)\n{\n  if (!value)\n    return NORMALIZE_NONE;\n  if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    return NORMALIZE_WIDTH;\n  if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    return NORMALIZE_HEIGHT;\n  if (iupStrEqualNoCase(value, \"BOTH\"))\n    return NORMALIZE_WIDTH|NORMALIZE_HEIGHT;\n  return NORMALIZE_NONE;\n}\n\nchar* iupNormalizeGetNormalizeSizeStr(int normalize)\n{\n  char* int2str[] = {\"NONE\", \"HORIZONTAL\", \"VERTICAL\", \"BOTH\"};\n  return int2str[normalize];\n}\n\nvoid iupNormalizeSizeBoxChild(Ihandle *ih, int normalize, int children_natural_maxwidth, int children_natural_maxheight)\n{\n  /* It is called from Vbox and Hbox ComputeNaturalSizeMethod after the natural size is calculated */\n  /* reset the natural width and/or height */\n  Ihandle* child;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING) && \n        (child->iclass->nativetype != IUP_TYPEVOID || \n         !IupClassMatch(child, \"fill\")))\n    {\n      if (normalize & NORMALIZE_WIDTH) \n        child->naturalwidth = children_natural_maxwidth;\n      if (normalize & NORMALIZE_HEIGHT)\n        child->naturalheight = children_natural_maxheight;\n    }\n  }\n}\n\nstatic int iNormalizerSetNormalizeAttrib(Ihandle* ih, const char* value)\n{\n  int i, count;\n  Ihandle** ih_list;\n  Ihandle* ih_control;\n  int natural_maxwidth = 0, natural_maxheight = 0;\n  int normalize = iupNormalizeGetNormalizeSize(value);\n  if (!normalize)\n    return 1;\n\n  count = iupArrayCount(ih->data->ih_array);\n  ih_list = (Ihandle**)iupArrayGetData(ih->data->ih_array);\n\n  for (i = 0; i < count; i++)\n  {\n    ih_control = ih_list[i];\n    iupBaseComputeNaturalSize(ih_control);\n    natural_maxwidth = iupMAX(natural_maxwidth, ih_control->naturalwidth);\n    natural_maxheight = iupMAX(natural_maxheight, ih_control->naturalheight);\n  }\n\n  for (i = 0; i < count; i++)\n  {\n    ih_control = ih_list[i];\n    if (!(ih_control->flags & IUP_FLOATING) && \n        (ih_control->iclass->nativetype != IUP_TYPEVOID || \n         !IupClassMatch(ih_control, \"fill\")))\n    {\n      if (normalize & NORMALIZE_WIDTH)\n        ih_control->userwidth = natural_maxwidth;\n      if (normalize & NORMALIZE_HEIGHT)\n        ih_control->userheight = natural_maxheight;\n    }\n  }\n  return 1;\n}\n\nstatic int iNormalizerSetAddControlHandleAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* ih_control = (Ihandle*)value;\n  Ihandle** ih_list = (Ihandle**)iupArrayInc(ih->data->ih_array);\n  int count = iupArrayCount(ih->data->ih_array);\n  ih_list[count-1] = ih_control;\n  return 0;\n}\n\nstatic int iNormalizerSetAddControlAttrib(Ihandle* ih, const char* value)\n{\n  return iNormalizerSetAddControlHandleAttrib(ih, (char*)IupGetHandle(value));\n}\n\nstatic void iNormalizerComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  (void)w;\n  (void)h;\n  (void)children_expand;\n  iNormalizerSetNormalizeAttrib(ih, iupAttribGetStr(ih, \"NORMALIZE\"));\n}\n\nstatic int iNormalizerCreateMethod(Ihandle* ih, void** params)\n{\n  ih->data = iupALLOCCTRLDATA();\n  ih->data->ih_array = iupArrayCreate(10, sizeof(Ihandle*));\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    Ihandle** ih_list;\n    int i = 0;\n    while (*iparams) \n    {\n      ih_list = (Ihandle**)iupArrayInc(ih->data->ih_array);\n      ih_list[i] = *iparams;\n      i++;\n      iparams++;\n    }\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iNormalizerDestroy(Ihandle* ih)\n{\n  iupArrayDestroy(ih->data->ih_array);\n}\n\nIclass* iupNormalizerNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"normalizer\";\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupNormalizerNewClass;\n  ic->Create = iNormalizerCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n  ic->ComputeNaturalSize = iNormalizerComputeNaturalSizeMethod;\n  ic->Destroy = iNormalizerDestroy;\n\n  iupClassRegisterAttribute(ic, \"NORMALIZE\", NULL, iNormalizerSetNormalizeAttrib, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ADDCONTROL_HANDLE\", NULL, iNormalizerSetAddControlHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ADDCONTROL\", NULL, iNormalizerSetAddControlAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle *IupNormalizerv(Ihandle **ih_list)\n{\n  return IupCreatev(\"normalizer\", (void**)ih_list);\n}\n\nIhandle *IupNormalizer(Ihandle* ih_first, ...)\n{\n  Ihandle **ih_list;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, ih_first);\n  ih_list = (Ihandle **)iupObjectGetParamList(ih_first, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"normalizer\", (void**)ih_list);\n  free(ih_list);\n\n  return ih;\n}\n","/** \\file\n * \\brief Ihandle management\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <stdarg.h>  \n#include <memory.h>  \n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_assert.h\"\n#include \"iup_register.h\"\n#include \"iup_names.h\"\n\n\nstatic Ihandle* iHandleCreate(void)\n{\n  Ihandle *ih = (Ihandle*)malloc(sizeof(Ihandle));\n  memset(ih, 0, sizeof(Ihandle));\n\n  ih->sig[0] = 'I';\n  ih->sig[1] = 'U';\n  ih->sig[2] = 'P';\n  ih->sig[3] = 0;\n\n  ih->serial = -1;\n\n  ih->attrib = iupTableCreate(IUPTABLE_STRINGINDEXED);\n\n  return ih;\n}\n\nstatic void iHandleDestroy(Ihandle* ih)\n{\n  iupTableDestroy(ih->attrib);\n  memset(ih, 0, sizeof(Ihandle));\n  free(ih);\n}\n\nint iupObjectCheck(Ihandle* ih)\n{\n  char* sig = (char*)ih;\n\n  if (!ih) return 0;  \n\n  if (sig[0] != 'I' ||\n      sig[1] != 'U' ||\n      sig[2] != 'P' ||\n      sig[3] != 0)\n    return 0;\n\n  return 1;\n}\n\nIhandle* iupObjectCreate(Iclass* iclass, void** params)\n{\n  /* create the base handle structure */\n  Ihandle* ih = iHandleCreate();\n\n  ih->iclass = iclass;\n\n  /* create the element */\n  if (iupClassObjectCreate(ih, params) == IUP_ERROR)\n  {\n    iupERROR1(\"IUP object creation failed (%s).\", iclass->name);\n    iHandleDestroy(ih);\n    return NULL;\n  }\n\n  /* ensure attributes default values, at this time only the ones that can be set before map */\n  iupClassObjectEnsureDefaultAttributes(ih);\n\n  return ih;\n}\n\nvoid** iupObjectGetParamList(void* first, va_list arglist)\n{\n  const int INITIAL_NUMBER = 50;\n  void **params;\n  void *param;\n  int max_count = INITIAL_NUMBER, count = 0;\n\n  params = (void **) malloc (sizeof (void *) * INITIAL_NUMBER);\n\n  param = first;\n\n  while (param != NULL)\n  {\n    params[count] = param;\n    count++;\n\n    /* verifica se precisa realocar memoria */\n    if (count >= max_count)\n    {\n      void **new_params = NULL;\n\n      max_count += INITIAL_NUMBER;\n\n      new_params = (void **) realloc (params, sizeof (void *) * max_count);\n\n      params = new_params;\n    }\n\n    param = va_arg (arglist, void*);\n  }\n  params[count] = NULL;\n\n  return params;\n}\n\nIhandle* IupCreatev(const char *name, void **params)\n{\n  Iclass *ic;\n  iupASSERT(name!=NULL);\n  ic = iupRegisterFindClass(name);\n  if (ic)\n    return iupObjectCreate(ic, params);\n  else\n    return NULL;\n}\n\nIhandle *IupCreatep(const char *name, void* first, ...)\n{\n  va_list arglist;\n  void **params;\n  Ihandle *ih;\n  iupASSERT(name!=NULL);\n\n  va_start(arglist, first);\n  params = iupObjectGetParamList(first, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(name, params);\n  free(params);\n\n  return ih;\n}\n\nIhandle* IupCreate(const char *name)\n{\n  iupASSERT(name!=NULL);\n  return IupCreatev(name, NULL);\n}\n\nvoid IupDestroy(Ihandle *ih)\n{\n  Icallback cb;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  /* Hide before destroy to avoid children redraw */\n  if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n    IupHide(ih);\n\n  cb = IupGetCallback(ih, \"DESTROY_CB\");\n  if (cb) cb(ih);\n\n  cb = IupGetCallback(ih, \"LDESTROY_CB\");  /* for language bindings */\n  if (cb) cb(ih);\n\n  /* Destroy all its children.\n     Just need to remove the first child,\n     IupDetach will update firstchild. */\n  while (ih->firstchild)\n    IupDestroy(ih->firstchild);\n\n  /* unmap if mapped and remove from its parent child list */\n  IupDetach(ih);\n\n  /* removes names associated with the element */\n  iupRemoveNames(ih);\n\n  /* destroy the element */\n  iupClassObjectDestroy(ih);\n\n  /* destroy the private data */\n  if (ih->data)\n    free(ih->data);\n\n  /* destroy the base handle structure */\n  iHandleDestroy(ih);\n}\n","/** \\file\n * \\brief Windows Driver Core\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>             \n#include <stdlib.h>\n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_globalattrib.h\"\n#include \"iup_names.h\"\n#include \"iup_func.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_predialogs.h\"\n#include \"iup_class.h\"\n#include \"iup_register.h\"\n#include \"iup_key.h\"\n#include \"iup_image.h\"\n#include \"iup_dlglist.h\"\n#include \"iup_assert.h\"\n#include \"iup_strmessage.h\"\n\n\nstatic int iup_opened = 0;\nstatic int iup_dummy_argc = 0;\nstatic char** iup_dummy_argv = {0};\n\nint iupIsOpened(void)\n{\n  return iup_opened;\n}\n\nint IupOpen(int *argc, char ***argv)\n{\n  if (iup_opened)\n    return IUP_OPENED;\n  iup_opened = 1;\n\n  if (!argc || !(*argc) || !argv)\n  {\n    argc = &iup_dummy_argc;\n    argv = &iup_dummy_argv;\n  }\n\n  iupNamesInit();\n  iupFuncInit();\n  iupStrMessageInit();\n  iupGlobalAttribInit(); \n  iupRegisterInit();\n  iupKeyInit();\n  iupImageStockInit();\n\n  IupSetLanguage(\"ENGLISH\");\n  IupSetGlobal(\"VERSION\", IupVersion());\n  IupSetGlobal(\"COPYRIGHT\",  IUP_COPYRIGHT);\n\n  if (iupdrvOpen(argc, argv) == IUP_NOERROR)\n  {\n    char* value;\n\n    iupdrvFontInit();\n\n    IupStoreGlobal(\"SYSTEM\", iupdrvGetSystemName());\n    IupStoreGlobal(\"SYSTEMVERSION\", iupdrvGetSystemVersion());\n    IupStoreGlobal(\"COMPUTERNAME\", iupdrvGetComputerName());\n    IupStoreGlobal(\"USERNAME\", iupdrvGetUserName());\n    IupSetGlobal(\"DEFAULTFONT\", iupdrvGetSystemFont());  /* Use SetGlobal because iupdrvGetSystemFont returns a static string */\n    IupSetGlobal(\"DEFAULTPRECISION\", \"2\");\n\n    iupRegisterInternalClasses();\n\n    value = getenv(\"IUP_QUIET\");\n    if (value && !iupStrBoolean(value)) /* if not defined do NOT print */\n      printf(\"IUP %s %s\\n\", IupVersion(), IUP_COPYRIGHT);\n\n    value = getenv(\"IUP_VERSION\");\n    if (iupStrBoolean(value))\n      iupShowVersion();\n\n    return IUP_NOERROR;\n  }\n  else\n  {\n#ifdef  IUP_ASSERT\n    /* can not use pre-defined dialogs here, so only output to console. */\n    fprintf(stderr, \"IUP ERROR: IupOpen failed.\\n\");\n#endif\n    return IUP_ERROR;\n  }\n}\n\nvoid IupClose(void)\n{\n  if (!iup_opened)\n    return;\n  iup_opened = 0;\n\n  iupdrvSetIdleFunction(NULL);  /* stop any idle */\n\n  iupDlgListDestroyAll();    /* destroy all dialogs and their children */\n  iupNamesDestroyHandles();  /* destroy everything that do not belong to a dialog */\n  iupImageStockFinish();     /* release stock images hash table and the images */\n\n  iupRegisterFinish();  /* release native classes */\n\n  iupdrvFontFinish();   /* release font cache */\n  iupdrvClose();        /* release native handles and allocated memory */\n\n  iupGlobalAttribFinish();  /* release global hash table */\n  iupStrMessageFinish();    /* release messages hash table */\n  iupFuncFinish();          /* release callbacks hash table */\n  iupNamesFinish();         /* release names hash table */\n\n  iupStrGetMemory(-1); /* Frees internal buffer */\n}\n","/** \\file\n * \\brief pre-defined dialogs\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <time.h>\n\n#include \"iup.h\" \n\n#include \"iup_predialogs.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_strmessage.h\"\n               \n\nstatic int CB_button_OK (Ihandle* ih)\n{\n  iupAttribSet(IupGetDialog(ih), \"STATUS\", \"1\");\n  return IUP_CLOSE;\n}\n\nstatic int CB_button_CANCEL (Ihandle* ih)\n{\n  iupAttribSet(IupGetDialog(ih), \"STATUS\", \"-1\");\n  return IUP_CLOSE;\n}\n\nstatic int CB_dblclick(Ihandle *ih, int item, char *text)\n{\n  (void)text;\n  iupAttribSetInt(IupGetDialog(ih), \"_IUP_LIST_NUMBER\", item-1);\n  iupAttribSet(IupGetDialog(ih), \"STATUS\", \"1\");\n  return IUP_CLOSE;\n}\n\nstatic int CB_list (Ihandle *ih, char *text, int item, int state)\n{\n  (void)text;\n  if (state)\n    iupAttribSetInt(IupGetDialog(ih), \"_IUP_LIST_NUMBER\", item-1);\n  return IUP_DEFAULT;\n}\n\nint IupListDialog (int type, const char *title, int size, const char** list_str,\n                   int op, int max_col, int max_lin, int* marks)\n{\n  Ihandle *lst, *ok, *dlg, *cancel, *dlg_box, *button_box;\n  int i, bt;\n  char *m=NULL;\n\n  if (size > 999)\n    size = 999;\n\n  lst = IupList(NULL);\n\n  for (i=0;i<size;i++)\n    IupSetAttributeId(lst,\"\",i+1,list_str[i]);\n  IupSetAttributeId(lst,\"\",i+1,NULL);\n  IupSetAttribute(lst,\"EXPAND\",\"YES\");\n\n  ok = IupButton(\"_@IUP_OK\", NULL);\n  IupSetAttribute(ok,\"PADDING\" ,\"20x0\");\n  IupSetCallback(ok, \"ACTION\", (Icallback)CB_button_OK);\n\n  cancel = IupButton(\"_@IUP_CANCEL\", NULL);\n  IupSetAttribute(cancel,\"PADDING\" ,\"20x0\");\n  IupSetCallback(cancel, \"ACTION\", (Icallback)CB_button_CANCEL);\n\n  button_box = IupHbox(\n    IupFill(), \n    ok,\n    cancel,\n    NULL);\n  IupSetAttribute(button_box,\"MARGIN\",\"0x0\");\n  IupSetAttribute(button_box, \"NORMALIZESIZE\", \"HORIZONTAL\");\n\n  dlg_box = IupVbox(\n    lst,\n    button_box,\n    NULL);\n\n  IupSetAttribute(dlg_box,\"MARGIN\",\"10x10\");\n  IupSetAttribute(dlg_box,\"GAP\",\"10\");\n\n  dlg = IupDialog(dlg_box);\n\n  if (type == 1)\n  {\n    if (op<1 || op>size) op=1;\n    iupAttribSetInt(dlg, \"_IUP_LIST_NUMBER\", op-1);\n    IupSetInt(lst,\"VALUE\",op);\n    IupSetCallback(lst, \"ACTION\", (Icallback)CB_list);\n    IupSetCallback(lst, \"DBLCLICK_CB\", (Icallback)CB_dblclick);\n  }\n  else if ((type == 2) && (marks != NULL))\n  {\n    m=(char *)marks;\n    for (i=0;i<size;i++)\n      m[i] = marks[i] ? '+' : '-';\n    m[i]='\\0';\n    IupSetAttribute(lst,\"MULTIPLE\",\"YES\");\n    IupSetAttribute(lst,\"VALUE\",m);\n  }\n\n  if (max_lin < 4) max_lin = 4;\n  IupSetInt(lst, \"VISIBLELINES\", max_lin);\n  IupSetInt(lst, \"VISIBLECOLUMNS\", max_col);\n\n  IupSetStrAttribute(dlg,\"TITLE\", title);\n  IupSetAttribute(dlg,\"MINBOX\",\"NO\");\n  IupSetAttribute(dlg,\"MAXBOX\",\"NO\");\n  IupSetAttributeHandle(dlg,\"DEFAULTENTER\", ok);\n  IupSetAttributeHandle(dlg,\"DEFAULTESC\", cancel);\n  IupSetAttribute(dlg,\"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg,\"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupPopup(dlg,IUP_CENTERPARENT,IUP_CENTERPARENT);\n\n  if ((type == 2) && (marks != NULL))\n  {\n    m=IupGetAttribute(lst,\"VALUE\");\n    for (i=0;i<size;i++)\n      marks[i] = (m[i] == '+');\n  }\n\n  bt = IupGetInt(dlg, \"STATUS\");\n  if (type == 1)\n  {\n    if (bt == 1)\n      bt = iupAttribGetInt(dlg, \"_IUP_LIST_NUMBER\");\n    else\n      bt = -1;\n  }\n  else\n  {\n    if (bt != 1)\n      bt = -1;\n  }\n\n  IupDestroy(dlg);\n\n  return bt;\n}\n\nstatic int iAlarmButtonAction_CB(Ihandle *ih)\n{\n  iupAttribSet(IupGetDialog(ih), \"_IUP_BUTTON_NUMBER\", iupAttribGet(ih, \"_IUP_BUTTON_NUMBER\"));\n  return IUP_CLOSE;\n}\n\nint IupAlarm(const char *title, const char *msg, const char *b1, const char *b2, const char *b3)\n{\n  Ihandle  *dlg, *dlg_box, *button_box, *button, *default_esc, *default_enter;\n  int bt, len;\n  char* padding;\n\n  msg = msg? msg: \"\";\n\n  if (b1 == NULL)\n    return 0;\n\n  len = (int)strlen(b1);\n  if (b2)\n  {\n    int len2 = (int)strlen(b2);\n    if (len2 > len)\n      len = len2;\n  }\n  if (b3)\n  {\n    int len3 = (int)strlen(b3);\n    if (len3 > len)\n      len = len3;\n  }\n\n  if (len > 7)\n    padding = \"12x2\";\n  else\n    padding = \"20x0\";\n\n  button_box = IupHbox(NULL);\n  IupSetAttribute(button_box, \"NORMALIZESIZE\", \"HORIZONTAL\");\n  IupSetAttribute(button_box,\"MARGIN\",\"0x0\");\n  IupAppend(button_box, IupFill()); /* to center the buttons */\n\n  button = IupButton(b1, NULL);\n  iupAttribSet(button, \"_IUP_BUTTON_NUMBER\", \"1\");\n  IupSetAttribute(button, \"PADDING\", padding);\n  IupAppend(button_box, button);\n  IupSetCallback (button, \"ACTION\", (Icallback)iAlarmButtonAction_CB);\n  default_enter = button;\n  default_esc = button;\n\n  if (b2 != NULL)\n  {\n    button = IupButton(b2, NULL);\n    iupAttribSet(button, \"_IUP_BUTTON_NUMBER\", \"2\");\n    IupSetAttribute(button, \"PADDING\", padding);\n    IupAppend(button_box, button);\n    IupSetCallback (button, \"ACTION\", (Icallback)iAlarmButtonAction_CB);\n    default_esc = button;\n  }\n\n  if (b3 != NULL)\n  {\n    button = IupButton(b3, NULL);\n    iupAttribSet(button, \"_IUP_BUTTON_NUMBER\", \"3\");\n    IupSetAttribute(button, \"PADDING\", padding);\n    IupAppend(button_box, button);\n    IupSetCallback (button, \"ACTION\", (Icallback)iAlarmButtonAction_CB);\n    default_esc = button;\n  }\n\n  IupAppend(button_box, IupFill()); /* to center the buttons */\n\n  dlg_box = IupVbox(\n    IupLabel(msg),\n    IupSetAttributes(IupLabel(NULL), \"SEPARATOR=HORIZONTAL\"),\n    button_box,\n    NULL);\n\n  IupSetAttribute(dlg_box,\"MARGIN\",\"10x10\");\n  IupSetAttribute(dlg_box,\"GAP\",\"10\");\n\n  dlg = IupDialog(dlg_box);\n\n  IupSetStrAttribute(dlg,\"TITLE\", title);\n  IupSetAttribute(dlg,\"DIALOGFRAME\",\"YES\");\n  IupSetAttribute(dlg,\"DIALOGHINT\",\"YES\");\n  IupSetAttributeHandle(dlg,\"DEFAULTENTER\", default_enter);\n  IupSetAttributeHandle(dlg,\"DEFAULTESC\", default_esc);\n  IupSetAttribute(dlg,\"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg,\"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupPopup(dlg,IUP_CENTERPARENT,IUP_CENTERPARENT);\n\n  bt = iupAttribGetInt(dlg, \"_IUP_BUTTON_NUMBER\");\n\n  IupDestroy(dlg);\n\n  return bt;\n}\n\nint  iupDataEntry(int    maxlin,\n                  int*   maxcol,\n                  int*   maxscr,\n                  char*  title,\n                  char** text,\n                  char** data)\n{\n  int i, bt;\n  Ihandle *ok, *cancel, *dlg, *vb, *hb, **txt, **lbl, *button_box, *dlg_box;\n\n  txt = (Ihandle **)calloc(maxlin, sizeof(Ihandle*));\n  if (txt == NULL) return -2;\n  lbl = (Ihandle **)calloc(maxlin+1, sizeof(Ihandle*));\n\n  vb = IupVbox(NULL);\n\n  for (i=0; i<maxlin; i++)\n  {\n    txt[i] = IupText(NULL);\n    IupSetAttribute(txt[i],\"VALUE\",data[i]);\n    IupSetInt(txt[i],\"VISIBLECOLUMNS\", maxscr[i]);\n    IupSetInt(txt[i],\"NC\", maxcol[i]);\n    IupSetAttribute(txt[i],\"EXPAND\",\"HORIZONTAL\");\n\n    hb = IupHbox(lbl[i] = IupLabel(text[i]), txt[i], NULL);\n    IupSetAttribute(hb,\"MARGIN\",\"0x0\");\n    IupSetAttribute(hb,\"ALIGNMENT\",\"ACENTER\");\n    IupAppend(vb, hb);\n  }\n  lbl[i] = NULL;\n  IupInsert(vb, NULL, IupNormalizerv(lbl));\n\n  ok = IupButton(\"_@IUP_OK\", NULL);\n  IupSetAttribute(ok, \"PADDING\", \"20x0\");\n  IupSetCallback(ok, \"ACTION\", (Icallback)CB_button_OK);\n\n  cancel = IupButton(\"_@IUP_CANCEL\", NULL);\n  IupSetAttribute(cancel, \"PADDING\", \"20x0\");\n  IupSetCallback(cancel, \"ACTION\", (Icallback)CB_button_CANCEL);\n\n  button_box = IupHbox(\n    IupFill(), \n    ok,\n    cancel,\n    NULL);\n  IupSetAttribute(button_box,\"MARGIN\",\"0x0\");\n  IupSetAttribute(button_box, \"NORMALIZESIZE\", \"HORIZONTAL\");\n\n  dlg_box = IupVbox(\n    IupFrame(vb),\n    button_box,\n    NULL);\n  IupSetAttribute(dlg_box,\"MARGIN\",\"10x10\");\n  IupSetAttribute(dlg_box,\"GAP\",\"5\");\n\n  dlg = IupDialog(dlg_box);\n\n  IupSetStrAttribute(dlg,\"TITLE\",title);\n  IupSetAttribute(dlg,\"MINBOX\",\"NO\");\n  IupSetAttribute(dlg,\"MAXBOX\",\"NO\");\n  IupSetAttributeHandle(dlg,\"DEFAULTENTER\", ok);\n  IupSetAttributeHandle(dlg,\"DEFAULTESC\", cancel);\n  IupSetAttribute(dlg,\"PARENTDIALOG\",IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg,\"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupMap(dlg);\n\n  IupSetfAttribute(dlg,\"MAXSIZE\", \"65535x%d\", IupGetInt2(dlg, \"RASTERSIZE\"));\n  IupSetAttribute(dlg,\"MINSIZE\", IupGetAttribute(dlg, \"RASTERSIZE\"));\n\n  IupPopup(dlg,IUP_CENTERPARENT,IUP_CENTERPARENT);\n\n  for (i=0; i<maxlin; i++)\n  {\n    iupStrCopyN(data[i], maxcol[i]+1, IupGetAttribute(txt[i], \"VALUE\"));\n  }\n\n  free(lbl);\n  free(txt);\n\n  bt = IupGetInt(dlg, \"STATUS\");\n  IupDestroy(dlg);\n  return bt;\n}\n\nint IupGetFile(char* filename)\n{\n  Ihandle *dlg = 0;\n  int ret;\n  char filter[4096] = \"*.*\";\n  static char dir[4096] = \"\";  /* static will make the dir persist from one call to another if not defined */\n\n  if (!filename) return -1;\n\n  dlg = IupFileDlg();\n\n  iupStrFileNameSplit(filename, dir, filter);\n\n  IupSetAttribute(dlg, \"FILTER\", filter);\n  IupSetAttribute(dlg, \"DIRECTORY\", dir);\n  IupSetAttribute(dlg, \"ALLOWNEW\", \"YES\");\n  IupSetAttribute(dlg, \"NOCHANGEDIR\", \"YES\");\n  IupSetAttribute(dlg, \"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg, \"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupPopup(dlg, IUP_CENTERPARENT, IUP_CENTERPARENT);\n\n  ret = IupGetInt(dlg, \"STATUS\");\n  if (ret != -1)\n  {\n    char* value = IupGetAttribute(dlg, \"VALUE\");\n    if (value) \n    {\n      iupStrCopyN(filename, 4096, value);\n      iupStrFileNameSplit(filename, dir, NULL);\n    }\n  }\n\n  IupDestroy(dlg);\n\n  return ret;\n}\n\nint IupGetText(const char* title, char* text)\n{\n  Ihandle *ok, *cancel, *multi_text, *button_box, *dlg_box, *dlg;\n  int bt;\n\n  multi_text = IupMultiLine(NULL);\n  IupSetAttribute(multi_text,\"EXPAND\", \"YES\");\n  IupSetAttribute(multi_text,\"VALUE\", text);\n  IupSetAttribute(multi_text,\"FONT\", \"Courier, 12\");\n  IupSetAttribute(multi_text, \"VISIBLELINES\", \"10\");\n  IupSetAttribute(multi_text, \"VISIBLECOLUMNS\", \"50\");\n\n  ok = IupButton(\"_@IUP_OK\", NULL);\n  IupSetAttribute(ok, \"PADDING\", \"20x0\");\n  IupSetCallback(ok, \"ACTION\", (Icallback)CB_button_OK);\n\n  cancel  = IupButton(\"_@IUP_CANCEL\", NULL);\n  IupSetAttribute(cancel, \"PADDING\", \"20x0\");\n  IupSetCallback(cancel, \"ACTION\", (Icallback)CB_button_CANCEL);\n\n  button_box = IupHbox(\n    IupFill(),\n    ok,\n    cancel,\n    NULL);\n  IupSetAttribute(button_box,\"MARGIN\",\"0x0\");\n  IupSetAttribute(button_box, \"NORMALIZESIZE\", \"HORIZONTAL\");\n\n  dlg_box = IupVbox(\n    multi_text,\n    button_box,\n    NULL);\n\n  IupSetAttribute(dlg_box,\"MARGIN\",\"10x10\");\n  IupSetAttribute(dlg_box,\"GAP\",\"10\");\n\n  dlg = IupDialog (dlg_box);\n\n  IupSetStrAttribute(dlg,\"TITLE\", title);\n  IupSetAttribute(dlg,\"MINBOX\",\"NO\");\n  IupSetAttribute(dlg,\"MAXBOX\",\"NO\");\n  IupSetAttributeHandle(dlg,\"DEFAULTENTER\", ok);\n  IupSetAttributeHandle(dlg,\"DEFAULTESC\", cancel);\n  IupSetAttribute(dlg,\"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg,\"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupMap(dlg);\n\n  IupSetAttribute(multi_text, \"VISIBLELINES\", NULL);\n  IupSetAttribute(multi_text, \"VISIBLECOLUMNS\", NULL);\n\n  IupPopup(dlg, IUP_CENTERPARENT, IUP_CENTERPARENT);\n\n  bt = IupGetInt(dlg, \"STATUS\");\n  if (bt==1)\n    iupStrCopyN(text, 10240, IupGetAttribute(multi_text, \"VALUE\"));\n  else\n    bt = 0; /* return 0 instead of -1 */\n\n  IupDestroy(dlg);\n  return bt;\n}\n\nint IupGetColor(int x, int y, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n  int ret;\n  Ihandle* dlg = IupColorDlg();\n\n  IupSetStrAttribute(dlg, \"TITLE\",  \"_@IUP_GETCOLOR\");\n  IupSetfAttribute(dlg, \"VALUE\", \"%d %d %d\", *r, *g, *b);\n  IupSetAttribute(dlg, \"PARENTDIALOG\", IupGetGlobal(\"PARENTDIALOG\"));\n  IupSetAttribute(dlg, \"ICON\", IupGetGlobal(\"ICON\"));\n\n  IupPopup(dlg, x, y);\n\n  ret = IupGetInt(dlg, \"STATUS\");\n  if (ret)\n    iupStrToRGB(IupGetAttribute(dlg, \"VALUE\"), r, g, b);\n\n  IupDestroy(dlg);\n\n  return ret;\n}\n\nvoid iupShowVersion(void)\n{\n  Ihandle* dlg;\n\n  dlg = IupDialog(IupVbox(IupFrame(IupVbox(\n                      IupLabel(IupVersion()),\n                      IupLabel(IupVersionDate()),\n                      IupLabel(IUP_COPYRIGHT),\n                      NULL)), \n                    IupButton(\"_@IUP_OK\", NULL),\n                    NULL));\n\n  IupSetAttribute(dlg,\"TITLE\",\"IUP Version\");\n  IupSetAttribute(dlg,\"DIALOGFRAME\",\"YES\");\n  IupSetAttribute(dlg,\"DIALOGHINT\",\"YES\");\n  IupSetAttribute(dlg,\"GAP\",\"10\");\n  IupSetAttribute(dlg,\"MARGIN\",\"10x10\");\n\n  IupPopup(dlg, IUP_CENTERPARENT, IUP_CENTERPARENT);\n  IupDestroy(dlg);\n}\n\nvoid iupShowError(Ihandle* parent, const char* message)\n{\n  Ihandle* dlg = IupMessageDlg();\n  char* title = NULL, *str_message;\n\n  if (parent)\n  {\n    IupSetAttributeHandle(dlg, \"PARENTDIALOG\", parent);\n    title = IupGetAttribute(parent, \"TITLE\");\n  }\n\n  if (!title)\n    title = \"_@IUP_ERROR\";\n\n  IupSetStrAttribute(dlg, \"TITLE\", title);\n  IupSetAttribute(dlg, \"DIALOGTYPE\", \"ERROR\");\n  IupSetAttribute(dlg, \"BUTTONS\", \"OK\");\n\n  str_message = IupGetLanguageString(message);\n  if (!str_message)\n    str_message = (char*)message;\n  IupStoreAttribute(dlg, \"VALUE\", str_message);\n\n  IupPopup(dlg, IUP_CURRENT, IUP_CURRENT);\n\n  IupDestroy(dlg);\n}\n\n","/** \\file\n * \\brief ProgressBar control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_progressbar.h\"\n\n\nvoid iProgressBarCropValue(Ihandle* ih)\n{\n  if(ih->data->value > ih->data->vmax)\n    ih->data->value = ih->data->vmax;\n  else if(ih->data->value < ih->data->vmin)\n    ih->data->value = ih->data->vmin;\n}\n\nchar* iProgressBarGetValueAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->value);\n}\n\nchar* iProgressBarGetDashedAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean(ih->data->dashed);\n}\n\nstatic int iProgressBarSetMinAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToDouble(value, &(ih->data->vmin)))\n    iProgressBarCropValue(ih);\n  return 0;\n}\n\nstatic char* iProgressBarGetMinAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->vmin);\n}\n\nstatic int iProgressBarSetMaxAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToDouble(value, &(ih->data->vmax)))\n    iProgressBarCropValue(ih);\n  return 0;\n}\n\nstatic char* iProgressBarGetMaxAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->vmax);\n}\n\nstatic int iProgressBarCreateMethod(Ihandle* ih, void **params)\n{\n  (void)params;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  /* default values */\n  ih->data->vmax      = 1;\n  ih->data->dashed    = 0;\n\n  /* progress bar default size is 200x30 */\n  IupSetAttribute(ih, \"RASTERSIZE\", \"200x30\");\n\n  return IUP_NOERROR;\n}\n\nstatic void iProgressBarDestroyMethod(Ihandle* ih)\n{\n  if (ih->data->timer)\n    IupDestroy(ih->data->timer);\n}\n\nIclass* iupProgressBarNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"progressbar\";\n  ic->format = NULL; /* no parameters */\n  ic->nativetype  = IUP_TYPECONTROL;\n  ic->childtype   = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupProgressBarNewClass;\n  ic->Create = iProgressBarCreateMethod;\n  ic->Destroy = iProgressBarDestroyMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Common Callbacks */\n  iupClassRegisterCallback(ic, \"MAP_CB\", \"\");\n  iupClassRegisterCallback(ic, \"UNMAP_CB\", \"\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* IupProgressBar only */\n  iupClassRegisterAttribute(ic, \"MIN\", iProgressBarGetMinAttrib, iProgressBarSetMinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MAX\", iProgressBarGetMaxAttrib, iProgressBarSetMaxAttrib, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NOT_MAPPED);\n\n  iupdrvProgressBarInitClass(ic);\n\n  return ic;\n}\n\nIhandle *IupProgressBar(void)\n{\n  return IupCreate(\"progressbar\");\n}\n","/** \\file\n * \\brief IupProgressDlg pre-defined dialog control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_strmessage.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n#include \"iup_childtree.h\"\n\n\n#define MIN_CLOCK 250   /* aprox in milliseconds */\n       \ntypedef struct _IprogressDlgData\n{\n  Ihandle *progress, \n          *description;  /* label for the secondary description */\n\n  int state,          /* flag indicating if it was interrupted */\n      percent,         /* current percent value */\n      count, total_count,\n      last_clock;      /* last time it was updated */\n} IprogressDlgData;\n\n\nstatic void iProgressDlgSetPercent(IprogressDlgData* progress_data, int percent)\n{\n  int cur_clock;\n\n  if (progress_data->state == 0)  /* from IDLE */\n    progress_data->state = 1;  /* to PROCESSING */\n\n  if (progress_data->state != 1)\n    return;\n\n  /* only set if a significant amount of time passed */\n  cur_clock = (int)clock();\n  if (cur_clock > progress_data->last_clock + MIN_CLOCK)\n  {\n    /* avoid duplicate updates */\n    if (percent != progress_data->percent)\n    {\n      IupSetInt(progress_data->progress, \"VALUE\", percent);\n      IupFlush();\n      progress_data->last_clock = (int)clock();\n    }\n  }\n\n  progress_data->percent = percent;\n\n  IupLoopStep();\n}\n\n/**************************************************************************************************************/\n/*                                     Attributes                                                             */\n/**************************************************************************************************************/\n\nstatic int iProgressDlgSetTotalCountAttrib(Ihandle* ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  iupStrToInt(value, &(progress_data->total_count));\n  if (progress_data->total_count <= 0) progress_data->total_count = 1;\n  return 0;\n}\n\nstatic char* iProgressDlgGetTotalCountAttrib(Ihandle *ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  return iupStrReturnInt(progress_data->total_count);\n}\n\nstatic int iProgressDlgSetCountAttrib(Ihandle* ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  if (iupStrToInt(value, &(progress_data->count)) && (progress_data->count >= 0 && progress_data->count <= progress_data->total_count))\n    iProgressDlgSetPercent(progress_data, (progress_data->count*100)/progress_data->total_count);\n  return 0;\n}\n\nstatic char* iProgressDlgGetCountAttrib(Ihandle *ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  return iupStrReturnInt(progress_data->count);\n}\n\nstatic int iProgressDlgSetIncAttrib(Ihandle* ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  int inc = 1;\n  iupStrToInt(value, &inc);\n  progress_data->count += inc;\n  if (progress_data->count < 0) progress_data->count = 0;\n  if (progress_data->count > progress_data->total_count) progress_data->count = progress_data->total_count;\n  iProgressDlgSetPercent(progress_data, (progress_data->count*100)/progress_data->total_count);\n  return 0;\n}\n\nstatic char* iProgressDlgGetStateAttrib(Ihandle *ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  if (progress_data->state==-1)\n    return \"ABORTED\";\n  else if (progress_data->state==1)\n    return \"PROCESSING\";\n  else if (progress_data->state==2)\n    return \"UNDEFINED\";\n  else\n    return \"IDLE\";\n}\n\nstatic void iProgressDlgStopMarquee(IprogressDlgData* progress_data)\n{\n  Ihandle* zbox = IupGetParent(progress_data->progress);\n  if (IupGetInt(zbox, \"VALUEPOS\")==1)\n  {\n    Ihandle* marquee = IupGetBrother(progress_data->progress);\n    IupSetAttribute(marquee, \"MARQUEE\", \"No\");\n  }\n}\n\nstatic int iProgressDlgSetStateAttrib(Ihandle *ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n\n  if (iupStrEqualNoCase(value, \"ABORTED\"))\n  {\n    iProgressDlgStopMarquee(progress_data);\n    progress_data->state = -1;\n  }\n  else if (iupStrEqualNoCase(value, \"PROCESSING\"))\n  {\n    Ihandle* zbox = IupGetParent(progress_data->progress);\n    IupSetAttribute(zbox, \"VALUEPOS\", \"0\");\n    progress_data->state = 1;\n  }\n  else if (iupStrEqualNoCase(value, \"UNDEFINED\"))\n  {\n    Ihandle* zbox = IupGetParent(progress_data->progress);\n    Ihandle* marquee = IupGetBrother(progress_data->progress);\n    IupSetAttribute(zbox, \"VALUEPOS\", \"1\");\n    IupSetAttribute(marquee, \"MARQUEE\", \"Yes\");\n    progress_data->state = 2;\n  }\n  else  /* IDLE */\n  {\n    progress_data->state = 0;\n    progress_data->percent = 0;\n    progress_data->count = 0;\n    IupSetAttribute(progress_data->progress, \"VALUE\", \"0\");\n    iProgressDlgStopMarquee(progress_data);\n  }\n  return 0;\n}\n\nstatic int iProgressDlgSetPercentAttrib(Ihandle* ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  int percent;\n  if (iupStrToInt(value, &percent) && (percent >=0 && percent <=100))\n    iProgressDlgSetPercent(progress_data, percent);\n  return 0;\n}\n\nstatic char* iProgressDlgGetPercentAttrib(Ihandle* ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  return iupStrReturnInt(progress_data->percent);\n}\n\nstatic int iProgressDlgSetDescriptionAttrib(Ihandle* ih, const char* value)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  IupStoreAttribute(progress_data->description, \"TITLE\", (char*)value);\n  IupFlush();\n  return 0;\n}\n\nstatic char* iProgressDlgGetDescriptionAttrib(Ihandle* ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  return IupGetAttribute(progress_data->description, \"TITLE\");\n}\n\n/**************************************************************************************************************/\n/*                                     Internal Callbacks                                                     */\n/**************************************************************************************************************/\n\nstatic int iProgressDlgCancel_CB(Ihandle* button)\n{\n  Ihandle* ih = IupGetDialog(button);\n  Icallback cb = IupGetCallback(ih, \"CANCEL_CB\");\n\n  if (!cb || cb(ih) != IUP_CONTINUE)\n    iProgressDlgSetStateAttrib(ih, \"ABORTED\");\n\n  return IUP_DEFAULT;\n}\n\n/**************************************************************************************************************/\n/*                                     Methods                                                                */\n/**************************************************************************************************************/\n\nstatic void iProgressDlgDestroyMethod(Ihandle* ih)\n{\n  IprogressDlgData* progress_data = (IprogressDlgData*)iupAttribGet(ih, \"_IUP_PDLG_DATA\");\n  free(progress_data);\n}\n\nstatic int iProgressDlgCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle *lbl, *progress, *marquee, *cancel, *vbox;\n  IprogressDlgData* progress_data = (IprogressDlgData*)malloc(sizeof(IprogressDlgData));\n  memset(progress_data, 0, sizeof(IprogressDlgData));\n  iupAttribSet(ih, \"_IUP_PDLG_DATA\", (char*)progress_data);\n\n  lbl = IupLabel(\"\");\n  IupSetAttribute(lbl,\"EXPAND\",\"YES\");\n\n  progress = IupProgressBar();\n  IupSetAttribute(progress,\"RASTERSIZE\",\"250x30\");\n  IupSetAttribute(progress,\"EXPAND\",\"HORIZONTAL\");\n  IupSetAttribute(progress,\"MAX\",\"100\");\n\n  marquee = IupProgressBar();\n  IupSetAttribute(marquee,\"RASTERSIZE\",\"250x30\");\n  IupSetAttribute(marquee,\"EXPAND\",\"HORIZONTAL\");\n  IupSetAttribute(marquee,\"MARQUEE\",\"Yes\");\n  IupSetAttribute(marquee,\"VISIBLE\",\"No\");\n\n  cancel = IupButton(\"_@IUP_CANCEL\", NULL);\n  IupSetAttribute(cancel,\"PADDING\",\"5x3\");\n  IupSetCallback(cancel, \"ACTION\", (Icallback) iProgressDlgCancel_CB);\n  IupSetAttributeHandle(ih, \"DEFAULTESC\", cancel);\n\n  vbox = IupVbox(lbl, IupZbox(progress, marquee, NULL), cancel, NULL);\n  IupSetAttribute(vbox,\"MARGIN\",\"5x5\");\n  IupSetAttribute(vbox,\"GAP\",\"5x5\");\n  IupSetAttribute(vbox,\"ALIGNMENT\",\"ACENTER\");\n\n  /* Do not use IupAppend because we set childtype=IUP_CHILDNONE */\n  iupChildTreeAppend(ih, vbox);\n  IupSetAttribute(ih,\"RESIZE\",\"NO\");\n  IupSetAttribute(ih,\"MAXBOX\",\"NO\");\n  IupSetAttribute(ih,\"MINBOX\",\"NO\");\n  IupSetAttribute(ih,\"MENUBOX\",\"NO\");\n\n  progress_data->progress = progress;\n  progress_data->description = lbl;\n\n  progress_data->total_count = 1;\n  progress_data->last_clock = clock();\n\n  (void)params;\n  return IUP_NOERROR;\n}\n\nIclass* iupProgressDlgNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"dialog\"));\n\n  ic->New = iupProgressDlgNewClass;\n  ic->Create = iProgressDlgCreateMethod;\n  ic->Destroy = iProgressDlgDestroyMethod;\n\n  ic->name = \"progressdlg\";\n  ic->nativetype = IUP_TYPEDIALOG;\n  ic->is_interactive = 1;\n  ic->childtype = IUP_CHILDNONE;\n\n  iupClassRegisterCallback(ic, \"CANCEL_CB\", \"\");\n\n  iupClassRegisterAttribute(ic, \"TOTALCOUNT\", iProgressDlgGetTotalCountAttrib, iProgressDlgSetTotalCountAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"COUNT\", iProgressDlgGetCountAttrib, iProgressDlgSetCountAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"INC\", NULL, iProgressDlgSetIncAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PERCENT\", iProgressDlgGetPercentAttrib, iProgressDlgSetPercentAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"STATE\", iProgressDlgGetStateAttrib, iProgressDlgSetStateAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DESCRIPTION\", iProgressDlgGetDescriptionAttrib, iProgressDlgSetDescriptionAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle* IupProgressDlg(void)\n{\n  return IupCreate(\"progressdlg\");\n}\n\n","/** \\file\n * \\brief Radio Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n\n\nIhandle *iupRadioFindToggleParent(Ihandle* ih_toggle)\n{\n  Ihandle *p;\n  for (p=ih_toggle; p->parent; p=p->parent)\n  {\n    if (p->iclass->nativetype == IUP_TYPEVOID &&\n        IupClassMatch(p, \"radio\"))\n      return p;\n  }\n\n  return NULL;\n}\n\nstatic int iRadioFindToggleChild(Ihandle* ih, Ihandle* ih_toggle)\n{\n  Ihandle* child;\n\n  if (ih == ih_toggle) /* found child that match the toggle */\n    return 1;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (iRadioFindToggleChild(child, ih_toggle))\n      return 1;\n  }\n\n  return 0;\n}\n\nstatic int iRadioChildIsToggle(Ihandle* child)\n{\n  if (IupClassMatch(child, \"toggle\") || \n      IupClassMatch(child, \"gltoggle\") ||\n      (IupClassMatch(child, \"flatbutton\") && iupAttribGetBoolean(child, \"TOGGLE\")))\n    return 1;\n  else\n    return 0;\n}\n\nstatic Ihandle* iRadioGetToggleChildOn(Ihandle* ih)\n{\n  Ihandle* child;\n\n  /* found child that is a toggle and it is ON */\n  if (iRadioChildIsToggle(ih) && IupGetInt(ih, \"VALUE\"))\n    return ih;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    Ihandle* ih_toggle = iRadioGetToggleChildOn(child);\n    if (ih_toggle)\n      return ih_toggle;\n  }\n\n  return NULL;\n}\n\n/******************************************************************************/\n\n\nstatic int iRadioSetValueHandleAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* ih_toggle = (Ihandle*)value;\n  if (!iupObjectCheck(ih_toggle))\n    return 0;\n\n  if (!iRadioChildIsToggle(ih_toggle))\n    return 0;\n\n  if (iRadioFindToggleChild(ih->firstchild, ih_toggle))\n    IupSetAttribute(ih_toggle, \"VALUE\", \"ON\");\n \n  return 0;\n}\n\nstatic char* iRadioGetValueHandleAttrib(Ihandle* ih)\n{\n  return (char*)iRadioGetToggleChildOn(ih->firstchild);\n}\n\nstatic int iRadioSetValueAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle *ih_toggle;\n\n  if (!value)\n    return 0;\n\n  ih_toggle = IupGetHandle(value);\n  if (!ih_toggle)\n    return 0;\n\n  iRadioSetValueHandleAttrib(ih, (char*)ih_toggle);\n  return 0;\n}\n\nstatic char* iRadioGetValueAttrib(Ihandle* ih)\n{\n  Ihandle *ih_toggle = (Ihandle*)iRadioGetValueHandleAttrib(ih);\n  return IupGetName(ih_toggle);\n}\n\n/******************************************************************************/\n\n\nstatic int iRadioCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n  return IUP_NOERROR;\n}\n\nstatic void iRadioComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child = ih->firstchild;\n  if (child)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    *children_expand = child->expand;\n    *w = child->naturalwidth;\n    *h = child->naturalheight;\n  }\n}\n\nstatic void iRadioSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  if (ih->firstchild)\n    iupBaseSetCurrentSize(ih->firstchild, ih->currentwidth, ih->currentheight, shrink);\n}\n\nstatic void iRadioSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild)\n    iupBaseSetPosition(ih->firstchild, x, y);\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupRadio(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"radio\", children);\n}\n\nIclass* iupRadioNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"radio\";\n  ic->format = \"h\"; /* one Ihandle* */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY+1;  /* one child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupRadioNewClass;\n  ic->Create = iRadioCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n  ic->ComputeNaturalSize = iRadioComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iRadioSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iRadioSetChildrenPositionMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iupBaseGetCurrentSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Radio only */\n  iupClassRegisterAttribute(ic, \"VALUE\", iRadioGetValueAttrib, iRadioSetValueAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE_HANDLE\", iRadioGetValueHandleAttrib, iRadioSetValueHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT | IUPAF_IHANDLE | IUPAF_NO_STRING);\n\n  return ic;\n}\n","/** \\file\n* \\brief Register the Internal Controls\n*\n* See Copyright Notice in \"iup.h\"\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_register.h\"\n#include \"iup_stdcontrols.h\"\n\n\nstatic Itable *iregister_table = NULL;   /* table indexed by name containing Iclass* address */\n\nvoid iupRegisterInit(void)\n{\n  iregister_table = iupTableCreate(IUPTABLE_STRINGINDEXED);\n}\n\nvoid iupRegisterFinish(void)\n{\n  char* name = iupTableFirst(iregister_table);\n  while (name)\n  {\n    Iclass* ic = (Iclass*)iupTableGetCurr(iregister_table);\n    iupClassRelease(ic);\n    name = iupTableNext(iregister_table);\n  }\n\n  iupTableDestroy(iregister_table);\n  iregister_table = NULL;\n}\n\nint IupGetAllClasses(char** list, int n)\n{\n  int i = 0;\n  char* name = iupTableFirst(iregister_table);\n\n  if (!list || !n)\n    return iupTableCount(iregister_table);\n\n  while (name)\n  {\n    list[i] = name;\n    i++;\n    if (i == n)\n      break;\n\n    name = iupTableNext(iregister_table);\n  }\n\n  return i;\n}\n\nIclass* iupRegisterFindClass(const char* name)\n{\n  return (Iclass*)iupTableGet(iregister_table, name);\n}\n\nvoid iupRegisterClass(Iclass* ic)\n{\n  Iclass* old_ic = (Iclass*)iupTableGet(iregister_table, ic->name);\n  if (old_ic)\n    iupClassRelease(old_ic);\n\n  iupTableSet(iregister_table, ic->name, (void*)ic, IUPTABLE_POINTER);\n}\n\n\n/***************************************************************/\n\nvoid iupRegisterInternalClasses(void)\n{\n  iupRegisterClass(iupDialogNewClass());\n  iupRegisterClass(iupMessageDlgNewClass());\n  iupRegisterClass(iupColorDlgNewClass());\n  iupRegisterClass(iupFontDlgNewClass());\n  iupRegisterClass(iupFileDlgNewClass());\n  iupRegisterClass(iupProgressDlgNewClass());\n\n  iupRegisterClass(iupTimerNewClass());\n  iupRegisterClass(iupImageNewClass());\n  iupRegisterClass(iupImageRGBNewClass());\n  iupRegisterClass(iupImageRGBANewClass());\n  iupRegisterClass(iupUserNewClass());\n  iupRegisterClass(iupClipboardNewClass());\n\n  iupRegisterClass(iupRadioNewClass());\n  iupRegisterClass(iupFillNewClass());\n  iupRegisterClass(iupHboxNewClass());\n  iupRegisterClass(iupVboxNewClass());\n  iupRegisterClass(iupZboxNewClass());\n  iupRegisterClass(iupCboxNewClass());\n  iupRegisterClass(iupSboxNewClass());\n  iupRegisterClass(iupNormalizerNewClass());\n  iupRegisterClass(iupSplitNewClass());\n  iupRegisterClass(iupExpanderNewClass());\n  iupRegisterClass(iupDetachBoxNewClass());\n\n  iupRegisterClass(iupMenuNewClass());\n  iupRegisterClass(iupItemNewClass());\n  iupRegisterClass(iupSeparatorNewClass());\n  iupRegisterClass(iupSubmenuNewClass());\n\n  iupRegisterClass(iupLabelNewClass());\n  iupRegisterClass(iupButtonNewClass());\n  iupRegisterClass(iupToggleNewClass());\n  iupRegisterClass(iupCanvasNewClass());\n  iupRegisterClass(iupFrameNewClass());\n  iupRegisterClass(iupTextNewClass());\n  iupRegisterClass(iupMultilineNewClass());\n  iupRegisterClass(iupListNewClass());\n  iupRegisterClass(iupFlatButtonNewClass());\n\n  iupRegisterClass(iupProgressBarNewClass());\n  iupRegisterClass(iupValNewClass());\n  iupRegisterClass(iupTabsNewClass());\n  iupRegisterClass(iupSpinNewClass());\n  iupRegisterClass(iupSpinboxNewClass());\n  iupRegisterClass(iupTreeNewClass());\n  iupRegisterClass(iupScrollBoxNewClass());\n  iupRegisterClass(iupBackgroundBoxNewClass());\n  iupRegisterClass(iupLinkNewClass());\n  iupRegisterClass(iupGridBoxNewClass());\n}\n","/** \\file\n * \\brief iupsbox control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_childtree.h\"\n\n\n#define ISBOX_THICK 5\n\nenum { ISBOX_NORTH, ISBOX_SOUTH, ISBOX_WEST, ISBOX_EAST };\n\nstruct _IcontrolData\n{\n  int w, h;\n  int isholding;\n  int start_x, start_y;\n  int start_w, start_h;\n\n  int direction;     /* one of the types: ISBOX_NORTH, ISBOX_SOUTH, ISBOX_WEST, ISBOX_EAST */\n};\n\n\nstatic int iSboxGetYborder(Ihandle* ih)\n{\n  if (ih->data->direction == ISBOX_NORTH || ih->data->direction == ISBOX_SOUTH)\n    return ISBOX_THICK;\n  else\n    return 0;\n}\n\nstatic int iSboxGetXborder(Ihandle* ih)\n{\n  if (ih->data->direction == ISBOX_EAST || ih->data->direction == ISBOX_WEST)\n    return ISBOX_THICK;\n  else\n    return 0;\n}\n\nstatic void iSboxSaveDimension(Ihandle* ih, int w, int h)\n{\n  ih->data->w = w;\n  ih->data->h = h;\n  iupLayoutApplyMinMaxSize(ih, &(ih->data->w), &(ih->data->h));\n}\n\nstatic void iSboxAddDecorOffset(Ihandle* ih, int *x, int *y)\n{\n  /* skip north thumb if there is one */\n  if (ih->data->direction == ISBOX_NORTH)\n    *y += ISBOX_THICK;\n\n  /* skip west thumb if there is one */\n  if (ih->data->direction == ISBOX_WEST)\n    *x += ISBOX_THICK;\n}\n\nstatic void iSboxGetFinalSize(Ihandle* ih, int direction, int *w, int *h)\n{\n  int final_x, final_y;\n  int diff_x, diff_y;\n\n  iupStrToIntInt(IupGetGlobal(\"CURSORPOS\"), &final_x, &final_y, 'x');\n\n  diff_x = final_x - ih->data->start_x;\n  diff_y = final_y - ih->data->start_y;\n\n  if(direction == ISBOX_WEST)\n    diff_x = -diff_x;\n\n  if(direction == ISBOX_NORTH)\n    diff_y = -diff_y;\n\n  *w = diff_x + ih->data->start_w;\n  *h = diff_y + ih->data->start_h;\n}\n\nstatic void iSboxShakeControls(Ihandle* ih)\n{\n  int new_w, new_h;\n\n  iSboxGetFinalSize(ih, ih->data->direction, &new_w, &new_h);\n\n  if (ih->data->direction == ISBOX_WEST || ih->data->direction == ISBOX_EAST)\n  {\n    if (new_w != ih->data->w)\n    {\n      iSboxSaveDimension(ih, new_w, ih->data->h);\n      IupRefresh(ih);  /* may affect all the elements in the dialog */\n    }\n  }\n  else if (ih->data->direction == ISBOX_SOUTH || ih->data->direction == ISBOX_NORTH)\n  {\n    if (new_h != ih->data->h)\n    {\n      iSboxSaveDimension(ih, ih->data->w, new_h);\n      IupRefresh(ih);  /* may affect all the elements in the dialog */\n    }\n  }\n}\n\n\n/*****************************************************************************\\\n|* Callbacks of canvas bar                                                   *|\n\\*****************************************************************************/\n\n\nstatic int iSboxMotion_CB(Ihandle* bar, int x, int y, char *r)\n{\n  Ihandle* ih = bar->parent;\n\n  if (ih->data->isholding)\n    iSboxShakeControls(ih);\n\n  (void)x;\n  (void)y;\n  (void)r;\n  return IUP_DEFAULT;\n}\n\nstatic int iSboxButton_CB(Ihandle* bar, int button, int pressed, int x, int y, char* status)\n{\n  Ihandle* ih = bar->parent;\n\n  if (button!=IUP_BUTTON1)\n    return IUP_DEFAULT;\n\n  if (!ih->data->isholding && pressed)\n  {\n    ih->data->isholding = 1;\n\n    /* Save the cursor position */\n    iupStrToIntInt(IupGetGlobal(\"CURSORPOS\"), &ih->data->start_x, &ih->data->start_y, 'x');\n\n    /* Save the initial size */\n    ih->data->start_w = ih->data->w;\n    ih->data->start_h = ih->data->h;\n  }\n  else if (ih->data->isholding && !pressed)\n    ih->data->isholding = 0;\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iSboxFocus_CB(Ihandle* bar, int focus)\n{\n  Ihandle* ih = bar->parent;\n\n  if (!ih || focus) /* use only kill focus */\n    return IUP_DEFAULT;\n\n  if (ih->data->isholding)\n    ih->data->isholding = 0;\n\n  return IUP_DEFAULT;\n}\n\n\n/*****************************************************************************\\\n|* Attributes                                                                *|\n\\*****************************************************************************/\n\n\nstatic char* iSboxGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth - iSboxGetXborder(ih);\n  int height = ih->currentheight - iSboxGetYborder(ih);\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iSboxSetColorAttrib(Ihandle* ih, const char* value)\n{\n  IupSetAttribute(ih->firstchild, \"BGCOLOR\", value);\n  return 0;  /* do not store value in hash table */\n}\n\nstatic int iSboxSetDirectionAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle) /* only before map */\n    return 0;\n\n  if (iupStrEqualNoCase(value, \"NORTH\"))\n    ih->data->direction = ISBOX_NORTH;\n  else if(iupStrEqualNoCase(value, \"SOUTH\"))\n    ih->data->direction = ISBOX_SOUTH;\n  else if(iupStrEqualNoCase(value, \"WEST\"))\n    ih->data->direction = ISBOX_WEST;\n  else  /* Default = EAST */\n    ih->data->direction = ISBOX_EAST;\n\n  if (ih->data->direction == ISBOX_EAST || ih->data->direction == ISBOX_WEST)\n    IupSetAttribute(ih->firstchild, \"CURSOR\", \"RESIZE_WE\");\n  else\n    IupSetAttribute(ih->firstchild, \"CURSOR\", \"RESIZE_NS\");\n\n  return 0;  /* do not store value in hash table */\n}\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\n\nstatic void iSboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = ih->naturalwidth, \n      natural_h = ih->naturalheight;\n\n  /* only allow expand in the oposite direction, complement iupBaseContainerUpdateExpand */\n  if (ih->data->direction == ISBOX_EAST || ih->data->direction == ISBOX_WEST)\n      ih->expand &= ~IUP_EXPAND_WIDTH;\n  else \n      ih->expand &= ~IUP_EXPAND_HEIGHT;\n\n  /* always has at least one child, the bar */\n\n  /* This is an unusual element, the iupBaseComputeNaturalSize logic is done twice, one here and one back there. */\n\n  if (ih->firstchild->brother)\n  {\n    Ihandle* child = ih->firstchild->brother;\n\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    *children_expand = child->expand;\n\n    /* calculate as in iupBaseComputeNaturalSize */\n    natural_w = iupMAX(natural_w, child->naturalwidth  + iSboxGetXborder(ih));\n    natural_h = iupMAX(natural_h, child->naturalheight + iSboxGetYborder(ih));\n  }\n\n  /* update control to fit its children according to direction */\n\n  /* bar */\n  if (ih->data->direction == ISBOX_EAST || ih->data->direction == ISBOX_WEST)\n  {\n    ih->data->w = iupMAX(natural_w, ih->data->w);\n    ih->data->h = natural_h;\n  }\n  else  /* ISBOX_NORTH || ISBOX_SOUTH */\n  {\n    ih->data->w = natural_w;\n    ih->data->h = iupMAX(natural_h, ih->data->h);\n  }\n\n  /* child */\n  if (ih->firstchild->brother)\n  {\n    Ihandle* child = ih->firstchild->brother;\n    child->naturalwidth  = ih->data->w - iSboxGetXborder(ih);\n    child->naturalheight = ih->data->h - iSboxGetYborder(ih);\n  }\n\n  *w = ih->data->w;\n  *h = ih->data->h;\n}\n\nstatic void iSboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  /* bar */\n  if ((ih->data->direction == ISBOX_NORTH || ih->data->direction == ISBOX_SOUTH))\n  {\n    ih->firstchild->currentwidth  = ih->currentwidth;\n    ih->firstchild->currentheight = ISBOX_THICK;\n  }\n  else\n  {\n    ih->firstchild->currentwidth  = ISBOX_THICK;\n    ih->firstchild->currentheight = ih->currentheight;\n  }\n\n  /* child */\n  if (ih->firstchild->brother)\n  {\n    int width = ih->currentwidth-iSboxGetXborder(ih);\n    int height = ih->currentheight-iSboxGetYborder(ih);\n    if (width < 0) width = 0;\n    if (height < 0) height = 0;\n\n    iupBaseSetCurrentSize(ih->firstchild->brother, width, height, shrink);\n  }\n}\n\nstatic void iSboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int posx = 0, posy = 0;\n\n  /* bar */\n  if (ih->data->direction == ISBOX_EAST)\n  {\n    posx = ih->data->w - ISBOX_THICK;\n    if (posx<0) posx = 0;\n  }\n  if (ih->data->direction == ISBOX_SOUTH)\n  {\n    posy = ih->data->h - ISBOX_THICK;\n    if (posy<0) posy = 0;\n  }\n\n  iupBaseSetPosition(ih->firstchild, x+posx, y+posy);\n\n  /* child */\n  if (ih->firstchild->brother)\n  {  \n    iSboxAddDecorOffset(ih, &x, &y);\n    iupBaseSetPosition(ih->firstchild->brother, x, y);\n  } \n}\n\nstatic int iSboxCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle* bar;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->direction = ISBOX_EAST;\n  ih->data->h = -1;\n  ih->data->w = -1;\n\n  bar = IupCanvas(NULL);\n  bar->flags |= IUP_INTERNAL;\n  iupChildTreeAppend(ih, bar);  /* bar will always be the firstchild */\n\n  IupSetAttribute(bar, \"BORDER\", \"YES\");\n  IupSetAttribute(bar, \"EXPAND\", \"NO\");\n  IupSetAttribute(bar, \"BGCOLOR\", \"192 192 192\");\n\n  /* Setting callbacks */\n  IupSetCallback(bar, \"BUTTON_CB\", (Icallback) iSboxButton_CB);\n  IupSetCallback(bar, \"FOCUS_CB\",  (Icallback) iSboxFocus_CB);\n  IupSetCallback(bar, \"MOTION_CB\", (Icallback) iSboxMotion_CB);\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  return IUP_NOERROR;\n}\n\nIclass* iupSboxNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name   = \"sbox\";\n  ic->format = \"h\";   /* one Ihandle* */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype  = IUP_CHILDMANY+2; /* canvas+child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupSboxNewClass;\n  ic->Create  = iSboxCreateMethod;\n  ic->Map     = iupBaseTypeVoidMapMethod;\n\n  ic->ComputeNaturalSize = iSboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize     = iSboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition        = iSboxSetChildrenPositionMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iSboxGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* IupSbox only */\n  iupClassRegisterAttribute(ic, \"COLOR\",     NULL, iSboxSetColorAttrib,     IUPAF_SAMEASSYSTEM, \"192 192 192\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DIRECTION\", NULL, iSboxSetDirectionAttrib, IUPAF_SAMEASSYSTEM, \"EAST\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle* IupSbox(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"sbox\", children);\n}\n","/** \\file\n * \\brief iupscrollbox control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_register.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_drv.h\"\n\n\n/*****************************************************************************\\\n|* Canvas Callbacks                                                          *|\n\\*****************************************************************************/\n\nstatic int iScrollBoxScroll_CB(Ihandle *ih, int op, float posx, float posy)\n{\n  if (ih->firstchild)\n  {\n    int x, y;\n\n    char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n    /* Native container, position is reset */\n    x = 0;\n    y = 0;\n\n    if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n    if (IupGetInt(ih, \"DX\") > IupGetInt(ih, \"XMAX\")-iupdrvGetScrollbarSize())\n      posx = 0;\n    if (IupGetInt(ih, \"DY\") > IupGetInt(ih, \"YMAX\")-iupdrvGetScrollbarSize())\n      posy = 0;\n\n    x -= (int)posx;\n    y -= (int)posy;\n\n    iupBaseSetPosition(ih->firstchild, x, y);\n    iupLayoutUpdate(ih->firstchild);\n  }\n  (void)op;\n  return IUP_DEFAULT;\n}\n\nstatic int iScrollBoxButton_CB(Ihandle *ih, int but, int pressed, int x, int y, char* status)\n{\n  if (but==IUP_BUTTON1 && pressed)\n  {\n    iupAttribSetInt(ih, \"_IUP_START_X\", x);\n    iupAttribSetInt(ih, \"_IUP_START_Y\", y);\n    iupAttribSetInt(ih, \"_IUP_START_POSX\", IupGetInt(ih, \"POSX\"));\n    iupAttribSetInt(ih, \"_IUP_START_POSY\", IupGetInt(ih, \"POSY\"));\n    iupAttribSet(ih, \"_IUP_DRAG_SB\", \"1\");\n  }\n  if (but==IUP_BUTTON1 && !pressed)\n    iupAttribSet(ih, \"_IUP_DRAG_SB\", NULL);\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iScrollBoxMotion_CB(Ihandle *ih, int x, int y, char* status)\n{\n  if (iup_isbutton1(status) &&\n      iupAttribGet(ih, \"_IUP_DRAG_SB\"))\n  {\n    int start_x = iupAttribGetInt(ih, \"_IUP_START_X\");\n    int start_y = iupAttribGetInt(ih, \"_IUP_START_Y\");\n    int dx = x - start_x;\n    int dy = y - start_y;\n    int posx = iupAttribGetInt(ih, \"_IUP_START_POSX\");\n    int posy = iupAttribGetInt(ih, \"_IUP_START_POSY\");\n    IupSetInt(ih, \"POSX\", posx-dx);  /* drag direction is oposite to scrollbar */\n    IupSetInt(ih, \"POSY\", posy-dy);\n    iScrollBoxScroll_CB(ih, 0, IupGetFloat(ih, \"POSX\"), IupGetFloat(ih, \"POSY\"));\n  }\n  return IUP_DEFAULT;\n}\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\n\nstatic void iScrollBoxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  if (ih->firstchild)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(ih->firstchild);\n  }\n\n  /* ScrollBox size does not depends on the child size,\n     its natural size must be 0 to be free of restrictions. */\n  (void)w;\n  (void)h;\n\n  /* Also set expand to its own expand so it will not depend on children */\n  *children_expand = ih->expand;\n}\n\nstatic void iScrollBoxUpdateVisibleArea(Ihandle* ih, int xmax, int ymax)\n{\n  int width = ih->currentwidth,\n    height = ih->currentheight;\n\n  /* if child is greater than scrollbox in one direction,\n  then it has scrollbars\n  but this affects the opposite direction */\n\n  if (xmax > ih->currentwidth)\n    height -= iupdrvGetScrollbarSize();\n\n  if (ymax > ih->currentheight)\n    width -= iupdrvGetScrollbarSize();\n\n  if (xmax <= ih->currentwidth && xmax > width)\n    height -= iupdrvGetScrollbarSize();\n\n  if (ymax <= ih->currentheight && ymax > height)\n    width -= iupdrvGetScrollbarSize();\n\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n\n  IupSetInt(ih, \"DX\", width);\n  IupSetInt(ih, \"DY\", height);\n}\n\nstatic void iScrollBoxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child = ih->firstchild;\n\n  if (child)\n  {\n    int w, h, has_sb_horiz=0, has_sb_vert=0;\n\n    /* If child is greater than scrollbox area, use child natural size,\n       else use current scrollbox size;\n       So this will let the child be greater than the scrollbox,\n       or let the child expand to the scrollbox.  */\n\n    if (child->naturalwidth > ih->currentwidth)\n    {\n      w = child->naturalwidth;\n      has_sb_horiz = 1;\n    }\n    else\n      w = ih->currentwidth;  /* expand space */\n\n    if (child->naturalheight > ih->currentheight)\n    {\n      h = child->naturalheight;\n      has_sb_vert = 1;\n    }\n    else\n      h = ih->currentheight; /* expand space */\n\n    if (!has_sb_horiz && has_sb_vert)\n      w -= iupdrvGetScrollbarSize();  /* reduce expand space */\n\n    if (has_sb_horiz && !has_sb_vert)\n      h -= iupdrvGetScrollbarSize();  /* reduce expand space */\n\n    /* Now w and h is a possible child size */\n    iupBaseSetCurrentSize(child, w, h, shrink);\n\n    /* Now we use the actual child size as the virtual area */\n    IupSetInt(ih, \"XMAX\", child->currentwidth);\n    IupSetInt(ih, \"YMAX\", child->currentheight);\n\n    /* Finally update the visible area */\n    iScrollBoxUpdateVisibleArea(ih, child->currentwidth, child->currentheight);\n  }\n  else\n  {\n    IupSetAttribute(ih, \"XMAX\", \"0\");\n    IupSetAttribute(ih, \"YMAX\", \"0\");\n    IupSetAttribute(ih, \"DX\", \"0\");\n    IupSetAttribute(ih, \"DY\", \"0\");\n  }\n}\n\nstatic void iScrollBoxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild)\n  {\n    char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n    /* Native container, position is reset */\n    x = 0;\n    y = 0;\n\n    if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n    x -= IupGetInt(ih, \"POSX\");\n    y -= IupGetInt(ih, \"POSY\");\n\n    /* Child coordinates are relative to client left-top corner. */\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n}\n\nstatic int iScrollBoxCreateMethod(Ihandle* ih, void** params)\n{\n  /* Setting callbacks */\n  IupSetCallback(ih, \"SCROLL_CB\",    (Icallback)iScrollBoxScroll_CB);\n  IupSetCallback(ih, \"BUTTON_CB\",    (Icallback)iScrollBoxButton_CB);\n  IupSetCallback(ih, \"MOTION_CB\",    (Icallback)iScrollBoxMotion_CB);\n\n  IupSetAttribute(ih, \"CANFOCUS\", \"NO\");\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (iparams[0]) IupAppend(ih, iparams[0]);\n  }\n\n  return IUP_NOERROR;\n}\n\nIclass* iupScrollBoxNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"canvas\"));\n\n  ic->name   = \"scrollbox\";\n  ic->format = \"h\";   /* one Ihandle* */\n  ic->nativetype = IUP_TYPECANVAS;\n  ic->childtype  = IUP_CHILDMANY+1;  /* 1 child */\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupScrollBoxNewClass;\n  ic->Create  = iScrollBoxCreateMethod;\n\n  ic->ComputeNaturalSize = iScrollBoxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iScrollBoxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iScrollBoxSetChildrenPositionMethod;\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  {\n    IattribGetFunc drawsize_get = NULL;\n    iupClassRegisterGetAttribute(ic, \"DRAWSIZE\", &drawsize_get, NULL, NULL, NULL, NULL);\n    iupClassRegisterAttribute(ic, \"CLIENTSIZE\", drawsize_get, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  }\n\n  /* Native Container */\n  iupClassRegisterAttribute(ic, \"CHILDOFFSET\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  /* replace IupCanvas behavior */\n  iupClassRegisterReplaceAttribFunc(ic, \"BGCOLOR\", iupBaseNativeParentGetBgColorAttrib, NULL);\n  iupClassRegisterReplaceAttribDef(ic, \"BGCOLOR\", \"DLGBGCOLOR\", NULL);\n  iupClassRegisterReplaceAttribDef(ic, \"BORDER\", \"NO\", NULL);\n  iupClassRegisterReplaceAttribFlags(ic, \"BORDER\", IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterReplaceAttribDef(ic, \"SCROLLBAR\", \"YES\", NULL);\n\n  return ic;\n}\n\nIhandle* IupScrollBox(Ihandle* child)\n{\n  void *children[2];\n  children[0] = (void*)child;\n  children[1] = NULL;\n  return IupCreatev(\"scrollbox\", children);\n}\n","/** \\file\n * \\brief show/popup/hide/map\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_class.h\"\n#include \"iup_dialog.h\"\n#include \"iup_menu.h\"\n#include \"iup_assert.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n\n\nvoid IupUnmap(Ihandle *ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  /* Invalid if it is NOT mapped. */\n  if (!ih->handle)\n    return;\n\n  /* unmap children */\n  {\n    Ihandle* child = ih->firstchild;\n    while (child)\n    {\n      IupUnmap(child);\n      child = child->brother;\n    }\n  }\n\n  /* only call UNMAP_CB for controls that have a native representation */\n  if (ih->iclass->nativetype != IUP_TYPEVOID)\n  {\n    Icallback unmap_cb = IupGetCallback(ih, \"UNMAP_CB\");\n    if (unmap_cb) unmap_cb(ih);\n  }\n\n  /* unmap from the native system */\n  iupClassObjectUnMap(ih);\n  ih->handle = NULL;\n}\n\nint IupMap(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return IUP_INVALID;\n\n  /* already mapped, only update the dialog layout */\n  if (ih->handle)\n  {\n    /* if the dialog is visible, then it will be reflected in the user interface */\n\n    /* the result is equivalent of calling IupRefresh(ih) when it is a dialog */\n    if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n    {\n      /* calculate position and size for all children */\n      iupLayoutCompute(ih);\n      /* moves and resizes the elements to reflect the layout computation */\n      iupLayoutUpdate(ih);\n    }\n\n    /* does nothing if not a dialog and already mapped */\n    return IUP_NOERROR;\n  }\n\n  /* parent must be mapped to map child */\n  if (ih->parent && !(ih->parent->handle))\n    return IUP_ERROR;\n    \n  /* map to the native system */\n  if (iupClassObjectMap(ih) == IUP_ERROR)\n  {\n    iupERROR(\"Error during IupMap.\");\n    return IUP_ERROR;\n  }\n\n  /* update FONT, must be before several other attributes, so we do it here */\n  if (ih->iclass->nativetype != IUP_TYPEVOID &&\n      ih->iclass->nativetype != IUP_TYPEIMAGE &&\n      ih->iclass->nativetype != IUP_TYPEMENU)\n    iupUpdateStandardFontAttrib(ih);\n\n  /* ensure attributes default values, at this time only the ones that need to be set after map */\n  iupClassObjectEnsureDefaultAttributes(ih);\n\n  /* updates the defined attributes from the hash table (this) to the native system (this). */\n  iupAttribUpdate(ih); \n\n  /* updates inheritable attributes defined in the parent tree */\n  iupAttribUpdateFromParent(ih);\n\n  /* map children independent from childtype */\n  if (ih->firstchild)\n  {\n    Ihandle* child = ih->firstchild;\n    while (child)\n    {\n      if (IupMap(child) == IUP_ERROR)\n        return IUP_ERROR;\n\n      child = child->brother;\n    }\n\n    /* updates the defined attributes from the hash table (this) to the native system (children). */\n    iupAttribUpdateChildren(ih);\n  }\n\n  /* the result is equivalent of calling IupRefresh(ih) when it is a dialog */\n  if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n  {\n    /* calculate position and size for all children */\n    iupLayoutCompute(ih);\n    /* moves and resizes the elements to reflect the layout computation */\n    iupLayoutUpdate(ih);\n  }\n\n  /* only call MAP_CB for controls that have a native representation */\n  if (ih->iclass->nativetype != IUP_TYPEVOID)\n  {\n    Icallback map_cb = IupGetCallback(ih, \"MAP_CB\");\n    if (map_cb) map_cb(ih);\n  }\n\n  return IUP_NOERROR;\n}\n\nint IupPopup(Ihandle *ih, int x, int y)\n{\n  int ret;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return IUP_INVALID;\n\n  if (ih->iclass->nativetype != IUP_TYPEDIALOG && \n      ih->iclass->nativetype != IUP_TYPEMENU)\n  {\n    iupERROR(\"Must be a menu or dialog in IupPopup.\");\n    return IUP_INVALID;\n  }\n\n  ret = IupMap(ih);\n  if (ret == IUP_ERROR) \n    return ret;\n\n  if (ih->iclass->nativetype == IUP_TYPEDIALOG)\n    ret = iupDialogPopup(ih, x, y);\n  else\n    ret = iupMenuPopup(ih, x, y);\n\n  if (ret != IUP_NOERROR) \n  {\n    iupERROR(\"Error during IupPopup.\");\n    return ret;\n  }\n\n  return IUP_NOERROR;\n}\n\nint IupShowXY(Ihandle *ih, int x, int y)\n{\n  int ret;\n\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return IUP_INVALID;\n\n  if (ih->iclass->nativetype != IUP_TYPEDIALOG)\n  {\n    iupERROR(\"Must be a dialog in IupShowXY.\");\n    return IUP_INVALID;\n  }\n\n  ret = IupMap(ih);\n  if (ret == IUP_ERROR) \n    return ret;\n\n  ret = iupDialogShowXY(ih, x, y);\n  if (ret != IUP_NOERROR) \n  {\n    iupERROR(\"Error during IupShowXY.\");\n    return ret;\n  }\n\n  return IUP_NOERROR;\n}\n\nint IupShow(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return IUP_INVALID;\n\n  if (ih->iclass->nativetype != IUP_TYPEDIALOG)\n    IupSetAttribute(ih, \"VISIBLE\", \"YES\");\n  else   \n  {\n    int ret = IupMap(ih);\n    if (ret == IUP_ERROR) \n      return ret;\n      \n    ret = iupDialogShowXY(ih, IUP_CURRENT, IUP_CURRENT);\n    if (ret != IUP_NOERROR) \n    {\n      iupERROR(\"Error during IupShow.\");\n      return ret;\n    }\n  }\n\n  return IUP_NOERROR;\n}\n\nint IupHide(Ihandle* ih)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return IUP_INVALID; \n\n  if (ih->iclass->nativetype != IUP_TYPEDIALOG)\n    IupSetAttribute(ih, \"VISIBLE\", \"NO\");\n  else if (ih->handle)\n    iupDialogHide(ih);\n\n  return IUP_NOERROR;\n}\n","/** \\file\n * \\brief Spin control\n *\n  * See Copyright Notice in \"iup.h\"\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n#include \"iup_childtree.h\"\n\n\n\nstatic int iSpinCallCB(Ihandle* ih, int dub, int ten, int sign)\n{\n  IFni cb;\n\n  /* get the callback on the spin or on the spinbox */\n  Ihandle* spinbox = (Ihandle*)iupAttribGet(ih->parent, \"_IUPSPIN_BOX\");\n  if (spinbox) \n    ih = spinbox;\n  else\n    ih = ih->parent;\n\n  cb = (IFni) IupGetCallback(ih, \"SPIN_CB\");\n  if (cb) \n  {\n    return cb(ih, sign*(dub && ten ? 100 :\n                               ten ?  10 : \n                               dub ?   2 : 1));\n  }\n\n  return IUP_DEFAULT;\n}\n\nstatic int iSpinTimerCB(Ihandle* ih)\n{\n  Ihandle* spin_button = (Ihandle*)iupAttribGet(ih, \"_IUPSPIN_BUTTON\");\n  char* status   = iupAttribGet(ih, \"_IUPSPIN_STATUS\");\n  int spin_dir   = iupAttribGetInt(ih, \"_IUPSPIN_DIR\");\n  int count      = iupAttribGetInt(ih, \"_IUPSPIN_COUNT\");\n  char* reconfig = NULL;\n\n  if(count == 0) /* first time */\n    reconfig = \"50\";\n  else if(count == 14) /* 300 + 14*50 = 1000 (1 second) */\n    reconfig = \"25\";\n  else if(count == 34) /* 300 + 14*50 + 20*50 = 2000 (2 seconds) */\n    reconfig = \"10\";\n\n  if (reconfig)\n  {\n    IupSetAttribute(ih, \"RUN\", \"NO\");\n    IupSetAttribute(ih, \"TIME\", reconfig);\n    IupSetAttribute(ih, \"RUN\", \"YES\");\n  }\n\n  iupAttribSetInt(ih, \"_IUPSPIN_COUNT\", count + 1);\n\n  return iSpinCallCB(spin_button, iup_isshift(status), iup_iscontrol(status), spin_dir);\n}\n\nstatic void iSpinRunTimer(Ihandle* ih, char* status, char* dir)\n{\n  Ihandle* spin_timer = IupGetHandle(\"IupSpinTimer\");\n\n  iupAttribSet(spin_timer, \"_IUPSPIN_BUTTON\", (char*)ih);\n  iupAttribSetStr(spin_timer, \"_IUPSPIN_STATUS\", status);\n  iupAttribSetStr(spin_timer, \"_IUPSPIN_DIR\",   dir);\n  iupAttribSet(spin_timer, \"_IUPSPIN_COUNT\", \"0\");\n\n  IupSetAttribute(spin_timer, \"TIME\",           \"400\");\n  IupSetAttribute(spin_timer, \"RUN\",            \"YES\");\n}\n\nstatic void iSpinStopTimer(void)\n{\n  Ihandle* spin_timer = IupGetHandle(\"IupSpinTimer\");\n  IupSetAttribute(spin_timer, \"RUN\", \"NO\");\n}\n\nstatic int iSpinK_SP(Ihandle* ih)\n{\n  int dir = iupAttribGetInt(ih, \"_IUPSPIN_DIR\");\n  \n  return iSpinCallCB(ih, 0, 0, dir);\n}\n\nstatic int iSpinK_sSP(Ihandle* ih)\n{\n  int dir = iupAttribGetInt(ih, \"_IUPSPIN_DIR\");\n  \n  return iSpinCallCB(ih, 1, 0, dir);\n}\n\nstatic int iSpinK_cSP(Ihandle* ih)\n{\n  int dir = iupAttribGetInt(ih, \"_IUPSPIN_DIR\");\n  \n  return iSpinCallCB(ih, 0, 1, dir);\n}\n\nstatic int iSpinButtonCB(Ihandle* ih, int but, int pressed, int x, int y, char* status)\n{\n  (void)x;\n  (void)y;\n \n  if (pressed && but == IUP_BUTTON1 && !iup_isdouble(status))\n  {\n    int dir = iupAttribGetInt(ih, \"_IUPSPIN_DIR\");\n    \n    iSpinRunTimer(ih, status, iupAttribGet(ih, \"_IUPSPIN_DIR\"));\n    \n    return iSpinCallCB(ih, iup_isshift(status), iup_iscontrol(status), dir);\n  }\n  else if (!pressed && but == IUP_BUTTON1)\n    iSpinStopTimer();\n  \n  return IUP_DEFAULT;\n}\n\nstatic int iSpinCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle* bt_up;\n  Ihandle* bt_down;\n  (void)params;\n\n  /* Button UP */\n  bt_up = IupButton(NULL, NULL);\n  \n  IupSetAttribute(bt_up, \"EXPAND\", \"NO\");\n  IupSetAttribute(bt_up, \"IMAGE\",  \"IupSpinUpImage\");\n  IupSetAttribute(bt_up, \"_IUPSPIN_DIR\", \"1\");\n  IupSetAttribute(bt_up, \"CANFOCUS\", \"NO\");\n\n  IupSetCallback(bt_up, \"BUTTON_CB\", (Icallback) iSpinButtonCB);\n  IupSetCallback(bt_up, \"K_SP\",      (Icallback) iSpinK_SP);\n  IupSetCallback(bt_up, \"K_sSP\",     (Icallback) iSpinK_sSP);\n  IupSetCallback(bt_up, \"K_cSP\",     (Icallback) iSpinK_cSP);\n\n  /* Button DOWN */\n  bt_down = IupButton(NULL, NULL);\n  \n  IupSetAttribute(bt_down, \"EXPAND\", \"NO\");\n  IupSetAttribute(bt_down, \"IMAGE\",  \"IupSpinDownImage\");\n  IupSetAttribute(bt_down, \"_IUPSPIN_DIR\", \"-1\");\n  IupSetAttribute(bt_down, \"CANFOCUS\", \"NO\");\n\n  IupSetCallback(bt_down, \"BUTTON_CB\", (Icallback) iSpinButtonCB);\n  IupSetCallback(bt_down, \"K_SP\",      (Icallback) iSpinK_SP);\n  IupSetCallback(bt_down, \"K_sSP\",     (Icallback) iSpinK_sSP);\n  IupSetCallback(bt_down, \"K_cSP\",     (Icallback) iSpinK_cSP);\n\n  /* manually add the buttons as a children */\n  ih->firstchild = bt_up;\n  bt_up->parent = ih;\n  bt_up->brother = bt_down;\n  bt_down->parent = ih;\n  \n  /* avoid inheritance from parent */\n  IupSetAttribute(ih, \"GAP\",    \"0\");\n  IupSetAttribute(ih, \"MARGIN\", \"0x0\");\n\n  return IUP_NOERROR;\n}\n\n\nstatic void iSpinLoadImages(void)\n{\n  Ihandle* img;\n\n  /* Spin UP image */\n  unsigned char iupspin_up_img[] = {\n    1, 1, 1, 1, 1, 1, 1, 1, 1, \n    1, 1, 1, 1, 0, 1, 1, 1, 1,\n    1, 1, 1, 0, 0, 0, 1, 1, 1,\n    1, 1, 0, 0, 0, 0, 0, 1, 1,\n    1, 0, 0, 0, 0, 0, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0\n  };\n\n  /* Spin DOWN image */\n  unsigned char iupspin_down_img[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 0, 0, 0, 1,\n    1, 1, 0, 0, 0, 0, 0, 1, 1,\n    1, 1, 1, 0, 0, 0, 1, 1, 1,\n    1, 1, 1, 1, 0, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1\n  };\n\n  img = IupImage(9, 6, iupspin_up_img);\n  IupSetAttribute(img, \"0\", \"0 0 0\"); \n  IupSetAttribute(img, \"1\", \"BGCOLOR\"); \n  IupSetHandle(\"IupSpinUpImage\", img); \n\n  img = IupImage(9, 6, iupspin_down_img);\n  IupSetAttribute(img, \"0\", \"0 0 0\"); \n  IupSetAttribute(img, \"1\", \"BGCOLOR\"); \n  IupSetHandle(\"IupSpinDownImage\", img); \n}\n\nIclass* iupSpinNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"vbox\"));\n\n  ic->name = \"spin\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupSpinNewClass;\n  ic->Create = iSpinCreateMethod;\n\n  iupClassRegisterCallback(ic, \"SPIN_CB\", \"i\");\n\n  if (!IupGetHandle(\"IupSpinUpImage\") || !IupGetHandle(\"IupSpinDownImage\"))\n  {\n    Ihandle* spin_timer = IupTimer();\n    IupSetCallback(spin_timer, \"ACTION_CB\", (Icallback) iSpinTimerCB);\n    IupSetHandle(\"IupSpinTimer\", spin_timer);\n\n    iSpinLoadImages();\n  }\n\n  return ic;\n}\n\nIhandle* IupSpin(void)\n{\n  return IupCreate(\"spin\");\n}\n\n/**************************************************************************************\n                                      SPINBOX\n**************************************************************************************/\n\nstatic char* iSpinboxGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n  width -= ih->firstchild->currentwidth;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic void iSpinboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  /* update spin natural size */\n  iupBaseComputeNaturalSize(ih->firstchild);\n\n  if (ih->firstchild->brother)\n  {\n    /* update child natural size */\n    iupBaseComputeNaturalSize(ih->firstchild->brother);\n\n    *children_expand = ih->firstchild->brother->expand;\n\n    *w = ih->firstchild->brother->naturalwidth + ih->firstchild->naturalwidth;\n    *h = iupMAX(ih->firstchild->brother->naturalheight, ih->firstchild->naturalheight);\n  }\n  else\n  {\n    *w = ih->firstchild->naturalwidth;\n    *h = ih->firstchild->naturalheight;\n  }\n}\n\nstatic void iSpinboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  /* bar */                            \n  iupBaseSetCurrentSize(ih->firstchild, ih->firstchild->naturalwidth, ih->firstchild->naturalheight, shrink);\n\n  if (ih->firstchild->brother)\n  {\n    /* child */\n    int width = ih->currentwidth - ih->firstchild->naturalwidth;\n    if (width < 0) width = 0;\n    iupBaseSetCurrentSize(ih->firstchild->brother, width, ih->currentheight, shrink);\n  }\n}\n\nstatic void iSpinboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  if (ih->firstchild->brother)\n  { \n    if (ih->firstchild->brother->currentheight < ih->firstchild->currentheight)\n    {\n      /* bar */\n      iupBaseSetPosition(ih->firstchild, x+ih->firstchild->brother->currentwidth, y);\n\n      y += (ih->firstchild->currentheight-ih->firstchild->brother->currentheight)/2;\n\n      /* child */\n      iupBaseSetPosition(ih->firstchild->brother, x, y);\n    }\n    else\n    {\n      /* child */\n      iupBaseSetPosition(ih->firstchild->brother, x, y);\n\n      y += (ih->firstchild->brother->currentheight-ih->firstchild->currentheight)/2;\n\n      /* bar */\n      iupBaseSetPosition(ih->firstchild, x+ih->firstchild->brother->currentwidth, y);\n    }\n  } \n  else\n  {\n    /* bar */\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n}\n\nstatic int iSpinboxCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle *spin = IupSpin();\n  spin->flags |= IUP_INTERNAL;\n  iupChildTreeAppend(ih, spin);  /* spin will always be the firstchild */\n\n  iupAttribSet(spin, \"_IUPSPIN_BOX\", (char*)ih);  /* will be used by the callback */\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (*iparams)\n      IupAppend(ih, *iparams);\n  }\n\n  return IUP_NOERROR;\n}\n\nIclass* iupSpinboxNewClass(void)\n{\n  /* we don't inherit from a Hbox here to always position the spin at right */\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"spinbox\";\n  ic->format = \"h\"; /* one Ihandle* */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY+2;  /* spin+child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupSpinboxNewClass;\n  ic->Create = iSpinboxCreateMethod;\n  ic->ComputeNaturalSize = iSpinboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iSpinboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iSpinboxSetChildrenPositionMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n\n  iupClassRegisterCallback(ic, \"SPIN_CB\", \"i\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iSpinboxGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle* IupSpinbox(Ihandle* ctrl)\n{\n  void *children[2];\n  children[0] = (void*)ctrl;\n  children[1] = NULL;\n  return IupCreatev(\"spinbox\", children);\n}\n","/** \\file\n * \\brief iupsplit control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_childtree.h\"\n#include \"iup_draw.h\"\n\n\nenum { ISPLIT_VERT, ISPLIT_HORIZ };\nenum { ISPLIT_HIDE, ISPLIT_SHOW };\n\nstruct _IcontrolData\n{\n  /* aux */\n  int is_holding;\n  int start_pos, start_bar, start_size;\n\n  /* attributes */\n  int layoutdrag, autohide, showgrip, barsize;\n  int orientation;  /* one of the types: ISPLIT_VERT, ISPLIT_HORIZ */\n  int val;  /* split value: 0-1000, default 500 */\n  int min, max;  /* used only to crop val */\n};\n\n\nstatic void iSplitAutoHideChild(Ihandle* child, int flag)\n{\n  if (flag==ISPLIT_HIDE)\n  {\n    if (IupGetInt(child, \"VISIBLE\"))\n    {\n      IupSetAttribute(child, \"FLOATING\", \"IGNORE\");\n      IupSetAttribute(child, \"VISIBLE\", \"NO\");\n    }\n  }\n  else \n  {\n    if (!IupGetInt(child, \"VISIBLE\"))\n    {\n      IupSetAttribute(child, \"FLOATING\", \"NO\");\n      IupSetAttribute(child, \"VISIBLE\", \"YES\");\n    }\n  }\n}\n\nstatic void iSplitAutoHide(Ihandle* ih)\n{\n  Ihandle *child1 = ih->firstchild->brother;\n  if (child1)\n  {\n    int tol;\n    Ihandle *child2 = child1->brother;\n\n    if (ih->data->orientation == ISPLIT_VERT)\n    {\n      if (ih->currentwidth <= ih->data->barsize)\n        return;\n\n      tol = (1000*ih->data->barsize)/ih->currentwidth;\n    }\n    else\n    {\n      if (ih->currentheight <= ih->data->barsize)\n        return;\n\n      tol = (1000*ih->data->barsize)/ih->currentheight;\n    }\n\n    iSplitAutoHideChild(child1, ih->data->val<tol? ISPLIT_HIDE: ISPLIT_SHOW);\n\n    if (child2)\n      iSplitAutoHideChild(child2, ih->data->val>(1000-tol)? ISPLIT_HIDE: ISPLIT_SHOW);\n  }\n}\n\nstatic int iSplitGetWidth1(Ihandle* ih)\n{\n  /* This is the space available for the child,\n     It does NOT depends on the child. */\n  int width1 = (int)(((ih->currentwidth-ih->data->barsize)*ih->data->val)/1000.0 + 0.5);\n  if (width1 < 0) width1 = 0;\n  return width1;\n}\n\nstatic int iSplitGetWidth2(Ihandle* ih, int width1)\n{\n  /* This is the space available for the child,\n     It does NOT depends on the child. */\n  int width2 = (ih->currentwidth-ih->data->barsize) - width1;\n  if (width2 < 0) width2 = 0;\n  return width2;\n}\n\nstatic int iSplitGetHeight1(Ihandle* ih)\n{\n  /* This is the space available for the child,\n     It does NOT depends on the child. */\n  int height1 = (int)(((ih->currentheight-ih->data->barsize)*ih->data->val)/1000.0 + 0.5);\n  if (height1 < 0) height1 = 0;\n  return height1;\n}\n\nstatic int iSplitGetHeight2(Ihandle* ih, int height1)\n{\n  /* This is the space available for the child,\n     It does NOT depends on the child. */\n  int height2 = (ih->currentheight-ih->data->barsize) - height1;\n  if (height2 < 0) height2 = 0;\n  return height2;\n}\n\nstatic int iSplitCalcVal(Ihandle* ih, int size1)\n{\n  if (ih->data->orientation == ISPLIT_VERT)\n    return (size1*1000)/(ih->currentwidth - ih->data->barsize);\n  else\n    return (size1*1000)/(ih->currentheight - ih->data->barsize);\n}\n\nstatic void iSplitAdjustVal(Ihandle* ih)\n{\n  if (ih->data->val < ih->data->min) \n    ih->data->val = ih->data->min;\n  if (ih->data->val > ih->data->max) \n    ih->data->val = ih->data->max;\n\n  if (ih->data->autohide)\n    iSplitAutoHide(ih);  \n}\n\nstatic int iSplitAdjustWidth1(Ihandle* ih, int *width1)\n{\n  Ihandle *child1 = ih->firstchild->brother;\n  if (child1)\n  {\n    Ihandle *child2 = child1->brother;\n\n    int min_width1 = *width1;\n    iupLayoutApplyMinMaxSize(child1, &min_width1, NULL);\n    if (min_width1 > *width1)\n    {\n      *width1 = min_width1;  /* minimum value for width1 */\n      return 1;\n    }\n\n    if (child2)\n    {\n      int width2 = iSplitGetWidth2(ih, *width1);\n      int min_width2 = width2;\n      iupLayoutApplyMinMaxSize(child2, &min_width2, NULL);\n      if (min_width2 > width2)\n      {\n        width2 = min_width2;  /* minimum value for width2 */\n        *width1 = (ih->currentwidth-ih->data->barsize) - width2;  /* maximum value for width1 */\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int iSplitAdjustHeight1(Ihandle* ih, int *height1)\n{\n  Ihandle *child1 = ih->firstchild->brother;\n  if (child1)\n  {\n    Ihandle *child2 = child1->brother;\n\n    int min_height1 = *height1;\n    iupLayoutApplyMinMaxSize(child1, NULL, &min_height1);\n    if (min_height1 > *height1)\n    {\n      *height1 = min_height1;  /* minimum value for height1 */\n      return 1;\n    }\n\n    if (child2)\n    {\n      int height2 = iSplitGetHeight2(ih, *height1);\n      int min_height2 = height2;\n      iupLayoutApplyMinMaxSize(child2, NULL, &min_height2);\n      if (min_height2 > height2)\n      {\n        height2 = min_height2;  /* minimum value for height2 */\n        *height1 = (ih->currentheight-ih->data->barsize) - height2;  /* maximum value for height1 */\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic void iSplitSetBarPosition(Ihandle* ih)\n{\n  /* Update only the bar position, \n     used only when LAYOUTDRAG=NO */\n  int x = ih->x, \n      y = ih->y;\n\n  if (ih->data->orientation == ISPLIT_VERT)\n  {\n    /* bar */\n    x += iSplitGetWidth1(ih);\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n  else /* ISPLIT_HORIZ */\n  {\n    /* bar */\n    y += iSplitGetHeight1(ih);\n    iupBaseSetPosition(ih->firstchild, x, y);\n  }\n\n  IupSetAttribute(ih->firstchild, \"ZORDER\", \"TOP\");\n  iupClassObjectLayoutUpdate(ih->firstchild);\n}\n\n\n\n/*****************************************************************************\\\n|* Callbacks of canvas bar                                                   *|\n\\*****************************************************************************/\n\n\nstatic int iSplitAction_CB(Ihandle* bar)\n{\n  Ihandle* ih = bar->parent;\n  IdrawCanvas* dc = iupDrawCreateCanvas(bar);\n\n  iupDrawParentBackground(dc);\n\n  if (ih->data->showgrip)\n  {\n    int w, h, x, y;\n    unsigned char r = 160, g = 160, b = 160;\n    iupDrawGetSize(dc, &w, &h);\n\n    iupStrToRGB(iupAttribGetStr(ih, \"COLOR\"), &r, &g, &b);\n\n    if (ih->data->showgrip == 1)\n    {\n      int i, count;\n      unsigned char bg_r, bg_g, bg_b;\n\n      if (r + g + b > 3 * 190)\n      {\n        bg_r = 100; bg_g = 100; bg_b = 100;\n      }\n      else\n      {\n        bg_r = 255; bg_g = 255; bg_b = 255;\n      }\n\n      if (ih->data->orientation == ISPLIT_VERT)\n      {\n        x = ih->data->barsize / 2 - 1;\n        y = 2;\n        count = (h - 2) / 5;\n      }\n      else\n      {\n        x = 2;\n        y = ih->data->barsize / 2 - 1;\n        count = (w - 2) / 5;\n      }\n\n      for (i = 0; i < count; i++)\n      {\n        iupDrawRectangle(dc, x + 1, y + 1, x + 2, y + 2, bg_r, bg_g, bg_b, IUP_DRAW_FILL);\n        iupDrawRectangle(dc, x, y, x + 1, y + 1, r, g, b, IUP_DRAW_FILL);\n        if (ih->data->orientation == ISPLIT_VERT)\n          y += 5;\n        else\n          x += 5;\n      }\n    }\n    else\n    {\n      if (ih->data->orientation == ISPLIT_VERT)\n      {\n        x = ih->data->barsize / 2;\n\n        iupDrawLine(dc, x - 1, 0, x - 1, h - 1, r, g, b, IUP_DRAW_STROKE);\n        iupDrawLine(dc, x + 1, 0, x + 1, h - 1, r, g, b, IUP_DRAW_STROKE);\n      }\n      else\n      {\n        y = ih->data->barsize / 2;\n\n        iupDrawLine(dc, 0, y - 1, w - 1, y - 1, r, g, b, IUP_DRAW_STROKE);\n        iupDrawLine(dc, 0, y + 1, w - 1, y + 1, r, g, b, IUP_DRAW_STROKE);\n      }\n    }\n  }\n  else\n  {\n    char* color = iupAttribGet(ih, \"COLOR\");\n    if (color)\n    {\n      unsigned char r = 160, g = 160, b = 160;\n      int w, h;\n      iupDrawGetSize(dc, &w, &h);\n\n      iupStrToRGB(iupAttribGetStr(ih, \"COLOR\"), &r, &g, &b);\n      iupDrawRectangle(dc, 0, 0, w-1, h-1, r, g, b, IUP_DRAW_FILL);\n    }\n  }\n\n  iupDrawFlush(dc);\n\n  iupDrawKillCanvas(dc);\n\n  return IUP_DEFAULT;\n}\n\nstatic int iSplitMotion_CB(Ihandle* bar, int x, int y, char *status)\n{\n  Ihandle* ih = bar->parent;\n\n  if (ih->data->is_holding)\n  {\n    if (iup_isbutton1(status))  /* DRAG MOVE */\n    {\n      int old_val = ih->data->val;\n      int cur_x, cur_y;\n\n      iupStrToIntInt(IupGetGlobal(\"CURSORPOS\"), &cur_x, &cur_y, 'x');\n\n      if (ih->data->orientation == ISPLIT_VERT)\n      {\n        int width1 = ih->data->start_size + (cur_x - ih->data->start_pos);\n        iSplitAdjustWidth1(ih, &width1);\n        ih->data->val = iSplitCalcVal(ih, width1);\n      }\n      else\n      {\n        int height1 = ih->data->start_size + (cur_y - ih->data->start_pos);\n        iSplitAdjustHeight1(ih, &height1);\n        ih->data->val = iSplitCalcVal(ih, height1);\n      }\n\n      iSplitAdjustVal(ih);\n\n      if (old_val != ih->data->val)\n        iupBaseCallValueChangedCb(ih);\n\n      if (ih->data->layoutdrag)\n      {\n        IupRefreshChildren(ih);\n        IupFlush();\n      }\n      else\n        iSplitSetBarPosition(ih);\n    }\n    else\n      ih->data->is_holding = 0;\n  }\n\n  (void)x;\n  (void)y;\n  return IUP_DEFAULT;\n}\n\nstatic int iSplitButton_CB(Ihandle* bar, int button, int pressed, int x, int y, char* status)\n{\n  Ihandle* ih = bar->parent;\n\n  if (button!=IUP_BUTTON1)\n    return IUP_DEFAULT;\n\n  if (!ih->data->is_holding && pressed)  /* DRAG BEGIN */\n  {\n    int cur_x, cur_y;\n\n    ih->data->is_holding = 1;\n\n    iupStrToIntInt(IupGetGlobal(\"CURSORPOS\"), &cur_x, &cur_y, 'x');\n\n    /* Save the cursor position and size */\n    if (ih->data->orientation == ISPLIT_VERT)\n    {\n      ih->data->start_bar = ih->firstchild->x;\n      ih->data->start_pos = cur_x;\n      ih->data->start_size = ih->firstchild->x - ih->x;\n    }\n    else\n    {\n      ih->data->start_bar = ih->firstchild->y;\n      ih->data->start_pos = cur_y;\n      ih->data->start_size = ih->firstchild->y - ih->y;\n    }\n  }\n  else if (ih->data->is_holding && !pressed)  /* DRAG END */\n  {\n    ih->data->is_holding = 0;\n\n    /* Always refresh when releasing the mouse */\n    IupRefreshChildren(ih);  \n  }\n\n  (void)x;\n  (void)y;\n  (void)status;\n  return IUP_DEFAULT;\n}\n\nstatic int iSplitFocus_CB(Ihandle* bar, int focus)\n{\n  Ihandle* ih = bar->parent;\n\n  if (!ih || focus) /* use only kill focus */\n    return IUP_DEFAULT;\n\n  if (ih->data->is_holding)\n    ih->data->is_holding = 0;\n\n  return IUP_DEFAULT;\n}\n\n\n/*****************************************************************************\\\n|* Attributes                                                                *|\n\\*****************************************************************************/\n\n\nstatic char* iSplitGetClientSizeAttrib(Ihandle* ih)\n{\n  int width = ih->currentwidth;\n  int height = ih->currentheight;\n\n  if (ih->data->orientation == ISPLIT_VERT)\n    width -= ih->data->barsize;\n  else\n    height -= ih->data->barsize;\n\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height, 'x');\n}\n\nstatic int iSplitSetColorAttrib(Ihandle* ih, const char* value)\n{\n  (void)value;\n  IupUpdate(ih);\n  return 1;  /* store value in hash table */\n}\n\nstatic int iSplitSetOrientationAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle) /* only before map */\n    return 0;\n\n  if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->data->orientation = ISPLIT_HORIZ;\n  else  /* Default = VERTICAL */\n    ih->data->orientation = ISPLIT_VERT;\n\n  if (ih->data->orientation == ISPLIT_VERT)\n    IupSetAttribute(ih->firstchild, \"CURSOR\", \"SPLITTER_VERT\");\n  else\n    IupSetAttribute(ih->firstchild, \"CURSOR\", \"SPLITTER_HORIZ\");\n\n  return 0;  /* do not store value in hash table */\n}\n\nstatic int iSplitSetValueAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->data->val = -1;  /* reset to calculate in Natural size */\n\n    if (ih->handle)\n      IupRefreshChildren(ih);  \n  }\n  else\n  {\n    int val;\n    if (iupStrToInt(value, &val))\n    {\n      ih->data->val = val;\n      iSplitAdjustVal(ih);\n\n      if (ih->handle)\n        IupRefreshChildren(ih);  \n    }\n  }\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetValueAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->val);\n}\n\nstatic int iSplitSetBarSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToInt(value, &ih->data->barsize))\n  {\n    if (ih->data->val != -1)\n      iSplitAdjustVal(ih);  /* because of autohide */\n\n    if (ih->handle)\n      IupRefreshChildren(ih);  \n  }\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetBarSizeAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->barsize);\n}\n\nstatic int iSplitSetMinMaxAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToIntInt(value, &ih->data->min, &ih->data->max, ':'))\n  {\n    if (ih->data->min > ih->data->max)\n    {\n      int t = ih->data->min;\n      ih->data->min = ih->data->max;\n      ih->data->max = t;\n    }\n    if (ih->data->min < 0) ih->data->min = 0;\n    if (ih->data->max > 1000) ih->data->max = 1000;\n\n    if (ih->data->val != -1)\n      iSplitAdjustVal(ih);\n\n    if (ih->handle)\n      IupRefreshChildren(ih);  \n  }\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetMinMaxAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->min, ih->data->max, ':');\n}\n\nstatic int iSplitSetLayoutDragAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->layoutdrag = 1;\n  else\n    ih->data->layoutdrag = 0;\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetLayoutDragAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->layoutdrag); \n}\n\nstatic int iSplitSetShowGripAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->showgrip = 1;\n  else\n  {\n    if (iupStrEqualNoCase(value, \"LINES\"))\n      ih->data->showgrip = 2;\n    else\n    {\n      ih->data->showgrip = 0;\n\n      if (ih->data->barsize == 5)\n        iSplitSetBarSizeAttrib(ih, \"3\");\n    }\n  }\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetShowGripAttrib(Ihandle* ih)\n{\n  if (ih->data->showgrip == 2)\n    return \"LINES\";\n  else\n    return iupStrReturnBoolean (ih->data->showgrip); \n}\n\nstatic int iSplitSetAutoHideAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->autohide = 1;\n  else\n  {\n    Ihandle *child1 = ih->firstchild->brother;\n    if (child1)\n    {\n      Ihandle *child2 = child1->brother;\n      iSplitAutoHideChild(child1, ISPLIT_SHOW);\n      if (child2)\n        iSplitAutoHideChild(child2, ISPLIT_SHOW);\n    }\n\n    ih->data->autohide = 0;\n  }\n\n  if (ih->data->val != -1)\n    iSplitAdjustVal(ih);\n\n  if (ih->handle)\n    IupRefreshChildren(ih);  \n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iSplitGetAutoHideAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->autohide); \n}\n\n\n/*****************************************************************************\\\n|* Methods                                                                   *|\n\\*****************************************************************************/\n\n\nstatic void iSplitComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0;\n  Ihandle *child1, *child2 = NULL;\n  child1 = ih->firstchild->brother;\n  if (child1)\n    child2 = child1->brother;\n\n  /* bar */\n  if (ih->data->orientation == ISPLIT_VERT)\n    natural_w += ih->data->barsize;\n  else\n    natural_h += ih->data->barsize;\n\n  if (child1)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child1);\n\n    if (ih->data->orientation == ISPLIT_VERT)\n    {\n      natural_w += child1->naturalwidth;\n      natural_h = iupMAX(natural_h, child1->naturalheight);\n    }\n    else\n    {\n      natural_w = iupMAX(natural_w, child1->naturalwidth);\n      natural_h += child1->naturalheight;\n    }\n\n    *children_expand |= child1->expand;\n  }\n\n  if (child2)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child2);\n\n    if (ih->data->orientation == ISPLIT_VERT)\n    {\n      natural_w += child2->naturalwidth;\n      natural_h = iupMAX(natural_h, child2->naturalheight);\n    }\n    else\n    {\n      natural_w = iupMAX(natural_w, child2->naturalwidth);\n      natural_h += child2->naturalheight;\n    }\n\n    *children_expand |= child2->expand;\n  }\n\n  if (ih->data->val == -1)  /* first time or reset, recompute value from natural size */\n  {\n    if (child1)\n    {\n      /* just is just an initial value based on natural size of the split and the child */\n      if (ih->data->orientation == ISPLIT_VERT)\n        ih->data->val = (child1->naturalwidth*1000)/(natural_w-ih->data->barsize);\n      else\n        ih->data->val = (child1->naturalheight*1000)/(natural_h-ih->data->barsize);\n    }\n    else\n      ih->data->val = ih->data->min;\n\n    iSplitAdjustVal(ih);\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\nstatic void iSplitSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  int old_val = ih->data->val;\n  Ihandle *child1, *child2 = NULL;\n  child1 = ih->firstchild->brother;\n  if (child1)\n    child2 = child1->brother;\n\n  if (ih->data->orientation == ISPLIT_VERT)\n  {\n    int width1 = iSplitGetWidth1(ih);\n    if (iSplitAdjustWidth1(ih, &width1))    /* this will check for child1 and child2 */\n      ih->data->val = iSplitCalcVal(ih, width1);  /* has a MINMAX size, must fix split value */\n\n    if (child1)\n    {\n      iupBaseSetCurrentSize(child1, width1, ih->currentheight, shrink);\n\n      if (child1->currentwidth > width1)\n      {\n        /* has a minimum size, must fix split value */\n        width1 = child1->currentwidth;\n        ih->data->val = iSplitCalcVal(ih, width1);\n      }\n    }\n\n    /* bar */\n    ih->firstchild->currentwidth  = ih->data->barsize;\n    ih->firstchild->currentheight = ih->currentheight;\n\n    if (child2)\n    {\n      int width2 = iSplitGetWidth2(ih, width1);\n      iupBaseSetCurrentSize(child2, width2, ih->currentheight, shrink);\n\n      if (child2->currentwidth > width2)\n      {\n        /* has a minimum size, must fix split value */\n        width2 = child2->currentwidth;\n        width1 = (ih->currentwidth-ih->data->barsize) - width2;\n        ih->data->val = iSplitCalcVal(ih, width1);\n        if (child1)\n          iupBaseSetCurrentSize(child1, width1, ih->currentheight, shrink);\n      }\n    }\n  }\n  else /* ISPLIT_HORIZ */\n  {\n    int height1 = iSplitGetHeight1(ih);\n    if (iSplitAdjustHeight1(ih, &height1))  /* this will check for child1 and child2 */\n      ih->data->val = iSplitCalcVal(ih, height1);  /* has a MINMAX size, must fix split value */\n\n    if (child1)\n    {\n      iupBaseSetCurrentSize(child1, ih->currentwidth, height1, shrink);\n\n      if (child1->currentheight > height1)\n      {\n        /* has a minimum size, must fix split value */\n        height1 = child1->currentheight;\n        ih->data->val = iSplitCalcVal(ih, height1);\n      }\n    }\n\n    /* bar */\n    ih->firstchild->currentwidth  = ih->currentwidth;\n    ih->firstchild->currentheight = ih->data->barsize;\n\n    if (child2)\n    {\n      int height2 = iSplitGetHeight2(ih, height1);\n      iupBaseSetCurrentSize(child2, ih->currentwidth, height2, shrink);\n\n      if (child2->currentheight > height2)\n      {\n        /* has a minimum size, must fix split value */\n        height2 = child2->currentheight;\n        height1 = (ih->currentheight-ih->data->barsize) - height2;\n        ih->data->val = iSplitCalcVal(ih, height1);\n        if (child1)\n          iupBaseSetCurrentSize(child1, ih->currentwidth, height1, shrink);\n      }\n    }\n  }\n\n  if (old_val != ih->data->val)\n    iupBaseCallValueChangedCb(ih);\n}\n\nstatic void iSplitSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  Ihandle *child1, *child2 = NULL;\n  child1 = ih->firstchild->brother;\n  if (child1)\n    child2 = child1->brother;\n\n  if (ih->data->orientation == ISPLIT_VERT)\n  {\n    if (child1)\n      iupBaseSetPosition(child1, x, y);\n\n    /* bar */\n    x += iSplitGetWidth1(ih);\n    iupBaseSetPosition(ih->firstchild, x, y);\n\n    if (child2)\n    {\n      x += ih->data->barsize;\n      iupBaseSetPosition(child2, x, y);\n    }\n  }\n  else /* ISPLIT_HORIZ */\n  {\n    if (child1)\n      iupBaseSetPosition(child1, x, y);\n\n    /* bar */\n    y += iSplitGetHeight1(ih);\n    iupBaseSetPosition(ih->firstchild, x, y);\n\n    if (child2)\n    {\n      y += ih->data->barsize;\n      iupBaseSetPosition(child2, x, y);\n    }\n  }\n}\n\nstatic int iSplitCreateMethod(Ihandle* ih, void** params)\n{\n  Ihandle* bar;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->orientation = ISPLIT_VERT;\n  ih->data->val = -1;\n  ih->data->layoutdrag = 1;\n  ih->data->autohide = 0;\n  ih->data->barsize = 5;\n  ih->data->showgrip = 1;\n  ih->data->min = 0; \n  ih->data->max = 1000;\n\n  bar = IupCanvas(NULL);\n  iupChildTreeAppend(ih, bar);  /* bar will always be the firstchild */\n  bar->flags |= IUP_INTERNAL;\n\n  IupSetAttribute(bar, \"CANFOCUS\", \"NO\");\n  IupSetAttribute(bar, \"BORDER\", \"NO\");\n  IupSetAttribute(bar, \"EXPAND\", \"NO\");\n  IupSetAttribute(bar, \"CURSOR\", \"SPLITTER_VERT\");\n\n  /* Setting callbacks */\n  IupSetCallback(bar, \"BUTTON_CB\", (Icallback) iSplitButton_CB);\n  IupSetCallback(bar, \"FOCUS_CB\",  (Icallback) iSplitFocus_CB);\n  IupSetCallback(bar, \"MOTION_CB\", (Icallback) iSplitMotion_CB);\n  IupSetCallback(bar, \"ACTION\", (Icallback) iSplitAction_CB);\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    if (iparams[0]) IupAppend(ih, iparams[0]);\n    if (iparams[1]) IupAppend(ih, iparams[1]);\n  }\n\n  return IUP_NOERROR;\n}\n\nIclass* iupSplitNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name   = \"split\";\n  ic->format = \"hh\";   /* two Ihandle*(s) */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype  = IUP_CHILDMANY+3;  /* canvas+child+child */\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupSplitNewClass;\n  ic->Create  = iSplitCreateMethod;\n  ic->Map     = iupBaseTypeVoidMapMethod;\n\n  ic->ComputeNaturalSize = iSplitComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iSplitSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition    = iSplitSetChildrenPositionMethod;\n\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iSplitGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);\n\n  /* IupSplit only */\n  iupClassRegisterAttribute(ic, \"COLOR\",     NULL, iSplitSetColorAttrib,     IUPAF_SAMEASSYSTEM, \"160 160 160\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", NULL, iSplitSetOrientationAttrib, IUPAF_SAMEASSYSTEM, \"VERTICAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DIRECTION\", NULL, iSplitSetOrientationAttrib, IUPAF_SAMEASSYSTEM, \"VERTICAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE\", iSplitGetValueAttrib, iSplitSetValueAttrib, IUPAF_SAMEASSYSTEM, \"500\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LAYOUTDRAG\", iSplitGetLayoutDragAttrib, iSplitSetLayoutDragAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWGRIP\", iSplitGetShowGripAttrib, iSplitSetShowGripAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"AUTOHIDE\", iSplitGetAutoHideAttrib, iSplitSetAutoHideAttrib, IUPAF_SAMEASSYSTEM, \"NO\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"BARSIZE\", iSplitGetBarSizeAttrib, iSplitSetBarSizeAttrib, IUPAF_SAMEASSYSTEM, \"5\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MINMAX\", iSplitGetMinMaxAttrib, iSplitSetMinMaxAttrib, IUPAF_SAMEASSYSTEM, \"0:1000\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n\nIhandle* IupSplit(Ihandle* child1, Ihandle* child2)\n{\n  void *children[3];\n  children[0] = (void*)child1;\n  children[1] = (void*)child2;\n  children[2] = NULL;\n  return IupCreatev(\"split\", children);\n}\n","/** \\file\n * \\brief String Utilities\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n \n#include <string.h>  \n#include <stdlib.h>  \n#include <stdio.h>  \n#include <limits.h>\n#include <stdarg.h>\n#include <locale.h>\n\n#include \"iup_str.h\"\n\n\n/* Line breaks can be:\n\\n - UNIX\n\\r - Mac\n\\r\\n - DOS/Windows\n*/\n\n\n#define IUP_STR_EQUAL(str1, str2)      \\\n{                                      \\\n  if (str1 == str2)                    \\\n    return 1;                          \\\n                                       \\\n  if (!str1 || !str2)                  \\\n    return 0;                          \\\n                                       \\\n  while(*str1 && *str2 &&              \\\n        SF(*str1) == SF(*str2))        \\\n  {                                    \\\n    EXTRAINC(str1);                    \\\n    EXTRAINC(str2);                    \\\n    str1++;                            \\\n    str2++;                            \\\n  }                                    \\\n                                       \\\n  /* check also for terminator */      \\\n  if (*str1 == *str2) return 1;        \\\n}\n\nint iupStrEqual(const char* str1, const char* str2) \n{\n#define EXTRAINC(_x) (void)(_x)\n#define SF(_x) (_x)\n  IUP_STR_EQUAL(str1, str2);\n#undef SF\n#undef EXTRAINC\n  return 0;\n}\n\nint iupStrEqualPartial(const char* str1, const char* str2) \n{\n#define EXTRAINC(_x) (void)(_x)\n#define SF(_x) (_x)\n  IUP_STR_EQUAL(str1, str2);\n#undef SF\n#undef EXTRAINC\n  if (*str2 == 0) \n    return 1;  /* if second string is at terminator, then it is partially equal */\n  return 0;\n}\n\nint iupStrEqualNoCase(const char* str1, const char* str2) \n{\n#define EXTRAINC(_x) (void)(_x)\n#define SF(_x) iup_tolower(_x)\n  IUP_STR_EQUAL(str1, str2);\n#undef SF\n#undef EXTRAINC\n  return 0;\n}\n\nint iupStrEqualNoCasePartial(const char* str1, const char* str2) \n{\n#define EXTRAINC(_x) (void)(_x)\n#define SF(_x) iup_tolower(_x)\n  IUP_STR_EQUAL(str1, str2);\n#undef SF\n#undef EXTRAINC\n  if (*str2 == 0) \n    return 1;  /* if second string is at terminator, then it is partially equal */\n  return 0;\n}\n\nint iupStrEqualNoCaseNoSpace(const char* str1, const char* str2) \n{\n#define EXTRAINC(_x) { if (*_x == ' ') _x++; }  /* also ignore spaces */\n#define SF(_x) iup_tolower(_x)\n  IUP_STR_EQUAL(str1, str2);\n#undef SF\n#undef EXTRAINC\n  return 0;\n}\n\nint iupStrFalse(const char* str)\n{\n  if (!str || str[0]==0) return 0;\n  if (str[0]=='0' && str[1]==0) return 1;\n  if (iupStrEqualNoCase(str, \"NO\")) return 1;\n  if (iupStrEqualNoCase(str, \"OFF\")) return 1;\n  return 0;\n}\n\nint iupStrBoolean(const char* str)\n{\n  if (!str || str[0]==0) return 0;\n  if (str[0]=='1' && str[1]==0) return 1;\n  if (iupStrEqualNoCase(str, \"YES\")) return 1;\n  if (iupStrEqualNoCase(str, \"ON\")) return 1;\n  return 0;\n}\n\nvoid iupStrUpper(char* dstr, const char* sstr)\n{\n  if (!sstr || sstr[0] == 0) return;\n  for (; *sstr; sstr++, dstr++)\n    *dstr = (char)iup_toupper(*sstr);\n  *dstr = 0;\n}\n\nvoid iupStrLower(char* dstr, const char* sstr)\n{\n  if (!sstr || sstr[0] == 0) return;\n  for (; *sstr; sstr++, dstr++)\n    *dstr = (char)iup_tolower(*sstr);\n  *dstr = 0;\n}\n\nint iupStrHasSpace(const char* str)\n{\n  if (!str) return 0;\n  while (*str)\n  {\n    if (*str == ' ')\n      return 1;\n    str++;\n  }\n  return 0;\n}\n\nchar *iupStrDup(const char *str)\n{\n  if (str)\n  {\n    int size = strlen(str)+1;\n    char *newstr = malloc(size);\n    if (newstr) memcpy(newstr, str, size);\n    return newstr;\n  }\n  return NULL;\n}\n\nconst char* iupStrNextLine(const char* str, int *len)\n{\n  *len = 0;\n\n  if (!str) return NULL;\n\n  while(*str!=0 && *str!='\\n' && *str!='\\r') \n  {\n    (*len)++;\n    str++;\n  }\n\n  if (*str=='\\r' && *(str+1)=='\\n')   /* DOS line end */\n    return str+2;\n  else if (*str=='\\n' || *str=='\\r')   /* UNIX or MAC line end */\n    return str+1;\n  else \n    return str;  /* no next line */\n}\n\nconst char* iupStrNextValue(const char* str, int str_len, int *len, char sep)\n{\n  *len = 0;\n\n  if (!str) return NULL;\n\n  while(*str!=0 && *str!=sep && *len<str_len) \n  {\n    (*len)++;\n    str++;\n  }\n\n  if (*str==sep)\n    return str+1;\n  else \n    return str;  /* no next value */\n}\n\nint iupStrLineCount(const char* str)\n{\n  int num_lin = 1;\n\n  if (!str)\n    return num_lin;\n\n  while(*str != 0)\n  {\n    while(*str!=0 && *str!='\\n' && *str!='\\r')\n      str++;\n\n    if (*str=='\\r' && *(str+1)=='\\n')   /* DOS line end */\n    {\n      num_lin++;\n      str+=2;\n    }\n    else if (*str=='\\n' || *str=='\\r')   /* UNIX or MAC line end */\n    {\n      num_lin++;\n      str++;\n    }\n  }\n\n  return num_lin;\n}\n\nint iupStrCountChar(const char *str, char c)\n{\n  int n;\n  if (!str) return 0;\n  for (n=0; *str; str++)\n  {\n    if (*str==c)\n      n++;\n  }\n  return n;\n}\n\nvoid iupStrCopyN(char* dst_str, int dst_max_size, const char* src_str)\n{\n  if (src_str)\n  {\n    int size = strlen(src_str) + 1;\n    if (size > dst_max_size) size = dst_max_size;\n    memcpy(dst_str, src_str, size - 1);\n    dst_str[size - 1] = 0;\n  }\n}\n\nchar* iupStrDupUntil(const char **str, char c)\n{\n  const char *p_str;\n  char *new_str;\n  if (!str || str[0]==0)\n    return NULL;\n\n  p_str = strchr(*str,c);\n  if (!p_str) \n    return NULL;\n  else\n  {\n    int i;\n    int sl = (int)(p_str - (*str));\n\n    new_str = (char *)malloc(sl + 1);\n    if (!new_str) return NULL;\n\n    for (i = 0; i < sl; ++i)\n      new_str[i] = (*str)[i];\n\n    new_str[sl] = 0;\n\n    *str = p_str+1;\n    return new_str;\n  }\n}\n\nstatic char *iStrDupUntilNoCase(char **str, char sep)\n{\n  char *p_str,*new_str;\n  if (!str || str[0]==0)\n    return NULL;\n\n  p_str=strchr(*str,sep); /* usually the lower case is enough */\n  if (!p_str && (iup_toupper(sep)!=sep)) \n    p_str=strchr(*str, iup_toupper(sep));  /* but check also for upper case */\n\n  /* if both fail, then abort */\n  if (!p_str) \n    return NULL;\n  else\n  {\n    int i;\n    int sl=(int)(p_str - (*str));\n\n    new_str = (char *) malloc (sl + 1);\n    if (!new_str) return NULL;\n\n    for (i = 0; i < sl; ++i)\n      new_str[i] = (*str)[i];\n\n    new_str[sl] = 0;\n\n    *str = p_str+1;\n    return new_str;\n  }\n}\n\nchar *iupStrGetLargeMem(int *size)\n{\n#define LARGE_MAX_BUFFERS 10\n#define LARGE_SIZE SHRT_MAX\n  static char buffers[LARGE_MAX_BUFFERS][LARGE_SIZE];\n  static int buffers_index = -1;\n  char* ret_str;\n\n  /* init buffers array */\n  if (buffers_index == -1)\n  {\n    int i;\n\n    memset(buffers, 0, sizeof(char*)*LARGE_MAX_BUFFERS);\n    buffers_index = 0;\n\n    /* clear all memory only once */\n    for (i=0; i<LARGE_MAX_BUFFERS; i++)\n      memset(buffers[i], 0, sizeof(char)*LARGE_SIZE);\n  }\n\n  /* DON'T clear memory everytime because the buffer is too large */\n  ret_str = buffers[buffers_index];\n  ret_str[0] = 0;\n\n  buffers_index++;\n  if (buffers_index == LARGE_MAX_BUFFERS)\n    buffers_index = 0;\n\n  if (size) *size = LARGE_SIZE;\n  return ret_str;\n#undef LARGE_MAX_BUFFERS\n#undef LARGE_SIZE \n}\n\nstatic char* iupStrGetSmallMem(void)\n{\n#define SMALL_MAX_BUFFERS 100\n#define SMALL_SIZE 80  /* maximum for iupStrReturnFloat */\n  static char buffers[SMALL_MAX_BUFFERS][SMALL_SIZE];\n  static int buffers_index = -1;\n  char* ret_str;\n\n  /* init buffers array */\n  if (buffers_index == -1)\n  {\n    memset(buffers, 0, sizeof(char*)*SMALL_MAX_BUFFERS);\n    buffers_index = 0;\n  }\n\n  /* always clear memory before returning a new buffer */\n  memset(buffers[buffers_index], 0, SMALL_SIZE);\n  ret_str = buffers[buffers_index];\n\n  buffers_index++;\n  if (buffers_index == SMALL_MAX_BUFFERS)\n    buffers_index = 0;\n\n  return ret_str;\n#undef SMALL_MAX_BUFFERS\n#undef SMALL_SIZE \n}\n\nchar *iupStrGetMemory(int size)\n{\n#define MAX_BUFFERS 50\n  static char* buffers[MAX_BUFFERS];\n  static int buffers_sizes[MAX_BUFFERS];\n  static int buffers_index = -1;\n\n  int i;\n\n  if (size == -1) /* Frees memory */\n  {\n    buffers_index = -1;\n    for (i = 0; i < MAX_BUFFERS; i++)\n    {\n      if (buffers[i]) \n      {\n        free(buffers[i]);\n        buffers[i] = NULL;\n      }\n      buffers_sizes[i] = 0;\n    }\n    return NULL;\n  }\n  else\n  {\n    char* ret_str;\n\n    /* init buffers array */\n    if (buffers_index == -1)\n    {\n      memset(buffers, 0, sizeof(char*)*MAX_BUFFERS);\n      memset(buffers_sizes, 0, sizeof(int)*MAX_BUFFERS);\n      buffers_index = 0;\n    }\n\n    /* first alocation */\n    if (!(buffers[buffers_index]))\n    {\n      buffers_sizes[buffers_index] = size+1;\n      buffers[buffers_index] = (char*)malloc(buffers_sizes[buffers_index]);\n    }\n    else if (buffers_sizes[buffers_index] < size+1)  /* reallocate if necessary */\n    {\n      buffers_sizes[buffers_index] = size+1;\n      buffers[buffers_index] = (char*)realloc(buffers[buffers_index], buffers_sizes[buffers_index]);\n    }\n\n    /* always clear memory before returning a new buffer */\n    memset(buffers[buffers_index], 0, buffers_sizes[buffers_index]);\n    ret_str = buffers[buffers_index];\n\n    buffers_index++;\n    if (buffers_index == MAX_BUFFERS)\n      buffers_index = 0;\n\n    return ret_str;\n  }\n#undef MAX_BUFFERS\n}\n\nchar* iupStrReturnStrf(const char* format, ...)\n{\n  char* str = iupStrGetMemory(1024);\n  va_list arglist;\n  va_start(arglist, format);\n  vsnprintf(str, 1024, format, arglist);\n  va_end(arglist);\n  return str;\n}\n\nchar* iupStrReturnStr(const char* str)\n{\n  if (str)\n  {\n    int size = strlen(str)+1;\n    char* ret_str = iupStrGetMemory(size);\n    memcpy(ret_str, str, size);\n    return ret_str;\n  }\n  else\n    return NULL;\n}\n\nchar* iupStrReturnBoolean(int b)\n{\n  if (b)\n    return \"YES\";\n  else\n    return \"NO\";\n}\n\nchar* iupStrReturnChecked(int check)\n{\n  if (check == -1)\n    return \"NOTDEF\";\n  else if (check)\n    return \"ON\";\n  else\n    return \"OFF\";\n}\n\nchar* iupStrReturnInt(int i)\n{\n  char* str = iupStrGetSmallMem();  /* 20 */\n  sprintf(str, \"%d\", i);\n  return str;\n}\n\nchar* iupStrReturnFloat(float f)\n{\n  char* str = iupStrGetSmallMem();  /* 80 */\n  sprintf(str, IUP_FLOAT2STR, f);\n  return str;\n}\n\nchar* iupStrReturnDouble(double d)\n{\n  char* str = iupStrGetSmallMem();  /* 80 */\n  sprintf(str, IUP_DOUBLE2STR, d);\n  return str;\n}\n\nchar* iupStrReturnRGB(unsigned char r, unsigned char g, unsigned char b)\n{\n  char* str = iupStrGetSmallMem();  /* 3*20 */\n  sprintf(str, \"%d %d %d\", (int)r, (int)g, (int)b);\n  return str;\n}\n\nchar* iupStrReturnRGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  char* str = iupStrGetSmallMem();  /* 4*20 */\n  sprintf(str, \"%d %d %d %d\", (int)r, (int)g, (int)b, (int)a);\n  return str;\n}\n\nchar* iupStrReturnStrStr(const char *str1, const char *str2, char sep)\n{\n  if (str1 || str2)\n  {\n    char* ret_str;\n    int size1=0, size2=0;\n    if (str1) size1 = strlen(str1);\n    if (str2) size2 = strlen(str2);\n    ret_str = iupStrGetMemory(size1+size2+2);\n    if (str1 && size1) memcpy(ret_str, str1, size1);\n    ret_str[size1] = sep;\n    if (str2 && size2) memcpy(ret_str+size1+1, str2, size2);\n    ret_str[size1+1+size2] = 0;\n    return ret_str;\n  }\n  else\n    return NULL;\n}\n\nchar* iupStrReturnIntInt(int i1, int i2, char sep)\n{\n  char* str = iupStrGetSmallMem();  /* 2*20 */\n  sprintf(str, \"%d%c%d\", i1, sep, i2);\n  return str;\n}\n\nint iupStrGetFormatPrecision(const char* format)\n{\n  int precision;\n  while (*format)\n  {\n    if (*format == '.')\n      break;\n    format++;\n  }\n\n  if (*format != '.')\n    return -1;\n\n  format++;\n  if (iupStrToInt(format, &precision))\n    return precision;\n\n  return -1;\n}\n\nint iupStrToRGB(const char *str, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n  unsigned int ri = 0, gi = 0, bi = 0;\n  if (!str) return 0;\n  if (str[0]=='#')\n  {\n    str++;\n    if (sscanf(str, \"%2X%2X%2X\", &ri, &gi, &bi) != 3) return 0;\n  }\n  else\n  {\n    if (sscanf(str, \"%u %u %u\", &ri, &gi, &bi) != 3) return 0;\n  }\n  if (ri > 255 || gi > 255 || bi > 255) return 0;\n  *r = (unsigned char)ri;\n  *g = (unsigned char)gi;\n  *b = (unsigned char)bi;\n  return 1;\n}\n\nint iupStrToRGBA(const char *str, unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a)\n{\n  unsigned int ri = 0, gi = 0, bi = 0, ai = 255;\n  if (!str) return 0;\n  if (str[0] == '#')\n  {\n    str++;\n    if (sscanf(str, \"%2X%2X%2X%2X\", &ri, &gi, &bi, &ai) < 3) return 0;\n  }\n  else\n  {\n    if (sscanf(str, \"%u %u %u %u\", &ri, &gi, &bi, &ai) < 3) return 0;\n  }\n  if (ri > 255 || gi > 255 || bi > 255 || ai > 255) return 0;\n  *r = (unsigned char)ri;\n  *g = (unsigned char)gi;\n  *b = (unsigned char)bi;\n  *a = (unsigned char)ai;\n  return 1;\n}\n\n/* TODO: are strtod/atof and strtol/atoi faster/better than sscanf? \n         must handle the 0 return value. */\n\nint iupStrToInt(const char *str, int *i)\n{\n  if (!str) return 0;\n  if (sscanf(str, \"%d\", i) != 1) return 0;\n  return 1;\n}\n\nint iupStrToIntInt(const char *str, int *i1, int *i2, char sep)\n{\n  if (!str) return 0;\n                         \n  if (iup_tolower(*str) == sep) /* no first value */\n  {\n    str++; /* skip separator */\n    if (sscanf(str, \"%d\", i2) != 1) return 0;\n    return 1;\n  }\n  else \n  {\n    char* p_str = iStrDupUntilNoCase((char**)&str, sep);\n    \n    if (!p_str)   /* no separator means no second value */\n    {        \n      if (sscanf(str, \"%d\", i1) != 1) return 0;\n      return 1;\n    }\n    else if (*str==0)  /* separator exists, but second value empty, also means no second value */\n    {        \n      int ret = sscanf(p_str, \"%d\", i1);\n      free(p_str);\n      if (ret != 1) return 0;\n      return 1;\n    }\n    else\n    {\n      int ret = 0;\n      if (sscanf(p_str, \"%d\", i1) == 1) ret++;\n      if (sscanf(str, \"%d\", i2) == 1) ret++;\n      free(p_str);\n      return ret;\n    }\n  }\n}\n\nint iupStrToFloatDef(const char *str, float *f, float def)\n{\n  if (!str) { *f = def;  return 1; }\n  if (sscanf(str, \"%f\", f) != 1) return 0;\n  return 1;\n}\n\nint iupStrToFloat(const char *str, float *f)\n{\n  if (!str) return 0;\n  if (sscanf(str, \"%f\", f) != 1) return 0;\n  return 1;\n}\n\nint iupStrToDouble(const char *str, double *d)\n{\n  if (!str) return 0;\n  if (sscanf(str, \"%lf\", d) != 1) return 0;\n  return 1;\n}\n\nint iupStrToDoubleDef(const char *str, double *d, double def)\n{\n  if (!str) { *d = def;  return 1; }\n  if (sscanf(str, \"%lf\", d) != 1) return 0;\n  return 1;\n}\n\nint iupStrToFloatFloat(const char *str, float *f1, float *f2, char sep)\n{\n  if (!str) return 0;\n\n  if (iup_tolower(*str) == sep) /* no first value */\n  {\n    str++; /* skip separator */\n    if (sscanf(str, \"%f\", f2) != 1) return 0;\n    return 1;\n  }\n  else \n  {\n    char* p_str = iStrDupUntilNoCase((char**)&str, sep);\n    \n    if (!p_str)   /* no separator means no second value */\n    {        \n      if (sscanf(str, \"%f\", f1) != 1) return 0;\n      return 1;\n    }\n    else if (*str==0)    /* separator exists, but second value empty, also means no second value */\n    {        \n      int ret = sscanf(p_str, \"%f\", f1);\n      free(p_str);\n      if (ret != 1) return 0;\n      return 1;\n    }\n    else\n    {\n      int ret = 0;\n      if (sscanf(p_str, \"%f\", f1) == 1) ret++;\n      if (sscanf(str, \"%f\", f2) == 1) ret++;\n      free(p_str);\n      return ret;\n    }\n  }\n}\n\nint iupStrToDoubleDouble(const char *str, double *f1, double *f2, char sep)\n{\n  if (!str) return 0;\n\n  if (iup_tolower(*str) == sep) /* no first value */\n  {\n    str++; /* skip separator */\n    if (sscanf(str, \"%lf\", f2) != 1) return 0;\n    return 1;\n  }\n  else\n  {\n    char* p_str = iStrDupUntilNoCase((char**)&str, sep);\n\n    if (!p_str)   /* no separator means no second value */\n    {\n      if (sscanf(str, \"%lf\", f1) != 1) return 0;\n      return 1;\n    }\n    else if (*str == 0)    /* separator exists, but second value empty, also means no second value */\n    {\n      int ret = sscanf(p_str, \"%lf\", f1);\n      free(p_str);\n      if (ret != 1) return 0;\n      return 1;\n    }\n    else\n    {\n      int ret = 0;\n      if (sscanf(p_str, \"%lf\", f1) == 1) ret++;\n      if (sscanf(str, \"%lf\", f2) == 1) ret++;\n      free(p_str);\n      return ret;\n    }\n  }\n}\n\nint iupStrToStrStr(const char *str, char *str1, char *str2, char sep)\n{\n  if (!str) \n    return 0;\n\n  if (iup_tolower(*str) == sep) /* no first value */\n  {\n    str++; /* skip separator */\n    str1[0] = 0;\n    strcpy(str2, str);\n    return 1;\n  }\n  else \n  {\n    char* p_str = iStrDupUntilNoCase((char**)&str, sep);\n    \n    if (!p_str)   /* no separator means no second value */\n    {        \n      strcpy(str1, str);\n      str2[0] = 0;\n      return 1;\n    }\n    else if (*str==0)    /* separator exists, but second value empty, also means no second value */\n    {        \n      strcpy(str1, p_str);\n      free(p_str);\n      str2[0] = 0;\n      return 1;\n    }\n    else\n    {\n      strcpy(str1, p_str);\n      strcpy(str2, str);\n      free(p_str);\n      return 2;\n    }\n  }\n}\n\nchar* iupStrFileGetPath(const char *file_name)\n{\n  if (!file_name)\n    return NULL;\n  else\n  {\n    /* Starts at the last character */\n    int len = strlen(file_name) - 1;\n    while (len != 0)\n    {\n      if (file_name[len] == '\\\\' || file_name[len] == '/')\n      {\n        len++;\n        break;\n      }\n\n      len--;\n    }\n    if (len == 0)\n      return NULL;\n\n    {\n      char* path = malloc(len + 1);\n      memcpy(path, file_name, len);\n      path[len] = 0;\n\n      return path;\n    }\n  }\n}\n\nchar* iupStrFileGetTitle(const char *file_name)\n{\n  if (!file_name)\n    return NULL;\n  else\n  {\n    /* Starts at the last character */\n    int len = strlen(file_name);\n    int offset = len - 1;\n    while (offset != 0)\n    {\n      if (file_name[offset] == '\\\\' || file_name[offset] == '/')\n      {\n        offset++;\n        break;\n      }\n\n      offset--;\n    }\n\n    {\n      int title_size = len - offset + 1;\n      char* file_title = malloc(title_size);\n      memcpy(file_title, file_name + offset, title_size);\n      return file_title;\n    }\n  }\n}\n\nchar* iupStrFileGetExt(const char *file_name)\n{\n  if (!file_name)\n    return NULL;\n  else\n  {\n    /* Starts at the last character */\n    int len = strlen(file_name);\n    int offset = len - 1;\n    while (offset != 0)\n    {\n      /* if found a path separator stop. */\n      if (file_name[offset] == '\\\\' || file_name[offset] == '/')\n        return NULL;\n\n      if (file_name[offset] == '.')\n      {\n        offset++;\n        break;\n      }\n\n      offset--;\n    }\n\n    if (offset == 0)\n      return NULL;\n\n    {\n      int ext_size = len - offset + 1;\n      char* file_ext = (char*)malloc(ext_size);\n      memcpy(file_ext, file_name + offset, ext_size);\n      return file_ext;\n    }\n  }\n}\n\nchar* iupStrFileMakeFileName(const char* path, const char* title)\n{\n  if (!path || !title)\n    return NULL;\n  else\n  {\n    int size_path = strlen(path);\n    int size_title = strlen(title);\n    char *file_name = malloc(size_path + size_title + 2);\n    memcpy(file_name, path, size_path);\n\n    if (path[size_path - 1] != '/')\n    {\n      file_name[size_path] = '/';\n      size_path++;\n    }\n\n    memcpy(file_name + size_path, title, size_title);\n    file_name[size_path + size_title] = 0;\n\n    return file_name;\n  }\n}\n\nvoid iupStrFileNameSplit(const char* file_name, char *path, char *title)\n{\n  int i, n;\n\n  if (!file_name)\n    return;\n\n  /* Look for last folder separator and split title from path */\n  n = strlen(file_name);\n  for (i = n - 1; i >= 0; i--)\n  {\n    if (file_name[i] == '\\\\' || file_name[i] == '/') \n    {\n      if (path)\n      {\n        strncpy(path, file_name, i+1);\n        path[i+1] = 0;\n      }\n\n      if (title)\n      {\n        strcpy(title, file_name+i+1);\n        title[n-i] = 0;\n      }\n\n      return;\n    }\n  }\n}\n\nint iupStrReplace(char* str, char src, char dst)\n{\n  int i = 0;\n\n  if (!str)\n    return 0;\n\n  while (*str)\n  {\n    if (*str == src)\n    {\n      *str = dst;\n      i++;\n    }\n    str++;\n  }\n  return i;\n}\n\nvoid iupStrToUnix(char* str)\n{\n  char* pstr = str;\n\n  if (!str) return;\n  \n  while (*str)\n  {\n    if (*str == '\\r')\n    {\n      if (*(str+1) != '\\n')  /* MAC line end */\n        *pstr++ = '\\n';\n      str++;\n    }\n    else\n      *pstr++ = *str++;\n  }\n  \n  *pstr = *str;\n}\n\nvoid iupStrToMac(char* str)\n{\n  char* pstr = str;\n\n  if (!str) return;\n  \n  while (*str)\n  {\n    if (*str == '\\r')\n    {\n      if (*(++str) == '\\n')  /* DOS line end */\n        str++;\n      *pstr++ = '\\r';\n    }\n    else if (*str == '\\n')  /* UNIX line end */\n    {\n      str++;\n      *pstr++ = '\\r';\n    }\n    else\n      *pstr++ = *str++;\n  }\n  \n  *pstr = *str;\n}\n\nchar* iupStrToDos(const char* str)\n{\n\tchar *auxstr, *newstr;\n\tint num_lin;\n\n  if (!str) return NULL;\n\n  num_lin = iupStrLineCount(str);\n  if (num_lin == 1)\n    return (char*)str;\n\n\tnewstr = malloc(num_lin + strlen(str) + 1);\n  auxstr = newstr;\n\twhile(*str)\n\t{\n\t\tif (*str == '\\r' && *(str+1)=='\\n')  /* DOS line end */\n    {\n      *auxstr++ = *str++;\n      *auxstr++ = *str++;\n    }\n    else if (*str == '\\r')   /* MAC line end */\n    {\n\t\t  *auxstr++ = *str++;\n\t\t\t*auxstr++ = '\\n';\n    }\n    else if (*str == '\\n')  /* UNIX line end */\n    {\n\t\t\t*auxstr++ = '\\r';\n\t\t  *auxstr++ = *str++;\n    }\n    else\n\t\t  *auxstr++ = *str++;\n\t}\n\t*auxstr = 0;\n\n\treturn newstr;\t\n}\n\n#define IUP_ISRESERVED(_c) (_c=='\\n' || _c=='\\r' || _c=='\\t')\n\nchar* iupStrConvertToC(const char* str)\n{\n  char* new_str, *pnstr;\n  const char* pstr = str;\n  int len, count=0;\n\n  if (!str)\n    return NULL;\n\n  while(*pstr)\n  {\n    if (IUP_ISRESERVED(*pstr))\n      count++;\n    pstr++;\n  }\n  if (!count)\n    return (char*)str;\n\n  len = (int)(pstr-str);\n  new_str = malloc(len+count+1);\n  pstr = str;\n  pnstr = new_str;\n  while(*pstr)\n  {\n    if (IUP_ISRESERVED(*pstr))\n    {\n      *pnstr = '\\\\';\n      pnstr++;\n\n      switch(*pstr)\n      {\n      case '\\n':\n        *pnstr = 'n';\n        break;\n      case '\\r':\n        *pnstr = 'r';\n        break;\n      case '\\t':\n        *pnstr = 't';\n        break;\n      }\n    }\n    else\n      *pnstr = *pstr;\n\n    pnstr++;\n    pstr++;\n  }\n  *pnstr = 0;\n  return new_str;\n}\n\nchar* iupStrProcessMnemonic(const char* str, char *c, int action)\n{\n  int i = 0, found = 0;\n  char* new_str, *orig_str = (char*)str;\n\n  if (!str) \n    return NULL;\n\n  if (!strchr(str, '&'))\n    return (char*)str;\n\n  new_str = malloc(strlen(str)+1);\n  while (*str)\n  {\n    if (*str == '&')\n    {\n      if (*(str+1) == '&') /* remove & from the string, add next & to the string */\n      {\n        found = -1;\n\n        str++;\n        new_str[i++] = *str;\n      }\n      else if (found!=1) /* mnemonic found */\n      {\n        found = 1;\n\n        if (action == 1) /* replace & by c */\n          new_str[i++] = *c;\n        else if (action == -1)  /* remove & and return in c */\n          *c = *(str+1);  /* next is mnemonic */\n        /* else -- only remove & */\n      }\n    }\n    else\n    {\n      new_str[i++] = *str;\n    }\n\n    str++;\n  }\n  new_str[i] = 0;\n\n  if (found==0)\n  {\n    free(new_str);\n    return orig_str;\n  }\n\n  return new_str;\n}\n\nint iupStrFindMnemonic(const char* str)\n{\n  int c = 0, found = 0;\n\n  if (!str) \n    return 0;\n\n  if (!strchr(str, '&'))\n    return 0;\n\n  while (*str)\n  {\n    if (*str == '&')\n    {\n      if (*(str+1) == '&')\n      {\n        found = -1;\n        str++;\n      }\n      else if (found!=1) /* mnemonic found */\n      {\n        found = 1;\n        c = *(str+1);  /* next is mnemonic */\n      }\n    }\n\n    str++;\n  }\n\n  if (found==0)\n    return 0;\n  else\n    return c;\n}\n\nstatic unsigned char* Latin1_map = NULL;\nstatic unsigned char* Latin1_map_nocase = NULL;\n\nstatic void iStrInitLatin1_map(void)\n{\n  static unsigned char map[256];\n  static unsigned char map_nocase[256];\n\n  Latin1_map = map;\n  Latin1_map_nocase = map_nocase;\n\n#define M(_x) (map[(unsigned char)_x])\n\n  /* these characters are sorted in the same order as Excel would sort them */\n\n  M(  0)=  0;  M(  1)=  1; M(  2)=  2; M(  3)=  3; M(  4)=  4; M(  5)=  5; M(  6)=  6; M(  7)=  7;  M(  8)=  8; M(  9)=  9; M( 10)= 10; M( 11)= 11; M( 12)= 12; M( 13)= 13; M( 14)= 14; M( 15)= 15; \n  M( 16)= 16;  M( 17)= 17; M( 18)= 18; M( 19)= 19; M( 20)= 20; M( 21)= 21; M( 22)= 22; M( 23)= 23;  M( 24)= 24; M( 25)= 25; M( 26)= 26; M( 27)= 27; M( 28)= 28; M( 29)= 29; M( 30)= 30; M( 31)= 31; \n  M('\\'')= 32; M('-')= 33; M('�')= 34; M('�')= 35; M(' ')= 36; M('!')= 37; M('\"')= 38; M('#')= 39;  M('$')= 40; M('%')= 41; M('&')= 42; M('(')= 43; M(')')= 44; M('*')= 45; M(',')= 46; M('.')= 47; \n  M('/')= 48;  M(':')= 49; M(';')= 50; M('?')= 51; M('@')= 52; M('(')= 53; M(')')= 54; M('^')= 55;  M('�')= 56; M('_')= 57; M('`')= 58; M('{')= 59; M('|')= 60; M('}')= 61; M('~')= 62; M('�')= 63; \n  M('�')= 64;  M('�')= 65; M('�')= 66; M('�')= 67; M('�')= 68; M('�')= 69; M('�')= 70; M('�')= 71;  M('�')= 72; M('�')= 73; M('�')= 74; M('�')= 75; M('�')= 76; M('�')= 77; M('�')= 78; M('�')= 79; \n  M('�')= 80;  M('�')= 81; M('�')= 82; M('�')= 83; M('+')= 84; M('<')= 85; M('=')= 86; M('>')= 87;  M('�')= 88; M('�')= 89; M('�')= 90; M('�')= 91; M('�')= 92; M('�')= 93; M('�')= 94; M('�')= 95; \n  M('�')= 96;  M('�')= 97; M('�')= 98; M('�')= 99; M('�')=100; M('�')=101; M('�')=102; M('�')=103;  M('�')=104; M('�')=105; M('0')=106; M('�')=107; M('�')=108; M('�')=109; M('1')=110; M('�')=111; \n  M('2')=112;  M('�')=113; M('3')=114; M('�')=115; M('4')=116; M('5')=117; M('6')=118; M('7')=119;  M('8')=120; M('9')=121; M('a')=122; M('A')=123; M('�')=124; M('�')=125; M('�')=126; M('�')=127; \n  M('�')=128;  M('�')=129; M('�')=130; M('�')=131; M('�')=132; M('�')=133; M('�')=134; M('�')=135;  M('�')=136; M('�')=137; M('�')=138; M('b')=139; M('B')=140; M('c')=141; M('C')=142; M('�')=143; \n  M('�')=144;  M('d')=145; M('D')=146; M('�')=147; M('�')=148; M('e')=149; M('E')=150; M('�')=151;  M('�')=152; M('�')=153; M('�')=154; M('�')=155; M('�')=156; M('�')=157; M('�')=158; M('f')=159; \n  M('F')=160;  M('�')=161; M('g')=162; M('G')=163; M('h')=164; M('H')=165; M('i')=166; M('I')=167;  M('�')=168; M('�')=169; M('�')=170; M('�')=171; M('�')=172; M('�')=173; M('�')=174; M('�')=175; \n  M('j')=176;  M('J')=177; M('k')=178; M('K')=179; M('l')=180; M('L')=181; M('m')=182; M('M')=183;  M('n')=184; M('N')=185; M('�')=186; M('�')=187; M('o')=188; M('O')=189; M('�')=190; M('�')=191; \n  M('�')=192;  M('�')=193; M('�')=194; M('�')=195; M('�')=196; M('�')=197; M('�')=198; M('�')=199;  M('�')=200; M('�')=201; M('�')=202; M('�')=203; M('�')=204; M('p')=205; M('P')=206; M('q')=207; \n  M('Q')=208;  M('r')=209; M('R')=210; M('s')=211; M('S')=212; M('�')=213; M('�')=214; M('�')=215;  M('t')=216; M('T')=217; M('�')=218; M('�')=219; M('�')=220; M('u')=221; M('U')=222; M('�')=223; \n  M('�')=224;  M('�')=225; M('�')=226; M('�')=227; M('�')=228; M('�')=229; M('�')=230; M('v')=231;  M('V')=232; M('w')=233; M('W')=234; M('x')=235; M('X')=236; M('y')=237; M('Y')=238; M('�')=239; \n  M('�')=240;  M('�')=241; M('�')=242; M('z')=243; M('Z')=244; M('�')=245; M('�')=246; M('\\\\')=247; M(127)=248; M(129)=249; M(141)=250; M(143)=251; M(144)=252; M(157)=253; M(160)=254; M(173)=255; \n\n#undef M\n\n#define M(_x) (map_nocase[(unsigned char)_x])\n\n  /* here case differences use the same code */\n  M(  0)=  0;  M(  1)=  1; M(  2)=  2; M(  3)=  3; M(  4)=  4; M(  5)=  5; M(  6)=  6; M(  7)=  7;  M(  8)=  8; M(  9)=  9; M( 10)= 10; M( 11)= 11; M( 12)= 12; M( 13)= 13; M( 14)= 14; M( 15)= 15; \n  M( 16)= 16;  M( 17)= 17; M( 18)= 18; M( 19)= 19; M( 20)= 20; M( 21)= 21; M( 22)= 22; M( 23)= 23;  M( 24)= 24; M( 25)= 25; M( 26)= 26; M( 27)= 27; M( 28)= 28; M( 29)= 29; M( 30)= 30; M( 31)= 31; \n  M('\\'')= 32; M('-')= 33; M('�')= 34; M('�')= 35; M(' ')= 36; M('!')= 37; M('\"')= 38; M('#')= 39;  M('$')= 40; M('%')= 41; M('&')= 42; M('(')= 43; M(')')= 44; M('*')= 45; M(',')= 46; M('.')= 47; \n  M('/')= 48;  M(':')= 49; M(';')= 50; M('?')= 51; M('@')= 52; M('(')= 53; M(')')= 54; M('^')= 55;  M('�')= 56; M('_')= 57; M('`')= 58; M('{')= 59; M('|')= 60; M('}')= 61; M('~')= 62; M('�')= 63; \n  M('�')= 64;  M('�')= 65; M('�')= 66; M('�')= 67; M('�')= 68; M('�')= 69; M('�')= 70; M('�')= 71;  M('�')= 72; M('�')= 73; M('�')= 74; M('�')= 75; M('�')= 76; M('�')= 77; M('�')= 78; M('�')= 79; \n  M('�')= 80;  M('�')= 81; M('�')= 82; M('�')= 83; M('+')= 84; M('<')= 85; M('=')= 86; M('>')= 87;  M('�')= 88; M('�')= 89; M('�')= 90; M('�')= 91; M('�')= 92; M('�')= 93; M('�')= 94; M('�')= 95; \n  M('�')= 96;  M('�')= 97; M('�')= 98; M('�')= 99; M('�')=100; M('�')=101; M('�')=102; M('�')=103;  M('�')=104; M('�')=105; M('0')=106; M('�')=107; M('�')=108; M('�')=109; M('1')=110; M('�')=111; \n  M('2')=112;  M('�')=113; M('3')=114; M('�')=115; M('4')=116; M('5')=117; M('6')=118; M('7')=119;  M('8')=120; M('9')=121; M('a')=122; M('A')=122; M('�')=124; M('�')=125; M('�')=125; M('�')=127; \n  M('�')=127;  M('�')=129; M('�')=129; M('�')=131; M('�')=131; M('�')=133; M('�')=133; M('�')=135;  M('�')=135; M('�')=137; M('�')=137; M('b')=139; M('B')=139; M('c')=141; M('C')=141; M('�')=143; \n  M('�')=143;  M('d')=145; M('D')=145; M('�')=147; M('�')=147; M('e')=149; M('E')=149; M('�')=151;  M('�')=151; M('�')=153; M('�')=153; M('�')=155; M('�')=155; M('�')=157; M('�')=157; M('f')=159; \n  M('F')=159;  M('�')=161; M('g')=162; M('G')=162; M('h')=164; M('H')=164; M('i')=166; M('I')=166;  M('�')=168; M('�')=168; M('�')=170; M('�')=170; M('�')=172; M('�')=172; M('�')=174; M('�')=174; \n  M('j')=176;  M('J')=176; M('k')=178; M('K')=178; M('l')=180; M('L')=180; M('M')=182; M('M')=182;  M('n')=184; M('N')=184; M('�')=186; M('�')=186; M('o')=188; M('O')=188; M('�')=190; M('�')=191; \n  M('�')=191;  M('�')=193; M('�')=194; M('�')=195; M('�')=196; M('�')=197; M('�')=198; M('�')=199;  M('�')=200; M('�')=201; M('�')=202; M('�')=203; M('�')=204; M('p')=205; M('P')=206; M('q')=207; \n  M('Q')=208;  M('r')=209; M('R')=209; M('s')=211; M('S')=211; M('�')=213; M('�')=213; M('�')=215;  M('t')=216; M('T')=216; M('�')=218; M('�')=218; M('�')=220; M('u')=221; M('U')=221; M('�')=223; \n  M('�')=223;  M('�')=225; M('�')=225; M('�')=227; M('�')=227; M('�')=229; M('�')=229; M('v')=231;  M('V')=231; M('w')=233; M('W')=233; M('x')=235; M('X')=235; M('y')=237; M('Y')=237; M('�')=239; \n  M('�')=239;  M('�')=241; M('�')=241; M('z')=243; M('Z')=243; M('�')=245; M('�')=245; M('\\\\')=247; M(127)=248; M(129)=249; M(141)=250; M(143)=251; M(144)=252; M(157)=253; M(160)=254; M(173)=255; \n\n#undef M\n}\n\nstatic char iStrUTF8toLatin1(const char* *l)\n{\n  char c = **l;\n\n  if (c >= 0) \n    return c;   /* ASCII */\n\n  if ((c & 0x20) == 0)       /* Use 00100000 to detect 110XXXXX */\n  {\n    short u;\n    u  = (c & 0x1F) << 6;    /* first part + make room for second part */\n    (*l)++;\n    c = **l;\n    u |= (c & 0x3F);         /* second part (10XXXXXX) */\n    if (u >= -128 && u < 128)\n      return (char)u;\n    else\n      return 0;\n  }\n\n  /* only increment the pointer for the remaining codes */\n  if ((c & 0x10) == 0)       /* Use 00010000 to detect 1110XXXX */\n    *l += 3-1;  \n  else if ((c & 0x08) == 0)  /* Use 00001000 to detect 11110XXX */\n    *l += 4-1;\n\n  return 0;\n}\n\n/*\nThe Alphanum Algorithm is an improved sorting algorithm for strings\ncontaining numbers.  Instead of sorting numbers in ASCII order like a\nstandard sort, this algorithm sorts numbers in numeric order.\n\nThe Alphanum Algorithm is discussed at http://www.DaveKoelle.com/alphanum.html\n\nThis implementation is Copyright (c) 2008 Dirk Jagdmann <doj@cubic.org>.\nIt is a cleanroom implementation of the algorithm and not derived by\nother's works. In contrast to the versions written by Dave Koelle this\nsource code is distributed with the libpng/zlib license.\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you\n       must not claim that you wrote the original software. If you use\n       this software in a product, an acknowledgment in the product\n       documentation would be appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and\n       must not be misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n       distribution.\n\n***************************************************************************\n\nThe following code is based on the \"alphanum.hpp\" code \ndownloaded from the Dave Koelle page and implemented by Dirk Jagdmann.\n\nIt was modified to the C language and simplified to IUP needs.\n*/\n\nint iupStrCompare(const char *l, const char *r, int casesensitive, int utf8)\n{\n  enum mode_t { STRING, NUMBER } mode=STRING;\n\n  if (!l || !r)\n    return 0;\n\n  if (!Latin1_map)\n    iStrInitLatin1_map();\n\n  while(*l && *r)\n  {\n    if (mode == STRING)\n    {\n      while((*l) && (*r))\n      {\n        int diff;\n        char l_char = *l, \n             r_char = *r;\n\n        /* check if this are digit characters */\n        int l_digit = iup_isdigit(l_char), \n            r_digit = iup_isdigit(r_char);\n\n        /* if both characters are digits, we continue in NUMBER mode */\n        if(l_digit && r_digit)\n        {\n          mode = NUMBER;\n          break;\n        }\n\n        /* if only the left character is a digit, we have a result */\n        if(l_digit) return -1;\n\n        /* if only the right character is a digit, we have a result */\n        if(r_digit) return +1;\n\n        if (utf8)\n        {\n          l_char = iStrUTF8toLatin1(&l);  /* increment n-1 an utf8 character */\n          r_char = iStrUTF8toLatin1(&r);\n        }\n\n        /* compute the difference of both characters */\n        if (casesensitive)\n          diff = Latin1_map[(unsigned char)l_char] - Latin1_map[(unsigned char)r_char];\n        else\n          diff = Latin1_map_nocase[(unsigned char)l_char] - Latin1_map_nocase[(unsigned char)r_char];\n\n        /* if they differ we have a result */\n        if(diff != 0) return diff;\n\n        /* otherwise process the next characters */\n        ++l;\n        ++r;\n      }\n    }\n    else /* mode==NUMBER */\n    {\n      unsigned long r_int;\n      long diff;\n\n      /* get the left number */\n      unsigned long l_int=0;\n      while(*l && iup_isdigit(*l))\n      {\n        /* TODO: this can overflow */\n        l_int = l_int*10 + *l-'0';\n        ++l;\n      }\n\n      /* get the right number */\n      r_int=0;\n      while(*r && iup_isdigit(*r))\n      {\n        /* TODO: this can overflow */\n        r_int = r_int*10 + *r-'0';\n        ++r;\n      }\n\n      /* if the difference is not equal to zero, we have a comparison result */\n      diff = l_int-r_int;\n      if (diff != 0)\n        return (int)diff;\n\n      /* otherwise we process the next substring in STRING mode */\n      mode=STRING;\n    }\n  }\n\n  if (*r) return -1;\n  if (*l) return +1;\n  return 0;\n}\n\nint iupStrCompareEqual(const char *l, const char *r, int casesensitive, int utf8, int partial)\n{\n  if (!l || !r)\n    return 0;\n\n  if (!Latin1_map)\n    iStrInitLatin1_map();\n\n  while(*l && *r)\n  {\n    int diff;\n    char l_char = *l, \n         r_char = *r;\n\n    if (utf8)\n    {\n      l_char = iStrUTF8toLatin1(&l);  /* increment n-1 an utf8 character */\n      r_char = iStrUTF8toLatin1(&r);\n    }\n\n    /* compute the difference of both characters */\n    if (casesensitive)\n      diff = l_char - r_char;\n    else\n      diff = Latin1_map_nocase[(unsigned char)l_char] - Latin1_map_nocase[(unsigned char)r_char];\n\n    /* if they differ we have a result */\n    if(diff != 0) \n      return 0;\n\n    /* otherwise process the next characters */\n    ++l;\n    ++r;\n  }\n\n  /* check also for terminator */\n  if (*l == *r) \n    return 1;\n\n  if (partial && *r == 0) \n    return 1;  /* if second string is at terminator, then it is partially equal */\n\n  return 0;\n}\n\nstatic int iStrIncUTF8(const char* str)\n{\n  if (*str >= 0)      /* ASCII */\n    return 1;  \n  else if ((*str & 0x20) == 0)  /* Use 00100000 to detect 110XXXXX */\n    return 2;  \n  else if ((*str & 0x10) == 0)  /* Use 00010000 to detect 1110XXXX */\n    return 3;  \n  else if ((*str & 0x08) == 0)  /* Use 00001000 to detect 11110XXX */\n    return 4;\n  return 1;\n}\n\nint iupStrCompareFind(const char *l, const char *r, int casesensitive, int utf8)\n{\n  int i, inc, l_len, r_len, count;\n\n  if (!l || !r)\n    return 0;\n\n  l_len = strlen(l);\n  r_len = strlen(r);\n  count = l_len - r_len;\n  if (count < 0)\n    return 0;\n\n  count++;\n\n  for (i=0; i<count; i++)\n  {\n    if (iupStrCompareEqual(l, r, casesensitive, utf8, 1))\n      return 1;\n\n    if (utf8)\n    {\n      inc = iStrIncUTF8(l);\n      l += inc;\n      i += inc-1;\n    }\n    else\n      l++;\n  }\n\n  return 0;\n}\n\nstatic void iStrFixPosUTF8(const char* str, int *start, int *end)\n{\n  int p = 0, i = 0, find = 0, inc;\n  while (*(str + i))\n  {\n    if (find == 0 && p == *start)\n    {\n      *start = i;\n      find = 1;\n    }\n    if (find == 1 && p == *end)\n    {\n      *end = i;\n      return;\n    }\n\n    inc = iStrIncUTF8(str + i);\n    i += inc;\n    p++;\n  }\n\n  if (find == 0 && p == *start)\n  {\n    *start = i;\n    find = 1;\n  }\n\n  if (find == 1 && p == *end)\n    *end = i;\n}\n\nvoid iupStrRemove(char* str, int start, int end, int dir, int utf8)\n{\n  int len;\n\n  if (end < start || !str || str[0] == 0)\n    return;\n\n  if (start == end)\n  {\n    if (dir == 1)  /* (forward) */\n      end++;\n    else  /* dir==-1 (backward) */\n    {\n      if (start == 0) /* there is nothing to remove before */\n        return;\n      else\n        start--;\n    }\n  }\n\n  if (utf8)\n    iStrFixPosUTF8(str, &start, &end);\n\n  /* from \"start\" remove up to \"end\", but not including \"end\" */\n  len = strlen(str);\n  if (start >= len) { start = len - 1; end = len; }\n  if (end > len) end = len;\n\n  memmove(str + start, str + end, len - end + 1);\n}\n\nchar* iupStrInsert(const char* str, const char* insert_str, int start, int end, int utf8)\n{\n  char* new_str = (char*)str;\n  int insert_len, len;\n\n  if (!str || !insert_str)\n    return NULL;\n\n  insert_len = strlen(insert_str);\n  len = strlen(str);\n\n  if (utf8)\n    iStrFixPosUTF8(str, &start, &end);\n\n  if (end == start || insert_len > end - start)\n  {\n    new_str = malloc(len - (end - start) + insert_len + 1);\n    memcpy(new_str, str, start);\n    memcpy(new_str + start, insert_str, insert_len);\n    memcpy(new_str + start + insert_len, str + end, len - end + 1);\n  }\n  else\n  {\n    memcpy(new_str + start, insert_str, insert_len);\n    memcpy(new_str + start + insert_len, str + end, len - end + 1);\n  }\n\n  return new_str;\n}\n\nint iupStrIsAscii(const char* str)\n{\n  if (!str)\n    return 0;\n\n  while (*str)\n  {\n    int c = *str;\n    if (c < 0)\n      return 0;\n    str++;\n  }\n  return 1;\n}\n\nstatic char* iStrSetLocale(const char* decimal_symbol)\n{\n  if (decimal_symbol)\n  {\n    struct lconv* locale_info = localeconv();\n    if (locale_info->decimal_point[0] != decimal_symbol[0])\n    {\n      char* old_locale = setlocale(LC_NUMERIC, NULL);\n\n      if (decimal_symbol[0] == '.')\n      {\n        old_locale = iupStrDup(old_locale);  /* must be before another setlocale */\n        setlocale(LC_NUMERIC, \"en-US\");\n        return old_locale;\n      }\n      else if (decimal_symbol[0] == ',')\n      {\n        old_locale = iupStrDup(old_locale);  /* must be before another setlocale */\n        setlocale(LC_NUMERIC, \"pt-BR\");\n        return old_locale;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic void iStrResetLocale(char* old_locale)\n{\n  if (old_locale)\n  {\n    setlocale(LC_NUMERIC, old_locale);\n    free(old_locale);\n  }\n}\n\nint iupStrToDoubleLocale(const char *str, double *d, const char* decimal_symbol)\n{\n  int ret, locale_set = 0;\n  char* old_locale;\n\n  if (!str) \n    return 0;\n\n  old_locale = iStrSetLocale(decimal_symbol);\n  if (old_locale) locale_set = 1;\n\n  ret = sscanf(str, \"%lf\", d);\n\n  iStrResetLocale(old_locale);\n\n  if (ret != 1) \n    return 0;\n\n  if (locale_set)\n    return 2;\n  else\n    return 1;\n}\n\nvoid iupStrPrintfDoubleLocale(char *str, const char *format, double d, const char* decimal_symbol)\n{\n  char* old_locale = iStrSetLocale(decimal_symbol);\n\n  sprintf(str, format, d);\n\n  iStrResetLocale(old_locale);\n}\n","/** \\file\n * \\brief String Utilities\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n \n#include <string.h>  \n#include <stdlib.h>  \n#include <stdio.h>  \n#include <limits.h>  \n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_strmessage.h\"\n#include \"iup_table.h\"\n\n\nstatic void iStrMessageRegisterInternal(int lng, int utf8mode);\n\nstatic Itable *istrmessage_table = NULL;   /* the message hash table indexed by the name string */\n\nvoid iupStrMessageInit(void)\n{\n  istrmessage_table = iupTableCreate(IUPTABLE_STRINGINDEXED);\n\n  iStrMessageRegisterInternal(0, 0);\n}\n\nvoid iupStrMessageFinish(void)\n{\n  iupTableDestroy(istrmessage_table);\n  istrmessage_table = NULL;\n}\n\nchar* IupGetLanguageString(const char* name)\n{\n  char* value;\n  if (!name) return NULL;\n  value = (char*)iupTableGet(istrmessage_table, name);\n  if (!value)\n    return (char*)name;\n  return value;\n}\n\nvoid IupSetLanguageString(const char* name, const char* str)\n{\n  iupTableSet(istrmessage_table, name, (char*)str, IUPTABLE_POINTER);\n}\n\nvoid IupStoreLanguageString(const char* name, const char* str)\n{\n  iupTableSet(istrmessage_table, name, (char*)str, IUPTABLE_STRING);\n}\n\nvoid IupSetLanguagePack(Ihandle* ih)\n{\n  if (!ih)\n    iupTableClear(istrmessage_table);\n  else\n  {\n    char *name, *value;\n\n    name = iupTableFirst(ih->attrib);\n    while (name)\n    {\n      value = (char*)iupTableGetCurr(ih->attrib);\n\n      if (iupTableGetCurrType(ih->attrib)==IUPTABLE_STRING)\n        iupTableSet(istrmessage_table, name, value, IUPTABLE_STRING);\n      else\n        iupTableSet(istrmessage_table, name, value, IUPTABLE_POINTER);\n\n      name = iupTableNext(ih->attrib);\n    }\n  }\n}\n\nvoid IupSetLanguage(const char *language)\n{\n  IupStoreGlobal(\"LANGUAGE\", language);\n}\n\nchar *IupGetLanguage(void)\n{\n  return IupGetGlobal(\"LANGUAGE\");\n}\n\n\n/**********************************************************************************/\n\n\n#define ISRTMSG_NUM_LNG 4    /* 3+1 for expansion */\n                             /* ENGLISH, PORTUGUESE, PORTUGUESE(UTF-8), NULL */\n\ntypedef struct _IstdMessage\n{\n  const char* name;\n  const char* lng_str[ISRTMSG_NUM_LNG];\n} IstdMessage;\n\nstatic int istrmessage_lng = 0;\n\n/* When seeing this file assuming ISO8859-1 encoding, lng=1 will appear correct.\n   When seeing this file assuming UTF-8 encoding, lng=2 will appear correct. */\n\nstatic IstdMessage iStdMessages[] =\n{\n  {\"IUP_ERROR\", {\"Error\", \"Erro\", NULL, NULL}},\n  {\"IUP_YES\", {\"Yes\", \"Sim\", NULL, NULL}},\n  {\"IUP_NO\", {\"No\", \"N�o\", \"Não\", NULL}},\n  {\"IUP_INVALIDDIR\", {\"Invalid directory.\", \"Diret�rio inv�lido.\", \"Diretório inválido.\", NULL}},\n  {\"IUP_FILEISDIR\", {\"The selected name is a directory.\", \"O nome selecionado � um diret�rio.\", \"O nome selecionado é um diretório.\", NULL}},\n  {\"IUP_FILENOTEXIST\", {\"File does not exist.\", \"Arquivo inexistente.\", NULL, NULL}},\n  {\"IUP_FILEOVERWRITE\", {\"Overwrite existing file?\", \"Sobrescrever arquivo?\", NULL, NULL}},\n  {\"IUP_CREATEFOLDER\", {\"Create Folder\", \"Criar Diret�rio\", \"Criar Diretório\", NULL}},\n  {\"IUP_NAMENEWFOLDER\", {\"Name of the new folder:\", \"Nome do novo diret�rio:\", \"Nome do novo diretório:\", NULL}},\n  {\"IUP_SAVEAS\", {\"Save As\", \"Salvar Como\", NULL, NULL}},\n  {\"IUP_OPEN\", {\"Open\", \"Abrir\", NULL, NULL}},\n  {\"IUP_SELECTDIR\", {\"Select Directory\", \"Selecionar Diret�rio\", \"Selecionar Diretório\", NULL}},\n  {\"IUP_OK\", {\"OK\", \"OK\", NULL, NULL}},\n  {\"IUP_CANCEL\", {\"Cancel\", \"Cancelar\", NULL, NULL}},\n  {\"IUP_APPLY\", {\"Apply\", \"Aplicar\", NULL, NULL}},\n  {\"IUP_RESET\", {\"Reset\", \"Reinicializar\", NULL, NULL}},\n  {\"IUP_GETCOLOR\", {\"Color Selection\", \"Sele��o de Cor\", \"Seleção de Cor\", NULL}},\n  {\"IUP_HELP\", {\"Help\", \"Ajuda\", NULL, NULL}},\n  {\"IUP_RED\", {\"&Red:\", \"&Vermelho:\", NULL, NULL}},\n  {\"IUP_GREEN\", {\"&Green:\", \"V&erde:\", NULL, NULL}},\n  {\"IUP_BLUE\", {\"&Blue:\", \"&Azul:\", NULL, NULL}},\n  {\"IUP_HUE\", {\"&Hue:\", \"&Matiz:\", NULL, NULL}},\n  {\"IUP_SATURATION\", {\"&Saturation:\", \"&Satura��o:\", \"&Saturação:\", NULL}},\n  {\"IUP_INTENSITY\", {\"&Intensity:\", NULL, \"&Intensidade:\", NULL}},\n  {\"IUP_OPACITY\", {\"&Opacity:\", \"&Opacidade:\", NULL, NULL}},\n  {\"IUP_PALETTE\", {\"&Palette:\", \"&Paleta:\", NULL, NULL}},\n  {\"IUP_TRUE\", {\"True\", \"Verdadeiro\", NULL, NULL}},\n  {\"IUP_FALSE\", {\"False\", \"Falso\", NULL, NULL}},\n  {\"IUP_FAMILY\", {\"Family:\", \"Fam�lia:\", \"Família:\", NULL}},\n  {\"IUP_STYLE\", {\"Style:\", \"Estilo:\", NULL, NULL}},\n  {\"IUP_SIZE\", {\"Size:\", \"Tamanho:\", NULL, NULL}},\n  {\"IUP_SAMPLE\", {\"Sample:\", \"Exemplo:\", NULL, NULL}},\n  {NULL, {NULL, NULL, NULL}}\n};\n\nstatic void iStrMessageRegisterInternal(int lng, int utf8mode)\n{\n  IstdMessage* messages = iStdMessages;\n  while (messages->name)\n  {\n    if (utf8mode && !(messages->lng_str[lng]))\n      IupSetLanguageString(messages->name, messages->lng_str[lng-1]);\n    else\n      IupSetLanguageString(messages->name, messages->lng_str[lng]);\n    messages++;\n  }\n  istrmessage_lng = lng;\n}\n\nvoid iupStrMessageUpdateLanguage(const char* language)\n{\n  int lng = 0;  /* ENGLISH */\n  int utf8mode = IupGetInt(NULL, \"UTF8MODE\");\n  if (iupStrEqualNoCase(language, \"PORTUGUESE\"))\n  {\n    if (utf8mode)\n      lng = 2;\n    else\n      lng = 1;\n  }\n  if (lng != istrmessage_lng)\n    iStrMessageRegisterInternal(lng, utf8mode);\n}\n","/** \\file\n * \\brief iupTable functions.\n * Implementation by Danny Reinhold and Antonio Scuri. \n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"iup_table.h\"\n#include \"iup_str.h\"\n#include \"iup_assert.h\"\n\n/* #define DEBUGTABLE 1 */\n\n/* Adjust these parameters for optimal performance and memory usage */\nstatic const unsigned int itable_maxTableSizeIndex = 8;\nstatic const unsigned int itable_hashTableSize[] = { 31, 101, 401, 1601, 4001, 8009, 16001, 32003, 64007 };\nstatic const unsigned int itable_resizeLimit = 2;\nstatic const unsigned int itable_itemGrow = 5;\n\n/* Iteration context.\n */\ntypedef struct _ItableContext\n{\n  unsigned int entryIndex;  /* index at the Itable::entries array */\n  unsigned int itemIndex;   /* index at the ItableEntry::items array */\n} ItableContext;\n\n/* A key of an item.\n * To avoid lots of string comparisions we store\n * a keyindex as an integer.\n * To find a key in an item list we only have to\n * do integer comparisions.\n * Additionally the key itself is stored in\n * keyStr. In a string indexed hashtable this is\n * a duplicated string, in a pointer indexed hash table\n * this is simply the pointer (in this case keyIndex\n * and keyStr are equal).\n*/\ntypedef struct _ItableKey\n{\n  unsigned long keyIndex;  /* the secondary hash number */\n  const char   *keyStr;\n}\nItableKey;\n\n/* An item in the hash table.\n * Such an item is stored in the item list of\n * an entry.\n */\ntypedef struct _ItableItem\n{\n  Itable_Types  itemType;\n  ItableKey     key;\n  void*         value;\n}\nItableItem;\n\n/* An entry in the hash table.\n * An entry is chosen by an index in the hash table\n * and contains a list of items.\n * The number of items in this list is stored\n * in nextItemIndex.\n * size is the current size of the items array.\n */\ntypedef struct _ItableEntry\n{\n  unsigned int  nextItemIndex;\n  unsigned int  itemsSize;\n  ItableItem*   items;\n}\nItableEntry;\n\n\n/* A hash table.\n * entries is an array of entries. Select an\n * entry by its index.\n * size is the number of entries in the hash table...\n */\nstruct _Itable\n{\n  unsigned int         entriesSize;\n  unsigned int         numberOfEntries;\n  unsigned int         tableSizeIndex;  /* index into itable_hashTableSize array */\n  Itable_IndexTypes    indexType;  /* type of the index: string or pointer. */\n  ItableEntry          *entries;\n  ItableContext        context;\n};\n\n\n/* Prototypes of private functions */\n\nstatic void iTableFreeItemArray(Itable_IndexTypes indexType, unsigned int nextFreeIndex, \n                                                            ItableItem *items);\nstatic unsigned int iTableGetEntryIndex(Itable *it, const char *key, unsigned long *keyIndex);\nstatic unsigned int iTableFindItem(Itable *it, const char *key, ItableEntry **entry, \n                                                          unsigned int *itemIndex,\n                                                          unsigned long *keyIndex);\nstatic unsigned int iTableResize(Itable *it);\nstatic void iTableAdd(Itable *it, ItableKey *key, void *value, Itable_Types itemType);\nstatic void iTableUpdateArraySize(ItableEntry *entry);   \n\n#ifdef DEBUGTABLE\nstatic void iTableShowStatistics(Itable *it);\nstatic void iTableCheckDuplicated(ItableItem *item, unsigned int nextItemIndex, \n                                              const char *key, \n                                              unsigned long keyIndex);\n#endif\n\n\nItable *iupTableCreate(Itable_IndexTypes indexType)\n{\n  return iupTableCreateSized(indexType, 1);  /* 101 shows to be a better start for IUP */\n}\n\n\nItable *iupTableCreateSized(Itable_IndexTypes indexType, unsigned int initialSizeIndex)\n{\n  Itable *it = (Itable *)malloc(sizeof(Itable));\n  iupASSERT(it!=NULL);\n  if (!it)\n    return 0;\n\n  if (initialSizeIndex > itable_maxTableSizeIndex)\n    initialSizeIndex = itable_maxTableSizeIndex;\n\n  it->entriesSize    = itable_hashTableSize[initialSizeIndex];\n  it->tableSizeIndex  = initialSizeIndex;\n  it->numberOfEntries = 0;\n  it->indexType       = indexType;\n\n  it->entries = (ItableEntry *)malloc(it->entriesSize * sizeof(ItableEntry));\n  iupASSERT(it->entries!=NULL);\n  if (!it->entries)\n  {\n    free(it);\n    return 0;\n  }\n\n  memset(it->entries, 0, it->entriesSize * sizeof(ItableEntry));\n\n  it->context.entryIndex = (unsigned int)-1;\n  it->context.itemIndex = (unsigned int)-1;\n\n  return it;\n}\n\nvoid iupTableClear(Itable *it)\n{\n  unsigned int i;\n\n  if (!it)\n    return;\n\n  for (i = 0; i < it->entriesSize; i++)\n  {\n    ItableEntry *entry = &(it->entries[i]);\n    if (entry->items)\n    {\n      iTableFreeItemArray(it->indexType, entry->nextItemIndex, entry->items);\n      entry->items = NULL;\n    }\n  }\n\n  it->numberOfEntries = 0;\n\n  memset(it->entries, 0, it->entriesSize * sizeof(ItableEntry));\n\n  it->context.entryIndex = (unsigned int)-1;\n  it->context.itemIndex = (unsigned int)-1;\n}\n\nvoid iupTableDestroy(Itable *it)\n{\n  if (!it)\n    return;\n\n#ifdef DEBUGTABLE\n   iTableShowStatistics(it);\n#endif\n\n  iupTableClear(it);\n\n  if (it->entries)\n  {\n    free(it->entries);\n    it->entries = NULL;\n  }\n\n  free(it);\n}\n\nint iupTableCount(Itable *it)\n{\n  iupASSERT(it!=NULL);\n  if (!it)\n    return 0;\n  return it->numberOfEntries;\n}\n\nvoid iupTableSetFunc(Itable *it, const char *key, Ifunc func)\n{\n  iupTableSet(it, key, (void*)func, IUPTABLE_FUNCPOINTER); /* type cast from function pointer to void* */\n}\n\nvoid iupTableSet(Itable *it, const char *key, void *value, Itable_Types itemType)\n{\n  unsigned int  itemIndex,\n                itemFound;\n  unsigned long keyIndex;\n  ItableEntry  *entry;\n  ItableItem   *item;\n  void         *v;\n\n  iupASSERT(it!=NULL);\n  iupASSERT(key!=NULL);\n  if (!it || !key || !value)\n    return;\n\n  itemFound = iTableFindItem(it, key, &entry, &itemIndex, &keyIndex);\n\n#ifdef DEBUGTABLE\n  if (it->indexType == IUPTABLE_STRINGINDEXED)\n    iTableCheckDuplicated(&(entry->items[0]), entry->nextItemIndex, key, keyIndex);\n#endif\n\n  if (!itemFound)\n  {\n    /* create a new item */\n\n    /* first check if the hash table has to be reorganized */\n    if (iTableResize(it))\n    {\n      /* We have to search for the entry again, since it may\n       * have been moved by iTableResize. */\n      iTableFindItem(it, key, &entry, &itemIndex, &keyIndex);\n    }\n\n    iTableUpdateArraySize(entry);\n\n    /* add the item at the end of the item array */\n    if (itemType == IUPTABLE_STRING)\n      v = iupStrDup(value);\n    else\n      v = value;\n\n    item = &(entry->items[entry->nextItemIndex]);\n\n    item->itemType     = itemType;\n    item->key.keyIndex = keyIndex;\n    item->key.keyStr   = it->indexType == IUPTABLE_STRINGINDEXED? iupStrDup(key) : key;\n    item->value        = v;\n\n    entry->nextItemIndex++;\n    it->numberOfEntries++;\n  }\n  else\n  {\n    /* change an existing item */\n    void *v;\n    item = &(entry->items[itemIndex]);\n\n    if (itemType == IUPTABLE_STRING && item->itemType == IUPTABLE_STRING)\n    {\n      /* this will avoid to free + alloc of a new pointer */\n      if (iupStrEqual((char*)item->value, (char*)value))\n        return;\n    }\n\n    if (itemType == IUPTABLE_STRING)\n      v = iupStrDup(value);\n    else\n      v = value;\n\n    if (item->itemType == IUPTABLE_STRING)\n      free(item->value);\n\n    item->value    = v;\n    item->itemType = itemType;\n  }\n}\n\nstatic void iTableRemoveItem(Itable *it, ItableEntry *entry, unsigned int itemIndex)\n{\n  ItableItem   *item;\n  unsigned int  i;\n\n  item = &(entry->items[itemIndex]);\n\n  if (it->indexType == IUPTABLE_STRINGINDEXED)\n  {\n    free((void *)item->key.keyStr);\n    item->key.keyStr = NULL;\n  }\n\n  if (item->itemType == IUPTABLE_STRING)\n  {\n    free(item->value);\n    item->value = NULL;\n  }\n\n  /* re-order the remaining items */\n  for (i = itemIndex; i < entry->nextItemIndex-1; i++)\n    entry->items[i] = entry->items[i+1];\n\n  /* clear the released item */\n  memset(entry->items + entry->nextItemIndex-1, 0, sizeof (ItableItem));\n\n  entry->nextItemIndex--;\n  it->numberOfEntries--;\n}\n\nvoid iupTableRemove(Itable *it, const char *key)\n{\n  unsigned int itemFound,\n               itemIndex;\n  unsigned long keyIndex;\n  ItableEntry  *entry;\n\n  iupASSERT(it!=NULL);\n  iupASSERT(key!=NULL);\n  if (!it || !key)\n    return;\n\n  itemFound = iTableFindItem(it, key, &entry, &itemIndex, &keyIndex);\n  if (itemFound)\n    iTableRemoveItem(it, entry, itemIndex);\n}\n\nvoid *iupTableGet(Itable *it, const char *key)\n{\n  unsigned int  itemFound,\n                itemIndex;\n  unsigned long keyIndex;\n  ItableEntry  *entry;\n  void         *value = 0;\n\n  iupASSERT(it!=NULL);\n  iupASSERT(key!=NULL);\n  if (!it || !key)\n    return 0;\n\n  itemFound = iTableFindItem(it, key, &entry, &itemIndex, &keyIndex);\n  if (itemFound)\n    value = entry->items[itemIndex].value;\n\n  return value;\n}\n\nIfunc iupTableGetFunc(Itable *it, const char *key, void **value)\n{\n  Itable_Types itemType = IUPTABLE_POINTER;\n  *value = iupTableGetTyped(it, key, &itemType);\n  if (itemType == IUPTABLE_FUNCPOINTER)\n    return (Ifunc)(*value); /* type cast from void* to function pointer */\n  else\n    return (Ifunc)0;\n}\n\nvoid *iupTableGetTyped(Itable *it, const char *key, Itable_Types *itemType)\n{\n  unsigned int  itemFound,\n                itemIndex;\n  unsigned long keyIndex;\n  ItableEntry  *entry;\n  void         *value = 0;\n\n  iupASSERT(it!=NULL);\n  iupASSERT(key!=NULL);\n  if (!it || !key)\n    return 0;\n\n  itemFound = iTableFindItem(it, key, &entry, &itemIndex, &keyIndex);\n  if (itemFound)\n  {\n    value = entry->items[itemIndex].value;\n    if (itemType) \n      *itemType = entry->items[itemIndex].itemType;\n  }\n\n  return value;\n}\n\nvoid iupTableSetCurr(Itable *it, void* value, Itable_Types itemType)\n{\n  void* v;\n  ItableItem *item;\n\n  iupASSERT(it!=NULL);\n  if (!it || it->context.entryIndex == (unsigned int)-1\n         || it->context.itemIndex == (unsigned int)-1)\n    return;\n\n  item = &(it->entries[it->context.entryIndex].items[it->context.itemIndex]);\n\n  if (itemType == IUPTABLE_STRING && item->itemType == IUPTABLE_STRING)\n  {\n    /* this will avoid to free + alloc of a new pointer */\n    if (iupStrEqual((char*)item->value, (char*)value))\n      return;\n  }\n\n  if (itemType == IUPTABLE_STRING)\n    v = iupStrDup(value);\n  else\n    v = value;\n\n  if (item->itemType == IUPTABLE_STRING)\n    free(item->value);\n\n  item->value    = v;\n  item->itemType = itemType;\n\n}\n\nvoid* iupTableGetCurr(Itable *it)\n{\n  iupASSERT(it!=NULL);\n  if (!it || it->context.entryIndex == (unsigned int)-1\n         || it->context.itemIndex == (unsigned int)-1)\n    return 0;\n\n  return it->entries[it->context.entryIndex].items[it->context.itemIndex].value;\n}\n\nint iupTableGetCurrType(Itable *it)\n{\n  iupASSERT(it!=NULL);\n  if (!it || it->context.entryIndex == (unsigned int)-1\n         || it->context.itemIndex == (unsigned int)-1)\n    return -1;\n\n  return it->entries[it->context.entryIndex].items[it->context.itemIndex].itemType;\n}\n\nchar *iupTableFirst(Itable *it)\n{\n  unsigned int entryIndex;\n\n  iupASSERT(it!=NULL);\n  if (!it)\n    return 0;\n\n  it->context.entryIndex = (unsigned int)-1;\n  it->context.itemIndex = (unsigned int)-1;\n\n  /* find the first used entry */\n  for (entryIndex = 0; entryIndex < it->entriesSize; entryIndex++)\n  {\n    if (it->entries[entryIndex].nextItemIndex > 0)\n    {\n      it->context.entryIndex = entryIndex;\n      it->context.itemIndex = 0;\n      return (char*)it->entries[entryIndex].items[0].key.keyStr;\n    }\n  }\n\n  return 0;\n}\n\n\nchar *iupTableNext(Itable *it)\n{\n  unsigned int entryIndex;\n\n  iupASSERT(it!=NULL);\n  if (!it || it->context.entryIndex == (unsigned int)-1\n         || it->context.itemIndex == (unsigned int)-1)\n    return 0;\n\n  if (it->context.itemIndex + 1 < it->entries[it->context.entryIndex].nextItemIndex)\n  {\n    /* key in the current entry */\n    it->context.itemIndex++;\n    return (char*)it->entries[it->context.entryIndex].items[it->context.itemIndex].key.keyStr;\n  }\n  else\n  {\n    /* find the next used entry */\n    for (entryIndex = it->context.entryIndex+1; entryIndex < it->entriesSize; entryIndex++)\n    {\n      if (it->entries[entryIndex].nextItemIndex > 0)\n      {\n        it->context.entryIndex = entryIndex;\n        it->context.itemIndex = 0;\n        return (char*)it->entries[entryIndex].items[0].key.keyStr;\n      }\n    }\n  }\n\n  return 0;\n}\n\nchar *iupTableRemoveCurr(Itable *it)\n{\n  char* key;\n  unsigned int entryIndex;\n  ItableEntry  *entry;\n  unsigned int itemIndex;\n\n  iupASSERT(it!=NULL);\n  if (!it || it->context.entryIndex == (unsigned int)-1\n         || it->context.itemIndex == (unsigned int)-1)\n    return 0;\n\n  entry = &it->entries[it->context.entryIndex];\n  itemIndex = it->context.itemIndex;\n\n  if (it->context.itemIndex + 1 < it->entries[it->context.entryIndex].nextItemIndex)\n  {\n    /* key in the current entry */\n    it->context.itemIndex++;\n    key = (char*)it->entries[it->context.entryIndex].items[it->context.itemIndex].key.keyStr;\n\n    iTableRemoveItem(it, entry, itemIndex);\n    return key;\n  }\n  else\n  {\n    /* find the next used entry */\n    for (entryIndex = it->context.entryIndex+1; entryIndex < it->entriesSize; entryIndex++)\n    {\n      if (it->entries[entryIndex].nextItemIndex > 0)\n      {\n        it->context.entryIndex = entryIndex;\n        it->context.itemIndex = 0;\n        key = (char*)it->entries[entryIndex].items[0].key.keyStr;\n\n        iTableRemoveItem(it, entry, itemIndex);\n        return key;\n       }\n    }\n  }\n\n  return 0;\n}\n\n\n/********************************************/\n/*           Private functions              */\n/********************************************/\n\n\nstatic void iTableFreeItemArray(Itable_IndexTypes indexType, unsigned int nextFreeIndex, ItableItem *items)\n{\n  unsigned int i;\n\n  /* Used only in iupTableClear */\n\n  iupASSERT(items!=NULL);\n  if (!items)\n    return;\n\n  if (indexType == IUPTABLE_STRINGINDEXED)\n  {\n    for (i = 0; i < nextFreeIndex; i++)\n    {\n      free((void *)(items[i].key.keyStr));\n      items[i].key.keyStr = NULL;\n    }\n  }\n\n  for (i = 0; i < nextFreeIndex; i++)\n  {\n    if (items[i].itemType == IUPTABLE_STRING)\n    {\n      free(items[i].value);\n      items[i].value = NULL;\n    }\n  }\n\n  free(items);\n}\n\n\nstatic unsigned int iTableGetEntryIndex(Itable *it, const char *key, unsigned long *keyIndex)\n{\n  if (it->indexType == IUPTABLE_STRINGINDEXED)\n  {\n    register unsigned int checksum = 0;\n\n/*     Orignal version\n    unsigned int i;\n    for (i = 0; key[i]; i++)\n      checksum = checksum*31 + key[i];  \n*/\n\n    while (*key)\n    {\n      checksum *= 31;\n      checksum += *key;\n      key++;\n    }\n\n    *keyIndex = checksum;            /* this could NOT be dependent from table size */\n  }\n  else\n  {\n    /* Pointer indexed */\n    *keyIndex = (unsigned long)key;   /* this could NOT be dependent from table size */\n  }\n\n  return (unsigned int)((*keyIndex) % it->entriesSize);\n}\n\n#ifdef DEBUGTABLE\nstatic void iTableCheckDuplicated(ItableItem *item, unsigned int nextItemIndex, const char *key, \n                                                                          unsigned long keyIndex)\n{\n  unsigned int i;\n  for (i = 0; i < nextItemIndex; i++, item++)\n  {\n    if (!iupStrEqual((char*)item->key.keyStr, (char*)key) && \n        item->key.keyIndex == keyIndex)\n    {\n      fprintf(stderr, \"#ERROR# Duplicated key index (%ld): %s %s \\n\", keyIndex, \n                                                                     (char*)item->key.keyStr, \n                                                                     (char*)key);\n    }\n  }\n}\n#endif\n\nstatic unsigned int iTableFindItem(Itable *it, const char *key, ItableEntry **entry, \n                                                          unsigned int *itemIndex,\n                                                          unsigned long *keyIndex)\n{\n  unsigned int entryIndex,\n               itemFound,\n               i;\n  ItableItem  *item;\n\n  entryIndex = iTableGetEntryIndex(it, key, keyIndex);\n\n  *entry = &(it->entries[entryIndex]);\n\n  item = &((*entry)->items[0]);\n  for (i = 0; i < (*entry)->nextItemIndex; i++, item++)\n  {\n    if (it->indexType == IUPTABLE_STRINGINDEXED)\n      itemFound = item->key.keyIndex == *keyIndex; \n/*    itemFound = iupStrEqual(item->key.keyStr, key);  This is the original safe version */\n    else\n      itemFound = item->key.keyStr == key;\n\n    if (itemFound)\n    {\n      *itemIndex = i;\n      return 1;\n    }\n  }\n\n  /* if not found \"entry\", \"itemIndex\" and \"keyIndex\" will have the new insert position. */\n\n  *itemIndex = i;\n  return 0;\n}\n\nstatic void iTableUpdateArraySize(ItableEntry *entry)\n{\n  if (entry->nextItemIndex >= entry->itemsSize)\n  {\n    /* we have to expand the item array */\n    unsigned int newSize;\n\n    newSize = entry->itemsSize + itable_itemGrow;\n\n    entry->items = (ItableItem *)realloc(entry->items, newSize * sizeof(ItableItem));\n    iupASSERT(entry->items!=NULL);\n    if (!entry->items)\n      return;\n\n    memset(entry->items + entry->itemsSize, 0, itable_itemGrow * sizeof(ItableItem));\n\n    entry->itemsSize = newSize;\n  }\n}\n\nstatic void iTableAdd(Itable *it, ItableKey *key, void *value, Itable_Types itemType)\n{\n  unsigned int entryIndex;\n  unsigned long keyIndex;\n  ItableEntry *entry;\n  ItableItem* item;\n\n  entryIndex = iTableGetEntryIndex(it, key->keyStr, &keyIndex);\n\n  entry = &(it->entries[entryIndex]);\n  iTableUpdateArraySize(entry);\n\n  /* add a new item at the end of the item array without duplicating memory. */\n  item = &(entry->items[entry->nextItemIndex]);\n  item->itemType     = itemType;\n  item->key.keyIndex = keyIndex;\n  item->key.keyStr   = key->keyStr;\n  item->value        = value;\n\n  entry->nextItemIndex++;\n  it->numberOfEntries++;\n}\n\nstatic unsigned int iTableResize(Itable *it)\n{\n  unsigned int   newSizeIndex,\n                 entryIndex,\n                 i;\n  Itable        *newTable;\n  ItableEntry   *entry;\n  ItableItem    *item;\n\n  /* check if we do not need to resize the hash table */\n  if (it->numberOfEntries == 0 ||\n     it->tableSizeIndex >= itable_maxTableSizeIndex ||\n     it->entriesSize / it->numberOfEntries >= itable_resizeLimit)\n    return 0;\n\n  /* create a new hash table and copy the contents of\n   * the current table into the new one\n   */\n  newSizeIndex = it->tableSizeIndex + 1;\n  newTable = iupTableCreateSized(it->indexType, newSizeIndex);\n\n  for (entryIndex = 0; entryIndex < it->entriesSize; entryIndex++)\n  {\n    entry = &(it->entries[entryIndex]);\n\n    if (entry->items)\n    {\n      item = &(entry->items[0]);\n\n      for (i = 0; i < entry->nextItemIndex; i++, item++)\n      {\n        iTableAdd(newTable, &(item->key), item->value, item->itemType);\n      }     \n\n      free(entry->items);\n      entry->items = NULL;\n    }\n  }\n\n  free(it->entries);\n\n  it->entriesSize    = newTable->entriesSize;\n  it->tableSizeIndex  = newTable->tableSizeIndex;\n  it->numberOfEntries = newTable->numberOfEntries;\n  it->entries         = newTable->entries;\n\n  free(newTable);\n\n  return 1;\n}\n\n#ifdef DEBUGTABLE\nstatic void iTableShowStatistics(Itable *it)\n{\n  unsigned int nofSlots        = 0;\n  unsigned int nofKeys         = 0;\n  double optimalNofKeysPerSlot = 0.0;\n  unsigned int nofSlotsWithMoreKeys = 0;\n  unsigned int nofSlotsWithLessKeys = 0;\n\n  unsigned int entryIndex;\n  fprintf(stderr, \"\\n--- HASH TABLE STATISTICS ---\\n\");\n  if (!it)\n  {\n    fprintf(stderr, \"no hash table...\\n\");\n    return;\n  }\n\n  nofSlots = it->entriesSize;\n  nofKeys  = it->numberOfEntries;\n  optimalNofKeysPerSlot = (double)nofKeys / (double)nofSlots;\n\n  for (entryIndex = 0; entryIndex < it->entriesSize; entryIndex++)\n  {\n    ItableEntry *entry = &(it->entries[entryIndex]);\n\n    if (entry->nextItemIndex > optimalNofKeysPerSlot + 3)\n      nofSlotsWithMoreKeys++;\n    else if (entry->nextItemIndex < optimalNofKeysPerSlot - 3)\n      nofSlotsWithLessKeys++;\n  }\n\n  fprintf(stderr, \"Number of slots: %d\\n\", nofSlots);\n  fprintf(stderr, \"Number of keys: %d\\n\", nofKeys);\n  fprintf(stderr, \"Optimal number of keys per slot: %f\\n\", optimalNofKeysPerSlot);\n  fprintf(stderr, \"Number of slots with much more keys: %d\\n\", nofSlotsWithMoreKeys);\n  fprintf(stderr, \"Number of slots with far less keys: %d\\n\", nofSlotsWithLessKeys);\n  fprintf(stderr, \"\\n\");\n}\n#endif\n","/** \\file\n* \\brief iuptabs control\n*\n* See Copyright Notice in \"iup.h\"\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_image.h\"\n#include \"iup_tabs.h\"\n\n\n\nchar* iupTabsGetPaddingAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n}\n\nstatic int iTabsGetMaxWidth(Ihandle* ih)\n{\n  int max_width = 0, width, pos;\n  char *tabtitle, *tabimage;\n  Ihandle* child;\n\n  for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)\n  {\n    tabtitle = iupAttribGetId(ih, \"TABTITLE\", pos);\n    if (!tabtitle) tabtitle = iupAttribGet(child, \"TABTITLE\");\n    tabimage = iupAttribGetId(ih, \"TABIMAGE\", pos);\n    if (!tabimage) tabimage = iupAttribGet(child, \"TABIMAGE\");\n    if (!tabtitle && !tabimage)\n      tabtitle = \"     \";\n\n    width = 0;\n    if (tabtitle)\n      width += iupdrvFontGetStringWidth(ih, tabtitle);\n\n    if (tabimage)\n    {\n      void* img = iupImageGetImage(tabimage, ih, 0);\n      if (img)\n      {\n        int w;\n        iupdrvImageGetInfo(img, &w, NULL, NULL);\n        width += w;\n      }\n    }\n\n    if (width > max_width) max_width = width;\n  }\n\n  return max_width;\n}\n\nstatic int iTabsGetMaxHeight(Ihandle* ih)\n{\n  int max_height = 0, h, pos;\n  char *tabimage;\n  Ihandle* child;\n\n  for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)\n  {\n    tabimage = iupAttribGetId(ih, \"TABIMAGE\", pos);\n    if (!tabimage) tabimage = iupAttribGet(child, \"TABIMAGE\");\n\n    if (tabimage)\n    {\n      void* img = iupImageGetImage(tabimage, ih, 0);\n      if (img)\n      {\n        iupdrvImageGetInfo(img, NULL, &h, NULL);\n        if (h > max_height) max_height = h;\n      }\n    }\n  }\n\n  iupdrvFontGetCharSize(ih, NULL, &h);\n  if (h > max_height) max_height = h;\n\n  return max_height;\n}\n\nstatic void iTabsGetDecorSize(Ihandle* ih, int *width, int *height)\n{\n  if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)\n  {\n    if (ih->data->orientation == ITABS_HORIZONTAL)\n    {\n      int max_width = iTabsGetMaxWidth(ih);\n      *width  = 4 + (3 + max_width + 3) + 2 + 4;\n      *height = 4 + 4;\n\n      if (iupdrvTabsExtraDecor(ih))\n      {\n        int h;\n        iupdrvFontGetCharSize(ih, NULL, &h);\n        *height += h + 4;\n      }\n    }\n    else\n    {\n      int max_height = iTabsGetMaxHeight(ih);\n      *width  = 4 + (3 + max_height + 3) + 2 + 4;\n      *height = 4 + 4;\n\n      if (ih->handle && ih->data->is_multiline)\n      {\n        int num_lin = iupdrvTabsGetLineCountAttrib(ih);\n        *width += (num_lin-1)*(3 + max_height + 3 + 1);\n      }\n    }\n  }\n  else /* \"BOTTOM\" or \"TOP\" */\n  {\n    if (ih->data->orientation == ITABS_HORIZONTAL)\n    {\n      int max_height = iTabsGetMaxHeight(ih);\n      *width  = 4 + 4;\n      *height = 4 + (3 + max_height + 3) + 2 + 4;\n\n      if (ih->handle && ih->data->is_multiline)\n      {\n        int num_lin = iupdrvTabsGetLineCountAttrib(ih);\n        *height += (num_lin-1)*(3 + max_height + 3 + 1);\n      }\n\n      if (iupdrvTabsExtraDecor(ih))\n      {\n        int h;\n        iupdrvFontGetCharSize(ih, NULL, &h);\n        *width += h + 4;\n      }\n    }\n    else\n    {\n      int max_width = iTabsGetMaxWidth(ih);\n      *width  = 4 + 4;\n      *height = 4 + (3 + max_width + 3) + 2 + 4;\n    }\n  }\n\n  *width  += ih->data->horiz_padding;\n  *height += ih->data->vert_padding;\n}\n\nstatic void iTabsGetDecorOffset(Ihandle* ih, int *dx, int *dy)\n{\n  if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)\n  {\n    if (ih->data->type == ITABS_LEFT)\n    {\n      if (ih->data->orientation == ITABS_HORIZONTAL)\n      {\n        int max_width = iTabsGetMaxWidth(ih);\n        *dx = 4 + (3 + max_width + 3) + 2;\n      }\n      else\n      {\n        int max_height = iTabsGetMaxHeight(ih);\n        *dx = 4 + (3 + max_height + 3) + 2;\n\n        if (ih->handle && ih->data->is_multiline)\n        {\n          int num_lin = iupdrvTabsGetLineCountAttrib(ih);\n          *dx += (num_lin-1)*(3 + max_height + 3 + 1);\n        }\n      }\n    }\n    else\n      *dx = 4;\n\n    *dy = 4;\n  }\n  else /* \"BOTTOM\" or \"TOP\" */\n  {\n    if (ih->data->type == ITABS_TOP)\n    {\n      if (ih->data->orientation == ITABS_HORIZONTAL)\n      {\n        int max_height = iTabsGetMaxHeight(ih);\n        *dy = 4 + (3 + max_height + 3) + 2;\n\n        if (ih->handle && ih->data->is_multiline)\n        {\n          int num_lin = iupdrvTabsGetLineCountAttrib(ih);\n          *dy += (num_lin-1)*(3 + max_height + 3 + 1);\n        }\n      }\n      else\n      {\n        int max_width = iTabsGetMaxWidth(ih);\n        *dy = 4 + (3 + max_width + 3) + 2;\n      }\n    }\n    else\n      *dy = 4;\n\n    *dx = 4;\n  }\n\n  *dx += ih->data->horiz_padding;\n  *dy += ih->data->vert_padding;\n}\n\nvoid iupTabsCheckCurrentTab(Ihandle* ih, int pos, int removed)\n{\n  int cur_pos = iupdrvTabsGetCurrentTab(ih);\n  if (cur_pos == pos)\n  {\n    int p;\n\n    /* if given tab is the current tab, \n       then the current tab must be changed to a visible tab */\n    Ihandle* child;\n\n    /* this function is called after the child has being removed from the hierarchy,\n       but before the system tab being removed. */\n\n    p = 0;\n    if (removed && p == pos)\n      p++;\n\n    for (child = ih->firstchild; child; child = child->brother)\n    {\n      if (p != pos && iupdrvTabsIsTabVisible(child, p))\n      {\n        iupdrvTabsSetCurrentTab(ih, p);\n        return;\n      }\n\n      p++;\n      if (removed && p == pos)\n        p++;  /* increment twice to compensate for child already removed */\n    }\n  }\n}\n\nstatic void iTabsSetTab(Ihandle* ih, Ihandle* child, int pos)\n{\n  if (ih->handle)\n  {\n    int cur_pos = iupdrvTabsGetCurrentTab(ih);\n    if (cur_pos != pos && iupdrvTabsIsTabVisible(child, pos))\n      iupdrvTabsSetCurrentTab(ih, pos);\n  }\n  else\n    iupAttribSet(ih, \"_IUPTABS_VALUE_HANDLE\", (char*)child);\n}\n\n\n/* ------------------------------------------------------------------------- */\n/* TABS - Sets and Gets - Attribs                                           */\n/* ------------------------------------------------------------------------- */\n\nstatic int iTabsSetValueHandleAttrib(Ihandle* ih, const char* value)\n{\n  int pos;\n  Ihandle *child;\n\n  child = (Ihandle*)value;\n\n  if (!iupObjectCheck(child))\n    return 0;\n\n  pos = IupGetChildPos(ih, child);\n  if (pos != -1) /* found child */\n    iTabsSetTab(ih, child, pos);\n \n  return 0;\n}\n\nchar* iupTabsGetTabTypeAttrib(Ihandle* ih)\n{\n  switch(ih->data->type)\n  {\n  case ITABS_BOTTOM:\n    return \"BOTTOM\";\n  case ITABS_LEFT:\n    return \"LEFT\";\n  case ITABS_RIGHT:\n    return \"RIGHT\";\n  default:\n    return \"TOP\";\n  }\n}\n\nchar* iupTabsGetTabOrientationAttrib(Ihandle* ih)\n{\n  if (ih->data->orientation == ITABS_HORIZONTAL)\n    return \"HORIZONTAL\";\n  else\n    return \"VERTICAL\";\n}\n\nstatic char* iTabsGetValueHandleAttrib(Ihandle* ih)\n{\n  if (ih->handle)\n  {\n    int pos = iupdrvTabsGetCurrentTab(ih);\n    return (char*)IupGetChild(ih, pos);\n  }\n  else\n    return iupAttribGet(ih, \"_IUPTABS_VALUE_HANDLE\");\n}\n\nstatic char* iTabsGetCountAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(IupGetChildCount(ih));\n}\n\nstatic int iTabsSetValuePosAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* child;\n  int pos;\n\n  if (!iupStrToInt(value, &pos))\n    return 0;\n\n  child = IupGetChild(ih, pos);\n  if (child) /* found child */\n    iTabsSetTab(ih, child, pos);\n \n  return 0;\n}\n\nstatic char* iTabsGetValuePosAttrib(Ihandle* ih)\n{\n  if (ih->handle)\n  {\n    int pos = iupdrvTabsGetCurrentTab(ih);\n    return iupStrReturnInt(pos);\n  }\n  else\n  {\n    Ihandle* child = (Ihandle*)iupAttribGet(ih, \"_IUPTABS_VALUE_HANDLE\");\n    int pos = IupGetChildPos(ih, child);\n    if (pos != -1) /* found child */\n      return iupStrReturnInt(pos);\n  }\n\n  return NULL;\n}\n\nstatic int iTabsSetValueAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle *child;\n\n  if (!value)\n    return 0;\n\n  child = IupGetHandle(value);\n  if (!child)\n    return 0;\n\n  iTabsSetValueHandleAttrib(ih, (char*)child);\n\n  return 0;\n}\n\nstatic char* iTabsGetValueAttrib(Ihandle* ih)\n{\n  Ihandle* child = (Ihandle*)iTabsGetValueHandleAttrib(ih);\n  return IupGetName(child);\n}\n\nstatic char* iTabsGetClientSizeAttrib(Ihandle* ih)\n{\n  int width, height, decorwidth, decorheight;\n  width = ih->currentwidth;\n  height = ih->currentheight;\n  iTabsGetDecorSize(ih, &decorwidth, &decorheight);\n  width -= decorwidth;\n  height -= decorheight;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n  return iupStrReturnIntInt(width, height,'x');\n}\n\nstatic char* iTabsGetClientOffsetAttrib(Ihandle* ih)\n{\n  int dx, dy;\n  iTabsGetDecorOffset(ih, &dx, &dy);\n  return iupStrReturnIntInt(dx, dy, 'x');\n}\n\nchar* iupTabsGetTabVisibleAttrib(Ihandle* ih, int pos)\n{\n  Ihandle* child = IupGetChild(ih, pos);\n  if (child)\n    return iupStrReturnBoolean(iupdrvTabsIsTabVisible(child, pos));\n  else\n    return NULL;\n}\n\nchar* iupTabsGetTitleAttrib(Ihandle* ih, int pos)\n{\n  Ihandle* child = IupGetChild(ih, pos);\n  if (child)\n    return iupAttribGet(child, \"TABTITLE\");\n  else\n    return NULL;\n}\n\nstatic char* iTabsGetShowCloseAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->show_close); \n}\n\nstatic int iTabsSetShowCloseAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->show_close = 1;\n  else\n    ih->data->show_close = 0;\n\n  return 0;\n}\n/* ------------------------------------------------------------------------- */\n/* TABS - Methods                                                            */\n/* ------------------------------------------------------------------------- */\n\nstatic void iTabsComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int children_naturalwidth, children_naturalheight;\n  int decorwidth, decorheight;\n\n  /* calculate total children natural size (even for hidden children) */\n  children_naturalwidth = 0;\n  children_naturalheight = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    /* update child natural size first */\n    iupBaseComputeNaturalSize(child);\n\n    *children_expand |= child->expand;\n    children_naturalwidth = iupMAX(children_naturalwidth, child->naturalwidth);\n    children_naturalheight = iupMAX(children_naturalheight, child->naturalheight);\n  }\n\n  iTabsGetDecorSize(ih, &decorwidth, &decorheight);\n\n  *w = children_naturalwidth + decorwidth;\n  *h = children_naturalheight + decorheight;\n}\n\nstatic void iTabsSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child;\n  int width, height, decorwidth, decorheight;\n\n  iTabsGetDecorSize(ih, &decorwidth, &decorheight);\n\n  width = ih->currentwidth-decorwidth;\n  height = ih->currentheight-decorheight;\n  if (width < 0) width = 0;\n  if (height < 0) height = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    iupBaseSetCurrentSize(child, width, height, shrink);\n  }\n}\n\nstatic void iTabsSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  /* In all systems, each tab is a native window covering the client area.\n     Child coordinates are relative to client left-top corner of the tab page. */\n  Ihandle* child;\n  char* offset = iupAttribGet(ih, \"CHILDOFFSET\");\n\n  /* Native container, position is reset */\n  x = 0;\n  y = 0;\n\n  if (offset) iupStrToIntInt(offset, &x, &y, 'x');\n\n  for (child = ih->firstchild; child; child = child->brother)\n    iupBaseSetPosition(child, x, y);\n}\n\nstatic void* iTabsGetInnerNativeContainerHandleMethod(Ihandle* ih, Ihandle* child)\n{\n  while (child && child->parent != ih)\n    child = child->parent;\n  if (child)\n    return iupAttribGet(child, \"_IUPTAB_CONTAINER\");\n  else\n    return NULL;\n}\n\nstatic int iTabsCreateMethod(Ihandle* ih, void **params)\n{\n  ih->data = iupALLOCCTRLDATA();\n\n  /* add children */\n  if(params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams) \n    {\n      IupAppend(ih, *iparams);\n      iparams++;\n    }\n  }\n  return IUP_NOERROR;\n}\n\nIclass* iupTabsNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"tabs\";\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype  = IUP_CHILDMANY;\n  ic->is_interactive = 1;\n  ic->has_attrib_id = 1;\n\n  /* Class functions */\n  ic->New = iupTabsNewClass;\n  ic->Create  = iTabsCreateMethod;\n  ic->GetInnerNativeContainerHandle = iTabsGetInnerNativeContainerHandleMethod;\n\n  ic->ComputeNaturalSize = iTabsComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize     = iTabsSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition        = iTabsSetChildrenPositionMethod;\n\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* IupTabs Callbacks */\n  iupClassRegisterCallback(ic, \"TABCHANGE_CB\", \"nn\");\n  iupClassRegisterCallback(ic, \"TABCHANGEPOS_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"RIGHTCLICK_CB\", \"i\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* IupTabs only */\n  iupClassRegisterAttribute(ic, \"VALUE\", iTabsGetValueAttrib, iTabsSetValueAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUEPOS\", iTabsGetValuePosAttrib, iTabsSetValuePosAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE_HANDLE\", iTabsGetValueHandleAttrib, iTabsSetValueHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT | IUPAF_IHANDLE | IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"COUNT\", iTabsGetCountAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWCLOSE\", iTabsGetShowCloseAttrib, iTabsSetShowCloseAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iTabsGetClientSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iTabsGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Native Container */\n  iupClassRegisterAttribute(ic, \"CHILDOFFSET\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupdrvTabsInitClass(ic);\n\n  return ic;\n}\n\nIhandle* IupTabs(Ihandle* first,...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, first);\n  children = (Ihandle**)iupObjectGetParamList(first, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"tabs\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIhandle* IupTabsv(Ihandle** params)\n{\n  return IupCreatev(\"tabs\", (void**)params);\n}\n","/** \\file\n * \\brief Text Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_register.h\"\n#include \"iup_layout.h\"\n#include \"iup_mask.h\"\n#include \"iup_array.h\"\n#include \"iup_text.h\"\n#include \"iup_assert.h\"\n\n\n/* Used by List and Text, implemented in Text\n   Can NOT use ih->data \n*/\nint iupEditCallActionCb(Ihandle* ih, IFnis cb, const char* insert_value, int start, int end, void *mask, int nc, int remove_dir, int utf8)\n{\n  char *new_value, *value;\n  int ret = -1, /* normal processing */\n      key = 0;\n\n  if (!cb && !mask)\n    return ret;\n\n  value = IupGetAttribute(ih, \"VALUE\");  /* it will return a non NULL internal buffer */\n\n  if (!insert_value)\n  {\n    new_value = value;\n    iupStrRemove(new_value, start, end, remove_dir, utf8);\n  }\n  else\n  {\n    if (value[0]==0)\n      new_value = iupStrDup(insert_value);\n    else\n      new_value = iupStrInsert(value, insert_value, start, end, utf8);\n  }\n\n  if (insert_value && insert_value[0]!=0 && insert_value[1]==0)\n    key = insert_value[0];\n\n  if (!new_value)\n    return ret;\n\n  if (nc && (int)strlen(new_value) > nc)\n  {\n    if (new_value != value) free(new_value);\n    return 0; /* abort */\n  }\n\n  if (mask && iupMaskCheck((Imask*)mask, new_value)==0)\n  {\n    IFns cb = (IFns)IupGetCallback(ih, \"MASKFAIL_CB\");\n    if (cb) cb(ih, new_value);\n    if (new_value != value) free(new_value);\n    return 0; /* abort */\n  }\n\n  if (cb)\n  {\n    int cb_ret = cb(ih, key, (char*)new_value);\n    if (cb_ret==IUP_IGNORE)\n      ret = 0; /* abort */\n    else if (cb_ret==IUP_CLOSE)\n    {\n      IupExitLoop();\n      ret = 0; /* abort */\n    }\n    else if (cb_ret!=0 && key!=0 && \n             cb_ret != IUP_DEFAULT && cb_ret != IUP_CONTINUE)  \n      ret = cb_ret; /* replace key */\n  }\n\n  if (new_value != value) free(new_value);\n  return ret;\n}\n\nchar* iupTextGetFormattingAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->has_formatting); \n}\n\nint iupTextSetFormattingAttrib(Ihandle* ih, const char* value)\n{\n  if (ih->handle)  /* only before map */\n    return 0;\n\n  ih->data->has_formatting = iupStrBoolean(value);\n\n  return 0;\n}\n\nstatic void iTextDestroyFormatTags(Ihandle* ih)\n{\n  /* called if the element was destroyed before it was mapped */\n  int i, count = iupArrayCount(ih->data->formattags);\n  Ihandle** tag_array = (Ihandle**)iupArrayGetData(ih->data->formattags);\n  for (i = 0; i < count; i++)\n    IupDestroy(tag_array[i]);\n  iupArrayDestroy(ih->data->formattags);\n  ih->data->formattags = NULL;\n}\n\nstatic void iTextUpdateValueAttrib(Ihandle* ih)\n{\n  char* value = iupAttribGet(ih, \"VALUE\");\n  if (value)\n  {\n    iupAttribSetClassObject(ih, \"VALUE\", value);\n\n    iupAttribSet(ih, \"VALUE\", NULL); /* clear hash table */\n  }\n}\n\nchar* iupTextGetNCAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->nc);\n}\n\nstatic void iTextAddFormatTag(Ihandle* ih, Ihandle* formattag)\n{\n  char* bulk = iupAttribGet(formattag, \"BULK\");\n  if (bulk && iupStrBoolean(bulk))\n  {\n    Ihandle* child;\n    void* state = iupdrvTextAddFormatTagStartBulk(ih);\n\n    char* cleanout = iupAttribGet(formattag, \"CLEANOUT\");\n    if (cleanout && iupStrBoolean(cleanout))\n      IupSetAttribute(ih, \"REMOVEFORMATTING\", \"ALL\");\n\n    for (child = formattag->firstchild; child; child = child->brother)\n      iupdrvTextAddFormatTag(ih, child, 1);\n\n    iupdrvTextAddFormatTagStopBulk(ih, state);\n  }\n  else\n    iupdrvTextAddFormatTag(ih, formattag, 0);\n\n  IupDestroy(formattag);\n}\n\nvoid iupTextUpdateFormatTags(Ihandle* ih)\n{\n  /* called when the element is mapped */\n  int i, count = iupArrayCount(ih->data->formattags);\n  Ihandle** tag_array = (Ihandle**)iupArrayGetData(ih->data->formattags);\n\n  /* must update VALUE before updating the format */\n  iTextUpdateValueAttrib(ih);\n\n  for (i = 0; i < count; i++)\n    iTextAddFormatTag(ih, tag_array[i]);\n\n  iupArrayDestroy(ih->data->formattags);\n  ih->data->formattags = NULL;\n}\n\nint iupTextSetAddFormatTagHandleAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* formattag = (Ihandle*)value;\n  if (!iupObjectCheck(formattag))\n    return 0;\n\n  if (ih->handle)\n  {\n    /* must update VALUE before updating the format */\n    iTextUpdateValueAttrib(ih);\n\n    iTextAddFormatTag(ih, formattag);\n  }\n  else\n  {\n    Ihandle** tag_array;\n    int i;\n\n    if (!ih->data->formattags)\n      ih->data->formattags = iupArrayCreate(10, sizeof(Ihandle*));\n\n    i = iupArrayCount(ih->data->formattags);\n    tag_array = (Ihandle**)iupArrayInc(ih->data->formattags);\n    tag_array[i] = formattag;\n  }\n  return 0;\n}\n\nint iupTextSetAddFormatTagAttrib(Ihandle* ih, const char* value)\n{\n  return iupTextSetAddFormatTagHandleAttrib(ih, (char*)IupGetHandle(value));\n}\n\nstatic char* iTextGetMaskDataAttrib(Ihandle* ih)\n{\n  /* Used only by the OLD iupmask API */\n  return (char*)ih->data->mask;\n}\n\nstatic char* iTextGetMaskAttrib(Ihandle* ih)\n{\n  if (ih->data->mask)\n    return iupMaskGetStr(ih->data->mask);\n  else\n    return NULL;\n}\n\nstatic int iTextSetValueMaskedAttrib(Ihandle* ih, const char* value)\n{\n  if (value)\n  {\n    if (ih->data->mask && iupMaskCheck(ih->data->mask, value)==0)\n      return 0; /* abort */\n    IupStoreAttribute(ih, \"VALUE\", value);\n  }\n  return 0;\n}\n\nstatic int iTextSetMaskAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    int casei = iupAttribGetInt(ih, \"MASKCASEI\");\n    Imask* mask = iupMaskCreate(value,casei);\n    if (mask)\n    {\n      if (ih->data->mask)\n        iupMaskDestroy(ih->data->mask);\n\n      ih->data->mask = mask;\n      return 0;\n    }\n  }\n\n  return 0;\n}\n\nstatic int iTextSetMaskIntAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    int min, max;\n\n    if (iupStrToIntInt(value, &min, &max, ':')!=2)\n      return 0;\n\n    mask = iupMaskCreateInt(min,max);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iTextSetMaskFloatAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    float min, max;\n    char* decimal_symbol = iupAttribGet(ih, \"MASKDECIMALSYMBOL\");\n\n    if (iupStrToFloatFloat(value, &min, &max, ':')!=2)\n      return 0;\n\n    mask = iupMaskCreateFloat(min, max, decimal_symbol);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iTextSetMaskRealAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    if (ih->data->mask)\n    {\n      iupMaskDestroy(ih->data->mask);\n      ih->data->mask = NULL;\n    }\n  }\n  else\n  {\n    Imask* mask;\n    char* decimal_symbol = iupAttribGet(ih, \"MASKDECIMALSYMBOL\");\n    int positive = 0;\n\n    if (iupStrEqualNoCase(value, \"UNSIGNED\"))\n      positive = 1;\n\n    mask = iupMaskCreateReal(positive, decimal_symbol);\n\n    if (ih->data->mask)\n      iupMaskDestroy(ih->data->mask);\n\n    ih->data->mask = mask;\n  }\n\n  return 0;\n}\n\nstatic int iTextSetMultilineAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n  {\n    ih->data->is_multiline = 1;\n    ih->data->sb = IUP_SB_HORIZ | IUP_SB_VERT;  /* reset SCROLLBAR to YES */\n    iupAttribSet(ih, \"_IUP_MULTILINE_TEXT\", \"1\");\n  }\n  else\n  {\n    ih->data->is_multiline = 0;\n    iupAttribSet(ih, \"_IUP_MULTILINE_TEXT\", NULL);\n  }\n\n  return 0;\n}\n\nstatic char* iTextGetMultilineAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->is_multiline); \n}\n\nstatic int iTextSetAppendNewlineAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->append_newline = 1;\n  else\n    ih->data->append_newline = 0;\n  return 0;\n}\n\nstatic char* iTextGetAppendNewlineAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->append_newline); \n}\n\nstatic int iTextSetScrollbarAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle || !ih->data->is_multiline)\n    return 0;\n\n  if (!value)\n    value = \"YES\";    /* default, if multiline, is YES */\n\n  if (iupStrEqualNoCase(value, \"YES\"))\n    ih->data->sb = IUP_SB_HORIZ | IUP_SB_VERT;\n  else if (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n    ih->data->sb = IUP_SB_HORIZ;\n  else if (iupStrEqualNoCase(value, \"VERTICAL\"))\n    ih->data->sb = IUP_SB_VERT;\n  else\n    ih->data->sb = IUP_SB_NONE;\n\n  return 0;\n}\n\nstatic char* iTextGetScrollbarAttrib(Ihandle* ih)\n{\n  if (!ih->data->is_multiline)\n    return NULL;\n  if (ih->data->sb == (IUP_SB_HORIZ | IUP_SB_VERT))\n    return \"YES\";\n  if (ih->data->sb & IUP_SB_HORIZ)\n    return \"HORIZONTAL\";\n  if (ih->data->sb & IUP_SB_VERT)\n    return \"VERTICAL\";\n  return \"NO\";   /* IUP_SB_NONE */\n}\n\nchar* iupTextGetPaddingAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n}\n\n\n/********************************************************************/\n\n\nstatic int iTextCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"ACTION\", (char*)(params[0]));\n  }\n  ih->data = iupALLOCCTRLDATA();\n  ih->data->append_newline = 1;\n  return IUP_NOERROR;\n}\n\nstatic int iMultilineCreateMethod(Ihandle* ih, void** params)\n{\n  (void)params;\n  ih->data->is_multiline = 1;\n  ih->data->sb = IUP_SB_HORIZ | IUP_SB_VERT;  /* default is YES */\n  iupAttribSet(ih, \"_IUP_MULTILINE_TEXT\", \"1\");\n  return IUP_NOERROR;\n}\n\nstatic void iTextComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0,\n      visiblecolumns = iupAttribGetInt(ih, \"VISIBLECOLUMNS\"),\n      visiblelines = iupAttribGetInt(ih, \"VISIBLELINES\");\n  (void)children_expand; /* unset if not a container */\n\n  /* Since the contents can be changed by the user, the size can not be dependent on it. */\n  iupdrvFontGetCharSize(ih, NULL, &natural_h);  /* one line height */\n  natural_w = iupdrvFontGetStringWidth(ih, \"WWWWWWWWWW\");\n  natural_w = (visiblecolumns*natural_w)/10;\n  if (ih->data->is_multiline)\n    natural_h = visiblelines*natural_h;\n\n  /* compute the borders space */\n  if (iupAttribGetBoolean(ih, \"BORDER\"))\n    iupdrvTextAddBorders(&natural_w, &natural_h);\n\n  if (iupAttribGetBoolean(ih, \"SPIN\"))\n    iupdrvTextAddSpin(&natural_w, natural_h);\n\n  natural_w += 2*ih->data->horiz_padding;\n  natural_h += 2*ih->data->vert_padding;\n\n  /* add scrollbar */\n  if (ih->data->is_multiline && ih->data->sb)\n  {\n    int sb_size = iupdrvGetScrollbarSize();\n    if (ih->data->sb & IUP_SB_HORIZ)\n      natural_h += sb_size;  /* sb horizontal affects vertical size */\n    if (ih->data->sb & IUP_SB_VERT)\n      natural_w += sb_size;  /* sb vertical affects horizontal size */\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\nstatic void iTextDestroyMethod(Ihandle* ih)\n{\n  if (ih->data->formattags)\n    iTextDestroyFormatTags(ih);\n  if (ih->data->mask)\n    iupMaskDestroy(ih->data->mask);\n}\n\n\n/******************************************************************************/\n\ntypedef void (*Iconvertlincol2pos)(Ihandle* ih, int lin, int col, int *pos);\ntypedef void (*Iconvertpos2lincol)(Ihandle* ih, int pos, int *lin, int *col);\n\nvoid IupTextConvertLinColToPos(Ihandle* ih, int lin, int col, int *pos)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (!ih->handle)\n    return;\n    \n  if (IupClassMatch(ih, \"text\"))\n  {\n    if (ih->data->is_multiline)\n      iupdrvTextConvertLinColToPos(ih, lin, col, pos);\n    else\n      *pos = col - 1; /* IUP starts at 1 */\n  }\n  else \n  {\n    Iconvertlincol2pos convert = (Iconvertlincol2pos)IupGetCallback(ih, \"_IUP_LINCOL2POS_CB\");\n    if (convert)\n      convert(ih, lin, col, pos);\n  }\n}\n\nvoid IupTextConvertPosToLinCol(Ihandle* ih, int pos, int *lin, int *col)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return;\n\n  if (!ih->handle)\n    return;\n    \n  if (IupClassMatch(ih, \"text\"))\n  {\n    if (ih->data->is_multiline)\n      iupdrvTextConvertPosToLinCol(ih, pos, lin, col);\n    else\n    {\n      *col = pos + 1; /* IUP starts at 1 */\n      *lin = 1;\n    }\n  }\n  else \n  {\n    Iconvertpos2lincol convert = (Iconvertpos2lincol)IupGetCallback(ih, \"_IUP_POS2LINCOL_CB\");\n    if (convert)\n      convert(ih, pos, lin, col);\n  }\n}\n\nIhandle* IupText(const char* action)\n{\n  void *params[2];\n  params[0] = (void*)action;\n  params[1] = NULL;\n  return IupCreatev(\"text\", params);\n}\n\nIhandle* IupMultiLine(const char* action)\n{\n  void *params[2];\n  params[0] = (void*)action;\n  params[1] = NULL;\n  return IupCreatev(\"multiline\", params);\n}\n\nIclass* iupTextNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"text\";\n  ic->format = \"a\"; /* one ACTION callback name */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupTextNewClass;\n  ic->Create = iTextCreateMethod;\n  ic->Destroy = iTextDestroyMethod;\n  ic->ComputeNaturalSize = iTextComputeNaturalSizeMethod;\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"CARET_CB\", \"iii\");\n  iupClassRegisterCallback(ic, \"ACTION\", \"is\");\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n  iupClassRegisterCallback(ic, \"MOTION_CB\", \"iis\");\n  iupClassRegisterCallback(ic, \"SPIN_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* IupText only */\n  iupClassRegisterAttribute(ic, \"SCROLLBAR\", iTextGetScrollbarAttrib, iTextSetScrollbarAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"AUTOHIDE\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MULTILINE\", iTextGetMultilineAttrib, iTextSetMultilineAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"APPENDNEWLINE\", iTextGetAppendNewlineAttrib, iTextSetAppendNewlineAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"VALUEMASKED\", NULL, iTextSetValueMaskedAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKCASEI\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKDECIMALSYMBOL\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASK\", iTextGetMaskAttrib, iTextSetMaskAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKINT\", NULL, iTextSetMaskIntAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKFLOAT\", NULL, iTextSetMaskFloatAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MASKREAL\", NULL, iTextSetMaskRealAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"OLD_MASK_DATA\", iTextGetMaskDataAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"BORDER\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPIN\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINALIGN\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"RIGHT\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINAUTO\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINWRAP\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VISIBLECOLUMNS\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"5\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VISIBLELINES\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"WORDWRAP\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n\n  iupdrvTextInitClass(ic);\n\n  return ic;\n}\n\nIclass* iupMultilineNewClass(void)\n{\n  Iclass* ic = iupClassNew(iupRegisterFindClass(\"text\"));\n\n  ic->name = \"multiline\";   /* register the multiline name, so LED will work */\n  ic->format = \"a\"; /* one ACTION callback name */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  ic->Create = iMultilineCreateMethod;\n\n  return ic;\n}\n","/** \\file\n * \\brief Timer Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_str.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_timer.h\"\n#include \"iup_attrib.h\"\n\n\nlong long iupTimerGetLongLong(Ihandle* ih, const char* name)\n{\n  long long i = 0;\n  char *value = iupAttribGetStr(ih, name);\n  if (value)\n  {\n    if (sscanf(value, \"%lld\", &i) != 1)\n      return 0;\n  }\n  return i;\n}\n\nstatic int iTimerSetRunAttrib(Ihandle *ih, const char *value)\n{\n  if (iupStrBoolean(value))\n    iupdrvTimerRun(ih);\n  else\n    iupdrvTimerStop(ih);\n\n  return 0;\n}\n\nstatic char* iTimerGetRunAttrib(Ihandle *ih)\n{\n  return iupStrReturnBoolean (ih->serial > 0); \n}\n\nstatic char* iTimerGetWidAttrib(Ihandle *ih)\n{\n  return iupStrReturnInt(ih->serial);\n}\n\nstatic void iTimerDestroyMethod(Ihandle* ih)\n{\n  iupdrvTimerStop(ih);\n}\n\n/******************************************************************************/\n\nIhandle* IupTimer(void)\n{\n  return IupCreate(\"timer\");\n}\n\nIclass* iupTimerNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"timer\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupTimerNewClass;\n  ic->Destroy = iTimerDestroyMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"ACTION_CB\", \"\");\n\n  /* Attribute functions */\n  iupClassRegisterAttribute(ic, \"WID\", iTimerGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  iupClassRegisterAttribute(ic, \"RUN\", iTimerGetRunAttrib, iTimerSetRunAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TIME\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvTimerInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief Toggle Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_toggle.h\"\n#include \"iup_image.h\"\n\n\nstatic char* iToggleGetRadioAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->radio); \n}\n\nstatic int iToggleSetFlatAttrib(Ihandle* ih, const char* value)\n{\n  if (!ih->handle)  /* set only before map */\n    ih->data->flat = iupStrBoolean(value);\n  return 0;\n}\n\nstatic char* iToggleGetFlatAttrib(Ihandle *ih)\n{\n  return iupStrReturnBoolean (ih->data->flat); \n}\n\nchar* iupToggleGetPaddingAttrib(Ihandle* ih)\n{\n  return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');\n}\n\nstatic int iToggleCreateMethod(Ihandle* ih, void** params)\n{\n  if (params)\n  {\n    if (params[0]) iupAttribSetStr(ih, \"TITLE\", (char*)(params[0]));\n    if (params[1]) iupAttribSetStr(ih, \"ACTION\", (char*)(params[1]));\n  }\n  ih->data = iupALLOCCTRLDATA();\n  return IUP_NOERROR;\n}\n\nstatic void iToggleComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  int natural_w = 0, \n      natural_h = 0,\n      type = ih->data->type;\n  (void)children_expand; /* unset if not a container */\n\n  if (!ih->handle)\n  {\n    /* if not mapped must initialize the internal values */\n    char* value = iupAttribGet(ih, \"IMAGE\");\n    if (value)\n      type = IUP_TOGGLE_IMAGE;\n    else\n      type = IUP_TOGGLE_TEXT;\n  }\n\n  if (type == IUP_TOGGLE_IMAGE)\n  {\n    iupImageGetInfo(iupAttribGet(ih, \"IMAGE\"), &natural_w, &natural_h, NULL);\n\n    /* even when IMPRESS is set, must compute the borders space */\n    iupdrvButtonAddBorders(&natural_w, &natural_h);\n\n    natural_w += 2*ih->data->horiz_padding;\n    natural_h += 2*ih->data->vert_padding;\n  }\n  else /* IUP_TOGGLE_TEXT */\n  {\n    /* must use IupGetAttribute to check from the native implementation */\n    char* title = IupGetAttribute(ih, \"TITLE\");\n    char* str = iupStrProcessMnemonic(title, NULL, 0);   /* remove & */\n    iupdrvFontGetMultiLineStringSize(ih, str, &natural_w, &natural_h);\n\n    iupdrvToggleAddCheckBox(&natural_w, &natural_h, str);\n\n    if (str && str != title) free(str);\n  }\n\n  *w = natural_w;\n  *h = natural_h;\n}\n\n\n/******************************************************************************/\n\n\nIhandle* IupToggle(const char* title, const char* action)\n{\n  void *params[3];\n  params[0] = (void*)title;\n  params[1] = (void*)action;\n  params[2] = NULL;\n  return IupCreatev(\"toggle\", params);\n}\n\nIclass* iupToggleNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"toggle\";\n  ic->format = \"sa\"; /* one string and one ACTION callback name */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupToggleNewClass;\n  ic->Create = iToggleCreateMethod;\n  ic->ComputeNaturalSize = iToggleComputeNaturalSizeMethod;\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"ACTION\", \"i\");\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  iupClassRegisterAttribute(ic, \"RADIO\", iToggleGetRadioAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"3STATE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FLAT\", iToggleGetFlatAttrib, iToggleSetFlatAttrib, IUPAF_SAMEASSYSTEM, \"No\", IUPAF_NOT_MAPPED|IUPAF_DEFAULT);\n\n  iupdrvToggleInitClass(ic);\n\n  return ic;\n}\n","/** \\file\n * \\brief Tree control\n *\n * See Copyright Notice in iup.h\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_tree.h\"\n#include \"iup_assert.h\"\n\n\nstatic void iTreeInitializeImages(void)\n{\n  Ihandle *image_leaf, *image_blank, *image_paper;  \n  Ihandle *image_collapsed, *image_expanded;  \n\n#define ITREE_IMG_WIDTH   16\n#define ITREE_IMG_HEIGHT  16\n\n  unsigned char img_leaf[ITREE_IMG_WIDTH*ITREE_IMG_HEIGHT] = \n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 4, 4, 5, 5, 5, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 4, 5, 5, 1, 6, 1, 5, 0, 0, 0, 0,\n    0, 0, 0, 0, 3, 4, 4, 5, 5, 1, 6, 1, 5, 0, 0, 0,\n    0, 0, 0, 0, 3, 4, 4, 4, 5, 5, 1, 1, 5, 0, 0, 0,\n    0, 0, 0, 0, 2, 3, 4, 4, 4, 5, 5, 5, 4, 0, 0, 0,\n    0, 0, 0, 0, 2, 3, 3, 4, 4, 4, 5, 4, 4, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 3, 3, 4, 4, 4, 4, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n  };\n\n  unsigned char img_collapsed[ITREE_IMG_WIDTH*ITREE_IMG_HEIGHT] =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  \n    0, 0, 0, 0, 2, 2, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0,  \n    0, 0, 0, 2, 6, 5, 5, 7, 2, 3, 0, 0, 0, 0, 0, 0, \n    0, 0, 2, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 0, \n    0, 0, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 7, 7, 1, 7, 1, 7, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 7, 7, 7, 1, 7, 1, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 1, 7, 1, 7, 1, 7, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 7, 1, 7, 1, 7, 1, 4, 3, \n    0, 0, 2, 5, 7, 7, 7, 7, 1, 7, 1, 7, 1, 1, 4, 3, \n    0, 0, 2, 5, 1, 7, 1, 1, 7, 1, 7, 1, 1, 1, 4, 3, \n    0, 0, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3,  \n    0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \n  };\n\n  unsigned char img_expanded[ITREE_IMG_WIDTH*ITREE_IMG_HEIGHT] =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 2, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 2, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 2, 2, 0, \n    0, 0, 2, 1, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 6, 4, \n    0, 0, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 4, \n    0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 6, 4, \n    0, 2, 1, 3, 3, 3, 3, 3, 5, 3, 5, 6, 4, 6, 6, 4, \n    0, 2, 1, 3, 3, 3, 3, 3, 3, 5, 3, 6, 4, 6, 6, 4, \n    0, 0, 2, 0, 3, 3, 3, 3, 5, 3, 5, 5, 2, 4, 2, 4, \n    0, 0, 2, 0, 3, 3, 5, 5, 3, 5, 5, 5, 6, 4, 2, 4, \n    0, 0, 0, 2, 0, 5, 3, 3, 5, 5, 5, 5, 6, 2, 4, 4, \n    0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, \n    0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \n  };\n\n  unsigned char img_blank[ITREE_IMG_WIDTH*ITREE_IMG_HEIGHT] =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 0, 0, 0, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 0, 0, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 4, 0, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 0,\n    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0\n  };\n\n  unsigned char img_paper[ITREE_IMG_WIDTH*ITREE_IMG_HEIGHT] =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 0, 0, 0, 0,\n    0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 0, 0, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 4, 0, 0,\n    0, 0, 3, 1, 4, 3, 4, 3, 4, 3, 4, 2, 2, 2, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 3, 4, 3, 4, 3, 4, 3, 4, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 4, 3, 4, 3, 4, 3, 4, 3, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 3, 4, 3, 4, 3, 4, 3, 4, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 1, 4, 3, 4, 3, 4, 3, 4, 3, 1, 5, 2, 0,\n    0, 0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 0,\n    0, 0, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 0,\n    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0\n  };\n\n  image_leaf      = IupImage(ITREE_IMG_WIDTH, ITREE_IMG_HEIGHT, img_leaf);\n  image_collapsed = IupImage(ITREE_IMG_WIDTH, ITREE_IMG_HEIGHT, img_collapsed);\n  image_expanded  = IupImage(ITREE_IMG_WIDTH, ITREE_IMG_HEIGHT, img_expanded);\n  image_blank     = IupImage(ITREE_IMG_WIDTH, ITREE_IMG_HEIGHT, img_blank);\n  image_paper     = IupImage(ITREE_IMG_WIDTH, ITREE_IMG_HEIGHT, img_paper);\n\n  IupSetAttribute(image_leaf, \"0\", \"BGCOLOR\");\n  IupSetAttribute(image_leaf, \"1\", \"192 192 192\");\n  IupSetAttribute(image_leaf, \"2\", \"56 56 56\");\n  IupSetAttribute(image_leaf, \"3\", \"99 99 99\");\n  IupSetAttribute(image_leaf, \"4\", \"128 128 128\");\n  IupSetAttribute(image_leaf, \"5\", \"161 161 161\");\n  IupSetAttribute(image_leaf, \"6\", \"222 222 222\");\n\n  IupSetAttribute(image_collapsed, \"0\", \"BGCOLOR\");\n  IupSetAttribute(image_collapsed, \"1\", \"255 206 156\");\n  IupSetAttribute(image_collapsed, \"2\", \"156 156 0\");\n  IupSetAttribute(image_collapsed, \"3\", \"0 0 0\");\n  IupSetAttribute(image_collapsed, \"4\", \"206 206 99\");\n  IupSetAttribute(image_collapsed, \"5\", \"255 255 206\");\n  IupSetAttribute(image_collapsed, \"6\", \"247 247 247\");\n  IupSetAttribute(image_collapsed, \"7\", \"255 255 156\");\n\n  IupSetAttribute(image_expanded, \"0\", \"BGCOLOR\");\n  IupSetAttribute(image_expanded, \"1\", \"255 255 255\");\n  IupSetAttribute(image_expanded, \"2\", \"156 156 0\");\n  IupSetAttribute(image_expanded, \"3\", \"255 255 156\");\n  IupSetAttribute(image_expanded, \"4\", \"0 0 0\");\n  IupSetAttribute(image_expanded, \"5\", \"255 206 156\");\n  IupSetAttribute(image_expanded, \"6\", \"206 206 99\");\n\n  IupSetAttribute(image_blank, \"0\", \"BGCOLOR\");\n  IupSetAttribute(image_blank, \"1\", \"255 255 255\");\n  IupSetAttribute(image_blank, \"2\", \"000 000 000\");\n  IupSetAttribute(image_blank, \"3\", \"119 119 119\");\n  IupSetAttribute(image_blank, \"4\", \"136 136 136\");\n  IupSetAttribute(image_blank, \"5\", \"187 187 187\");\n\n  IupSetAttribute(image_paper, \"0\", \"BGCOLOR\");\n  IupSetAttribute(image_paper, \"1\", \"255 255 255\");\n  IupSetAttribute(image_paper, \"2\", \"000 000 000\");\n  IupSetAttribute(image_paper, \"3\", \"119 119 119\");\n  IupSetAttribute(image_paper, \"4\", \"136 136 136\");\n  IupSetAttribute(image_paper, \"5\", \"187 187 187\");\n\n  IupSetHandle(\"IMGLEAF\",      image_leaf);\n  IupSetHandle(\"IMGCOLLAPSED\", image_collapsed);\n  IupSetHandle(\"IMGEXPANDED\",  image_expanded);\n  IupSetHandle(\"IMGBLANK\",     image_blank);\n  IupSetHandle(\"IMGPAPER\",     image_paper);\n\n#undef ITREE_IMG_WIDTH\n#undef ITREE_IMG_HEIGHT\n}\n\nvoid iupTreeUpdateImages(Ihandle *ih)\n{\n  char* value = iupAttribGet(ih, \"IMAGELEAF\");\n  if (!value) value = \"IMGLEAF\";\n  iupAttribSetClassObject(ih, \"IMAGELEAF\", value);\n\n  value = iupAttribGet(ih, \"IMAGEBRANCHCOLLAPSED\");\n  if (!value) value = \"IMGCOLLAPSED\";\n  iupAttribSetClassObject(ih, \"IMAGEBRANCHCOLLAPSED\", value);\n\n  value = iupAttribGet(ih, \"IMAGEBRANCHEXPANDED\");\n  if (!value) value = \"IMGEXPANDED\";\n  iupAttribSetClassObject(ih, \"IMAGEBRANCHEXPANDED\", value);\n}\n\nvoid iupTreeSelectLastCollapsedBranch(Ihandle* ih, int *last_id)\n{\n  /* if last selected item is a branch, then select its children */\n  if (iupStrEqual(IupTreeGetAttribute(ih, \"KIND\", *last_id), \"BRANCH\") && \n      iupStrEqual(IupTreeGetAttribute(ih, \"STATE\", *last_id), \"COLLAPSED\"))\n  {\n    int childcount = IupTreeGetInt(ih, \"CHILDCOUNT\", *last_id);\n    if (childcount > 0)\n    {\n      int start = *last_id + 1;\n      int end = *last_id + childcount;\n      IupSetfAttribute(ih, \"MARK\", \"%d-%d\", start, end);\n      *last_id = *last_id + childcount;\n    }\n  }\n}\n\nint iupTreeForEach(Ihandle* ih, iupTreeNodeFunc func, void* userdata)\n{\n  int i;\n  for (i = 0; i < ih->data->node_count; i++)\n  {\n    if (!func(ih, ih->data->node_cache[i].node_handle, i, userdata))\n      return 0;\n  }\n\n  return 1;\n}\n\nint iupTreeFindNodeId(Ihandle* ih, InodeHandle* node_handle)\n{\n  /* Unoptimized version:\n  int i;\n  for (i = 0; i < ih->data->node_count; i++)\n  {\n    if (ih->data->node_cache[i].node_handle == node_handle)\n      return i;\n  }\n  */\n  InodeData *node_cache = ih->data->node_cache;\n  while(node_cache->node_handle != node_handle && \n        node_cache->node_handle != NULL)   /* the cache always have zeros at the end */\n    node_cache++;\n\n  if (node_cache->node_handle != NULL)\n    return (int)(node_cache - ih->data->node_cache);\n  else\n    return -1;\n}\n\nstatic int iTreeFindUserDataId(Ihandle* ih, void* userdata)\n{\n  /* Unoptimized version:\n  int i;\n  for (i = 0; i < ih->data->node_count; i++)\n  {\n    if (ih->data->node_cache[i].node_handle == node_handle)\n      return i;\n  }\n  */\n  InodeData *node_cache = ih->data->node_cache;\n  while(node_cache->userdata != userdata && \n        node_cache->node_handle != NULL)   /* the cache always have zeros at the end */\n    node_cache++;\n\n  if (node_cache->node_handle != NULL)\n    return (int)(node_cache - ih->data->node_cache);\n  else\n    return -1;\n}\n\nInodeHandle* iupTreeGetNode(Ihandle* ih, int id)\n{\n  if (id >= 0 && id < ih->data->node_count)\n    return ih->data->node_cache[id].node_handle;\n  else if (id == IUP_INVALID_ID && ih->data->node_count!=0)\n    return iupdrvTreeGetFocusNode(ih);\n  else\n    return NULL;\n}\n\nInodeHandle* iupTreeGetNodeFromString(Ihandle* ih, const char* name_id)\n{\n  int id = IUP_INVALID_ID;\n  iupStrToInt(name_id, &id);\n  return iupTreeGetNode(ih, id);\n}\n\nstatic void iTreeAddToCache(Ihandle* ih, int id, InodeHandle* node_handle)\n{\n  iupASSERT(id >= 0 && id < ih->data->node_count);\n  if (id < 0 || id >= ih->data->node_count)\n    return;\n\n  /* node_count here already contains the final count */\n\n  if (id == ih->data->node_count-1)\n    ih->data->node_cache[id].node_handle = node_handle;\n  else\n  {\n    /* open space for the new id */\n    int remain_count = ih->data->node_count-id;\n    memmove(ih->data->node_cache+id+1, ih->data->node_cache+id, remain_count*sizeof(InodeData));\n    ih->data->node_cache[id].node_handle = node_handle;\n  }\n\n  ih->data->node_cache[id].userdata = NULL;\n}\n\nstatic void iTreeIncCacheMem(Ihandle* ih)\n{\n  /* node_count here already contains the final count */\n\n  if (ih->data->node_count+10 > ih->data->node_cache_max)\n  {\n    int old_node_cache_max = ih->data->node_cache_max;\n    ih->data->node_cache_max += 20;\n    ih->data->node_cache = realloc(ih->data->node_cache, ih->data->node_cache_max*sizeof(InodeData));\n    memset(ih->data->node_cache+old_node_cache_max, 0, 20*sizeof(InodeData));\n  }\n}\n\nvoid iupTreeAddToCache(Ihandle* ih, int add, int kindPrev, InodeHandle* prevNode, InodeHandle* node_handle)\n{\n  int new_id = 0;\n\n  ih->data->node_count++;\n\n  /* node_count here already contains the final count */\n  iTreeIncCacheMem(ih);\n\n  if (prevNode)\n  {\n    if (add || kindPrev == ITREE_LEAF)\n    {\n      /* ADD implies always that id=prev_id+1 */\n      /* INSERT after a leaf implies always that new_id=prev_id+1 */\n      int prev_id = iupTreeFindNodeId(ih, prevNode);\n      new_id = prev_id+1;\n    }\n    else\n    {\n      /* INSERT after a branch implies always that new_id=prev_id+1+child_count */\n      int prev_id = iupTreeFindNodeId(ih, prevNode);\n      int child_count = iupdrvTreeTotalChildCount(ih, prevNode);\n      new_id = prev_id+1+child_count;\n    }\n  }\n\n  iTreeAddToCache(ih, new_id, node_handle);\n  iupAttribSetInt(ih, \"LASTADDNODE\", new_id);\n}\n\nvoid iupTreeDelFromCache(Ihandle* ih, int id, int count)\n{\n  int remain_count, last_add_node;\n\n  /* id can be the last node, actually==node_count becase node_count is already updated */\n  iupASSERT(id >= 0 && id <= ih->data->node_count);  \n  if (id < 0 || id > ih->data->node_count)\n    return;\n\n  /* minimum sanity check for LASTADDNODE */\n  last_add_node = iupAttribGetInt(ih, \"LASTADDNODE\");\n  if (last_add_node >= id && last_add_node < id+count)\n    iupAttribSet(ih, \"LASTADDNODE\", NULL);\n  else if (last_add_node >= id+count)\n    iupAttribSetInt(ih, \"LASTADDNODE\", last_add_node-count);\n\n  /* node_count here already contains the final count */\n\n  /* remove id+count */\n  remain_count = ih->data->node_count-id;\n  memmove(ih->data->node_cache+id, ih->data->node_cache+id+count, remain_count*sizeof(InodeData));\n\n  /* clear the remaining space */\n  memset(ih->data->node_cache+ih->data->node_count, 0, count*sizeof(InodeData));\n}\n\nvoid iupTreeCopyMoveCache(Ihandle* ih, int id_src, int id_dst, int count, int is_copy)\n{\n  int remain_count;\n\n  iupASSERT(id_src >= 0 && id_src < ih->data->node_count);\n  if (id_src < 0 || id_src >= ih->data->node_count)\n    return;\n\n  iupASSERT(id_dst >= 0 && id_dst < ih->data->node_count);\n  if (id_dst < 0 || id_dst >= ih->data->node_count)\n    return;\n\n  iupASSERT(id_dst < id_src || id_dst > id_src+count);\n  if (id_dst >= id_src && id_dst <= id_src+count)\n    return;\n\n  /* id_dst here points to the final position for a copy operation */\n\n  /* node_count here contains the final count for a copy operation */\n  iTreeIncCacheMem(ih);\n\n  /* add space for new nodes */\n  remain_count = ih->data->node_count - (id_dst + count);\n  memmove(ih->data->node_cache+id_dst+count, ih->data->node_cache+id_dst, remain_count*sizeof(InodeData));\n\n  /* compensate because we add space for new nodes */\n  if (id_src > id_dst)\n    id_src += count;\n\n  if (is_copy) \n  {\n    /* during a copy, the userdata is not reused, so clear it */\n    memset(ih->data->node_cache+id_dst, 0, count*sizeof(InodeData));\n  }\n  else /* move = copy + delete */\n  {\n    /* copy userdata from src to dst */\n    memcpy(ih->data->node_cache+id_dst, ih->data->node_cache+id_src, count*sizeof(InodeData));\n\n    /* remove the src */\n    remain_count = ih->data->node_count - (id_src + count);\n    memmove(ih->data->node_cache+id_src, ih->data->node_cache+id_src+count, remain_count*sizeof(InodeData));\n\n    /* clear the remaining space */\n    memset(ih->data->node_cache+ih->data->node_count-count, 0, count*sizeof(InodeData));\n  }\n\n  iupAttribSet(ih, \"LASTADDNODE\", NULL);\n}\n\n/*************************************************************************/\n\n\nchar* iupTreeGetSpacingAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->spacing);\n}\n\nstatic char* iTreeGetMarkModeAttrib(Ihandle* ih)\n{\n  if (ih->data->mark_mode==ITREE_MARK_SINGLE)\n    return \"SINGLE\";\n  else\n    return \"MULTIPLE\";\n}\n\nstatic int iTreeSetMarkModeAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"MULTIPLE\"))\n    ih->data->mark_mode = ITREE_MARK_MULTIPLE;    \n  else \n    ih->data->mark_mode = ITREE_MARK_SINGLE;\n\n  if (ih->handle)\n    iupdrvTreeUpdateMarkMode(ih); /* for this to work, must update during map */\n\n  return 0;\n}\n\nstatic int iTreeSetShiftAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value) && iupAttribGetBoolean(ih, \"CTRL\"))\n    iTreeSetMarkModeAttrib(ih, \"MULTIPLE\");\n  else\n    iTreeSetMarkModeAttrib(ih, \"SINGLE\");\n  return 1;\n}\n\nstatic int iTreeSetCtrlAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value) && iupAttribGetBoolean(ih, \"SHIFT\"))\n    iTreeSetMarkModeAttrib(ih, \"MULTIPLE\");\n  else\n    iTreeSetMarkModeAttrib(ih, \"SINGLE\");\n  return 1;\n}\n\nstatic char* iTreeGetShowRenameAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->show_rename); \n}\n\nstatic int iTreeSetShowRenameAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->show_rename = 1;\n  else\n    ih->data->show_rename = 0;\n\n  return 0;\n}\n\nstatic char* iTreeGetShowToggleAttrib(Ihandle* ih)\n{\n  if (ih->data->show_toggle)\n  {\n    if (ih->data->show_toggle == 2)\n      return \"3STATE\";\n    else\n      return \"YES\";\n  }\n  else\n    return \"NO\";\n}\n\nstatic int iTreeSetShowToggleAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"3STATE\"))\n    ih->data->show_toggle = 2;\n  else if (iupStrBoolean(value))\n    ih->data->show_toggle = 1;\n  else\n    ih->data->show_toggle = 0;\n\n  return 0;\n}\n\nstatic char* iTreeGetShowDragDropAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->show_dragdrop); \n}\n\nstatic int iTreeSetShowDragDropAttrib(Ihandle* ih, const char* value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n    ih->data->show_dragdrop = 1;\n  else\n    ih->data->show_dragdrop = 0;\n\n  return 0;\n}\n\nstatic int iTreeSetAddLeafAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  iupdrvTreeAddNode(ih, id, ITREE_LEAF, value, 1);\n  return 0;\n}\n\nstatic int iTreeSetAddBranchAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  iupdrvTreeAddNode(ih, id, ITREE_BRANCH, value, 1);\n  return 0;\n}\n\nstatic int iTreeSetInsertLeafAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  iupdrvTreeAddNode(ih, id, ITREE_LEAF, value, 0);\n  return 0;\n}\n\nstatic int iTreeSetInsertBranchAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (!ih->handle)  /* do not do the action before map */\n    return 0;\n  iupdrvTreeAddNode(ih, id, ITREE_BRANCH, value, 0);\n  return 0;\n}\n\nstatic char* iTreeGetAddExpandedAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->add_expanded); \n}\n\nstatic int iTreeSetAddExpandedAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n    ih->data->add_expanded = 1;\n  else\n    ih->data->add_expanded = 0;\n\n  return 0;\n}\n\nstatic char* iTreeGetCountAttrib(Ihandle* ih)\n{\n  return iupStrReturnInt(ih->data->node_count);\n}\n\nstatic char* iTreeGetTotalChildCountAttrib(Ihandle* ih, int id)\n{\n  InodeHandle* node_handle = iupTreeGetNode(ih, id);\n  if (!node_handle)\n    return NULL;\n\n  return iupStrReturnInt(iupdrvTreeTotalChildCount(ih, node_handle));\n}\n\nstatic char* iTreeGetUserDataAttrib(Ihandle* ih, int id)\n{\n  if (id >= 0 && id < ih->data->node_count)\n    return ih->data->node_cache[id].userdata;\n  else if (id == IUP_INVALID_ID && ih->data->node_count!=0)\n  {\n    InodeHandle* node_handle = iupdrvTreeGetFocusNode(ih);\n    id = iupTreeFindNodeId(ih, node_handle);\n    if (id >= 0 && id < ih->data->node_count)\n      return ih->data->node_cache[id].userdata;\n  }\n  return NULL;\n}\n\nstatic int iTreeSetUserDataAttrib(Ihandle* ih, int id, const char* value)\n{\n  if (id >= 0 && id < ih->data->node_count)\n    ih->data->node_cache[id].userdata = (void*)value;\n  else if (id == IUP_INVALID_ID && ih->data->node_count!=0)\n  {\n    InodeHandle* node_handle = iupdrvTreeGetFocusNode(ih);\n    id = iupTreeFindNodeId(ih, node_handle);\n    if (id >= 0 && id < ih->data->node_count)\n      ih->data->node_cache[id].userdata = (void*)value;\n  }\n  return 0;\n}\n\n\n/*****************************************************************************************/\n\n\nvoid iupTreeDragDropCopyCache(Ihandle* ih, int id_src, int id_dst, int count)\n{\n  int remain_count;\n\n  iupASSERT(id_src >= 0 && id_src < ih->data->node_count);\n  if (id_src < 0 || id_src >= ih->data->node_count)\n    return;\n\n  iupASSERT(id_dst >= 0 && id_dst < ih->data->node_count);\n  if (id_dst < 0 || id_dst >= ih->data->node_count)\n    return;\n\n  /* id_dst here points to the final position for a copy operation */\n\n  /* node_count here contains the final count for a copy operation */\n  iTreeIncCacheMem(ih);\n\n  /* add space for new nodes */\n  remain_count = ih->data->node_count - (id_dst + count);\n  memmove(ih->data->node_cache+id_dst+count, ih->data->node_cache+id_dst, remain_count*sizeof(InodeData));\n\n  /* compensate because we add space for new nodes */\n  if (id_src > id_dst)\n    id_src += count;\n\n  /* during a copy, the userdata is not reused, so clear it */\n  memset(ih->data->node_cache+id_dst, 0, count*sizeof(InodeData));\n\n  iupAttribSet(ih, \"LASTADDNODE\", NULL);\n}\n\nstatic int iTreeDropData_CB(Ihandle *ih, char* type, void* data, int len, int x, int y)\n{\n  int pos = IupConvertXYToPos(ih, x, y);\n  int is_ctrl = 0;\n  char key[5];\n\n  /* Data is not the pointer, it contains the pointer */\n  Ihandle* ih_source;\n  memcpy((void*)&ih_source, data, len);\n\n  /* A copy operation is enabled with the CTRL key pressed, or else a move operation will occour.\n     A move operation will be possible only if the attribute DRAGSOURCEMOVE is Yes.\n     When no key is pressed the default operation is copy when DRAGSOURCEMOVE=No and move when DRAGSOURCEMOVE=Yes. */\n  iupdrvGetKeyState(key);\n  if (key[1] == 'C')\n    is_ctrl = 1;\n\n  /* Here copy/move of multiple selection is not allowed,\n     only a single node and its children. */\n\n  if(ih_source->data->mark_mode == ITREE_MARK_SINGLE)\n  {\n    int srcPos = iupAttribGetInt(ih_source, \"_IUP_TREE_SOURCEPOS\");\n    InodeHandle *itemDst, *itemSrc;\n\n    itemSrc = iupTreeGetNode(ih_source, srcPos);\n    if (!itemSrc)\n      return IUP_DEFAULT;\n\n    itemDst = iupTreeGetNode(ih, pos);\n    if (!itemDst)\n      return IUP_DEFAULT;\n\n    /* Copy the node and its children to the new position */\n    iupdrvTreeDragDropCopyNode(ih_source, ih, itemSrc, itemDst);\n\n    if(IupGetInt(ih_source, \"DRAGSOURCEMOVE\") && !is_ctrl)\n      IupSetAttribute(ih_source, \"DELNODE0\", \"MARKED\");\n  }\n\n  (void)type;\n  return IUP_DEFAULT;\n}\n\nstatic int iTreeDragData_CB(Ihandle *ih, char* type, void *data, int len)\n{\n  int pos = iupAttribGetInt(ih, \"_IUP_TREE_SOURCEPOS\");\n  if (pos < 1)\n    return IUP_DEFAULT;\n\n  if(ih->data->mark_mode == ITREE_MARK_SINGLE)\n  {\n    /* Single selection */\n    IupSetAttributeId(ih, \"MARKED\", pos, \"YES\");\n  }\n\n  /* Copy source handle */\n  memcpy(data, (void*)&ih, len);\n \n  (void)type;\n  return IUP_DEFAULT;\n}\n\nstatic int iTreeDragDataSize_CB(Ihandle* ih, char* type)\n{\n  (void)ih;\n  (void)type;\n  return sizeof(Ihandle*);\n}\n\nstatic int iTreeDragEnd_CB(Ihandle *ih, int del)\n{\n  iupAttribSetInt(ih, \"_IUP_TREE_SOURCEPOS\", 0);\n  (void)del;\n  return IUP_DEFAULT;\n}\n\nstatic int iTreeDragBegin_CB(Ihandle* ih, int x, int y)\n{\n  int pos = IupConvertXYToPos(ih, x, y);\n  iupAttribSetInt(ih, \"_IUP_TREE_SOURCEPOS\", pos);\n  return IUP_DEFAULT;\n}\n\nstatic int iTreeSetDragDropTreeAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrBoolean(value))\n  {\n    /* Register callbacks to enable drag and drop between trees */\n    IupSetCallback(ih, \"DRAGBEGIN_CB\",    (Icallback)iTreeDragBegin_CB);\n    IupSetCallback(ih, \"DRAGDATASIZE_CB\", (Icallback)iTreeDragDataSize_CB);\n    IupSetCallback(ih, \"DRAGDATA_CB\",     (Icallback)iTreeDragData_CB);\n    IupSetCallback(ih, \"DRAGEND_CB\",      (Icallback)iTreeDragEnd_CB);\n    IupSetCallback(ih, \"DROPDATA_CB\",     (Icallback)iTreeDropData_CB);\n  }\n  else\n  {\n    /* Unregister callbacks */\n    IupSetCallback(ih, \"DRAGBEGIN_CB\",    NULL);\n    IupSetCallback(ih, \"DRAGDATASIZE_CB\", NULL);\n    IupSetCallback(ih, \"DRAGDATA_CB\",     NULL);\n    IupSetCallback(ih, \"DRAGEND_CB\",      NULL);\n    IupSetCallback(ih, \"DROPDATA_CB\",     NULL);\n  }\n\n  return 1;\n}\n\n\n/*************************************************************************/\n\n\nstatic int iTreeCreateMethod(Ihandle* ih, void **params)\n{\n  (void)params;\n\n  ih->data = iupALLOCCTRLDATA();\n\n  IupSetAttribute(ih, \"RASTERSIZE\", \"400x200\");\n  IupSetAttribute(ih, \"EXPAND\", \"YES\");\n\n  ih->data->add_expanded = 1;\n  ih->data->node_cache_max = 20;\n  ih->data->node_cache = calloc(ih->data->node_cache_max, sizeof(InodeData));\n\n  return IUP_NOERROR;\n}\n\nstatic void iTreeDestroyMethod(Ihandle* ih)\n{\n  if (ih->data->node_cache)\n    free(ih->data->node_cache);\n}\n\n/*************************************************************************/\n\nIhandle* IupTree(void)\n{\n  return IupCreate(\"tree\");\n}\n\nIclass* iupTreeNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"tree\";\n  ic->format = NULL; /* no parameters */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n  ic->has_attrib_id = 1;   /* has attributes with IDs that must be parsed */\n\n  /* Class functions */\n  ic->New = iupTreeNewClass;\n  ic->Create = iTreeCreateMethod;\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->Destroy = iTreeDestroyMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"TOGGLEVALUE_CB\",    \"ii\");\n  iupClassRegisterCallback(ic, \"SELECTION_CB\",      \"ii\");\n  iupClassRegisterCallback(ic, \"MULTISELECTION_CB\", \"Ii\");\n  iupClassRegisterCallback(ic, \"MULTIUNSELECTION_CB\", \"Ii\");\n  iupClassRegisterCallback(ic, \"BRANCHOPEN_CB\",     \"i\");\n  iupClassRegisterCallback(ic, \"BRANCHCLOSE_CB\",    \"i\");\n  iupClassRegisterCallback(ic, \"EXECUTELEAF_CB\",    \"i\");\n  iupClassRegisterCallback(ic, \"SHOWRENAME_CB\",     \"i\");\n  iupClassRegisterCallback(ic, \"RENAME_CB\",         \"is\");\n  iupClassRegisterCallback(ic, \"DRAGDROP_CB\",       \"iiii\");\n  iupClassRegisterCallback(ic, \"RIGHTCLICK_CB\",     \"i\");\n  iupClassRegisterCallback(ic, \"MOTION_CB\", \"iis\");\n  iupClassRegisterCallback(ic, \"BUTTON_CB\", \"iiiis\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* Drag&Drop */\n  iupdrvRegisterDragDropAttrib(ic);\n\n  /* IupTree Attributes - GENERAL */\n  iupClassRegisterAttribute(ic, \"DRAGDROPTREE\", NULL, iTreeSetDragDropTreeAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWDRAGDROP\", iTreeGetShowDragDropAttrib, iTreeSetShowDragDropAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWRENAME\",   iTreeGetShowRenameAttrib,   iTreeSetShowRenameAttrib,   NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWTOGGLE\",   iTreeGetShowToggleAttrib,   iTreeSetShowToggleAttrib,   NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ADDEXPANDED\",  iTreeGetAddExpandedAttrib,  iTreeSetAddExpandedAttrib,  IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"COUNT\",        iTreeGetCountAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LASTADDNODE\", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ADDROOT\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DROPEQUALDRAG\", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);\n                                               \n  /* IupTree Attributes - MARKS */\n  iupClassRegisterAttribute(ic, \"CTRL\",  NULL, iTreeSetCtrlAttrib,  NULL, NULL, IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"SHIFT\", NULL, iTreeSetShiftAttrib, NULL, NULL, IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"MARKMODE\",  iTreeGetMarkModeAttrib, iTreeSetMarkModeAttrib,  IUPAF_SAMEASSYSTEM, \"SINGLE\", IUPAF_NOT_MAPPED);\n\n  /* IupTree Attributes - ACTION */\n  iupClassRegisterAttributeId(ic, \"ADDLEAF\",   NULL, iTreeSetAddLeafAttrib,   IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"ADDBRANCH\", NULL, iTreeSetAddBranchAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"INSERTLEAF\",   NULL, iTreeSetInsertLeafAttrib,   IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"INSERTBRANCH\", NULL, iTreeSetInsertBranchAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\n  /* IupTree Attributes - NODES */\n  iupClassRegisterAttributeId(ic, \"TOTALCHILDCOUNT\", iTreeGetTotalChildCountAttrib,   NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"USERDATA\", iTreeGetUserDataAttrib, iTreeSetUserDataAttrib, IUPAF_NO_STRING|IUPAF_NO_INHERIT);\n  \n  /* Default node images */\n  if (!IupGetHandle(\"IMGLEAF\") || !IupGetHandle(\"IMGBLANK\") || !IupGetHandle(\"IMGPAPER\"))\n    iTreeInitializeImages();\n\n  iupdrvTreeInitClass(ic);\n\n  return ic;\n}\n\n/********************************************************************************************/\n\nvoid IupTreeSetAttribute(Ihandle* ih, const char* a, int id, const char* v)\n{\n  IupSetAttributeId(ih, a, id, v);\n}\n\nvoid IupTreeStoreAttribute(Ihandle* ih, const char* a, int id, const char* v)\n{\n  IupStoreAttributeId(ih, a, id, v);\n}\n\nchar* IupTreeGetAttribute(Ihandle* ih, const char* a, int id)\n{\n  return IupGetAttributeId(ih, a, id);\n}\n\nint IupTreeGetInt(Ihandle* ih, const char* a, int id)\n{\n  return IupGetIntId(ih, a, id);\n}\n\nfloat IupTreeGetFloat(Ihandle* ih, const char* a, int id)\n{\n  return IupGetFloatId(ih, a, id);\n}\n\nvoid IupTreeSetfAttribute(Ihandle* ih, const char* a, int id, const char* f, ...)\n{\n  int size;\n  char* v = iupStrGetLargeMem(&size);\n  va_list arglist;\n  va_start(arglist, f);\n  vsnprintf(v, size, f, arglist);\n  va_end(arglist);\n  IupStoreAttributeId(ih, a, id, v);\n}\n\nvoid IupTreeSetAttributeHandle(Ihandle* ih, const char* a, int id, Ihandle* ih_named)\n{\n  char attr[50];\n  sprintf(attr, \"%s%d\", a, id);\n  IupSetAttributeHandle(ih, attr, ih_named);\n}\n\n/************************************************************************************/\n\nint IupTreeSetUserId(Ihandle* ih, int id, void* userdata)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return 0;\n\n  if (id >= 0 && id < ih->data->node_count)\n  {\n    ih->data->node_cache[id].userdata = userdata;\n    return 1;\n  }\n\n  return 0;\n}\n\nint IupTreeGetId(Ihandle* ih, void *userdata)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return -1;\n\n  return iTreeFindUserDataId(ih, userdata);\n}\n\nvoid* IupTreeGetUserId(Ihandle* ih, int id)\n{\n  iupASSERT(iupObjectCheck(ih));\n  if (!iupObjectCheck(ih))\n    return NULL;\n\n  if (id >= 0 && id < ih->data->node_count)\n    return ih->data->node_cache[id].userdata;\n\n  return NULL;\n}\n","/** \\file\n * \\brief User Element.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_stdcontrols.h\"\n\n\nstatic int iUserSetClearAttributesAttrib(Ihandle* ih, const char* value)\n{\n  (void)value;\n  iupTableClear(ih->attrib);\n  return 0;\n}\n\nIhandle* IupUser(void)\n{\n  return IupCreate(\"user\");\n}\n\nIclass* iupUserNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"user\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 0;\n\n  ic->New = iupUserNewClass;\n\n  iupClassRegisterAttribute(ic, \"CLEARATTRIBUTES\", NULL, iUserSetClearAttributesAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Valuator Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n#include \"iupcontrols.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_val.h\"\n\n\nvoid iupValCropValue(Ihandle* ih)\n{\n  if (ih->data->val > ih->data->vmax) \n    ih->data->val = ih->data->vmax;\n  else if (ih->data->val < ih->data->vmin) \n    ih->data->val = ih->data->vmin;\n}\n\nchar* iupValGetShowTicksAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->show_ticks);\n}\n\nchar* iupValGetValueAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->val);\n}\n\nchar* iupValGetStepAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->step);\n}\n\nchar* iupValGetPageStepAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->pagestep);\n}\n\nstatic int iValSetMaxAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToDouble(value, &(ih->data->vmax)))\n    iupValCropValue(ih);\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iValGetMaxAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->vmax);\n}\n\nstatic int iValSetMinAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrToDouble(value, &(ih->data->vmin)))\n    iupValCropValue(ih);\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iValGetMinAttrib(Ihandle* ih)\n{\n  return iupStrReturnDouble(ih->data->vmin);\n}\n\nstatic int iValSetOrientationAttrib(Ihandle* ih, const char *value)\n{\n  int min_w, min_h;\n\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrEqualNoCase(value, \"VERTICAL\"))\n  {\n    ih->data->orientation = IVAL_VERTICAL;\n    iupdrvValGetMinSize(ih, &min_w, &min_h);\n    /* val natural vertical size is MinWx100 */\n    IupSetfAttribute(ih, \"RASTERSIZE\", \"%dx%d\", min_w, 100);\n  }\n  else /* \"HORIZONTAL\" */\n  {\n    ih->data->orientation = IVAL_HORIZONTAL;\n    iupdrvValGetMinSize(ih, &min_w, &min_h);\n    /* val natural horizontal size is 100xMinH */\n    IupSetfAttribute(ih, \"RASTERSIZE\", \"%dx%d\", 100, min_h);\n  }\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iValGetOrientationAttrib(Ihandle* ih)\n{\n  if (ih->data->orientation == IVAL_HORIZONTAL)\n    return \"HORIZONTAL\";\n  else /* (ih->data->orientation == IVAL_VERTICAL) */\n    return \"VERTICAL\";\n}\n\nstatic int iValSetInvertedAttrib(Ihandle* ih, const char *value)\n{\n  /* valid only before map */\n  if (ih->handle)\n    return 0;\n\n  if (iupStrBoolean(value))\n    ih->data->inverted = 1;\n  else\n    ih->data->inverted = 0;\n\n  return 0; /* do not store value in hash table */\n}\n\nstatic char* iValGetInvertedAttrib(Ihandle* ih)\n{\n  return iupStrReturnBoolean (ih->data->inverted); \n}\n\nstatic int iValCreateMethod(Ihandle* ih, void **params)\n{\n  char* orientation = \"HORIZONTAL\";\n  if (params && params[0])\n    orientation = params[0];\n\n  ih->data = iupALLOCCTRLDATA();\n\n  iValSetOrientationAttrib(ih, orientation);\n  if (ih->data->orientation == IVAL_VERTICAL)\n    ih->data->inverted = 1;  /* default is YES when vertical */\n\n  ih->data->vmax = 1.00;\n  ih->data->step = 0.01;\n  ih->data->pagestep = 0.10;\n\n  return IUP_NOERROR; \n}\n\nIclass* iupValNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"val\";\n  ic->format = \"s\"; /* one string */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 1;\n\n  /* Class functions */\n  ic->New = iupValNewClass;\n  ic->Create  = iValCreateMethod;\n  ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Callbacks */\n  iupClassRegisterCallback(ic, \"VALUECHANGED_CB\", \"\");\n\n  /* Common Callbacks */\n  iupBaseRegisterCommonCallbacks(ic);\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Visual */\n  iupBaseRegisterVisualAttrib(ic);\n\n  /* IupVal only */\n  iupClassRegisterAttribute(ic, \"MAX\", iValGetMaxAttrib, iValSetMaxAttrib, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"MIN\", iValGetMinAttrib, iValSetMinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"TYPE\", iValGetOrientationAttrib, iValSetOrientationAttrib, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", iValGetOrientationAttrib, iValSetOrientationAttrib, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"INVERTED\", iValGetInvertedAttrib, iValSetInvertedAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupdrvValInitClass(ic);\n\n  return ic;\n}\n\nIhandle *IupVal(const char *orientation)\n{\n  void *params[2];\n  params[0] = (void*)orientation;\n  params[1] = NULL;\n  return IupCreatev(\"val\", params);\n}\n","/** \\file\n * \\brief Vbox Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n#include \"iup_box.h\"\n#include \"iup_normalizer.h\"\n\n\nstatic int iVboxSetRasterSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    iupStrToIntInt(value, &s, &d, 'x');  /* first value will be ignored if second defined, can NOT set width */\n    if (d != 0) s = d;\n    if (s > 0) \n    {\n      ih->userheight = s;\n      ih->userwidth = 0;\n    }\n  }\n  iupAttribSet(ih, \"SIZE\", NULL); /* clear SIZE in hash table */\n  return 0;\n}\n\nstatic int iVboxSetSizeAttrib(Ihandle* ih, const char* value)\n{\n  if (!value)\n  {\n    ih->userwidth = 0;\n    ih->userheight = 0;\n  }\n  else\n  {\n    int s = 0, d = 0;\n    iupStrToIntInt(value, &s, &d, 'x');  /* first value will be ignored if second defined, can NOT set width */\n    if (d != 0) s = d;\n    if (s > 0) \n    {\n      int charwidth, charheight;\n      iupdrvFontGetCharSize(ih, &charwidth, &charheight);\n      ih->userheight = iupHEIGHT2RASTER(s, charheight);\n      ih->userwidth = 0;\n    }\n  }\n  return 1;  /* always save in the hash table, so when FONT is changed SIZE can be updated */\n}\n\nstatic int iVboxSetAlignmentAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"ARIGHT\"))\n    ih->data->alignment = IUP_ALIGN_ARIGHT;\n  else if (iupStrEqualNoCase(value, \"ACENTER\"))\n    ih->data->alignment = IUP_ALIGN_ACENTER;\n  else if (iupStrEqualNoCase(value, \"ALEFT\"))\n    ih->data->alignment = IUP_ALIGN_ALEFT;\n  return 0;\n}\n\nstatic char* iVboxGetAlignmentAttrib(Ihandle* ih)\n{\n  char* align2str[3] = {\"ALEFT\", \"ACENTER\", \"ARIGHT\"};\n  return iupStrReturnStr(align2str[ih->data->alignment]);\n}\n\nstatic void iVboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int total_natural_width, total_natural_height;\n\n  /* calculate total children natural size */\n  int children_count = 0;\n  int children_natural_maxwidth = 0;\n  int children_natural_maxheight = 0;\n  int children_natural_height = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (ih->data->expand_children)\n      child->expand = ih->data->expand_children;\n\n    /* update child natural size first */\n    if (!(child->flags & IUP_FLOATING_IGNORE))\n      iupBaseComputeNaturalSize(child);\n\n    if (!(child->flags & IUP_FLOATING))\n    {\n      *children_expand |= child->expand;\n      children_natural_maxwidth = iupMAX(children_natural_maxwidth, child->naturalwidth);\n      children_natural_maxheight = iupMAX(children_natural_maxheight, child->naturalheight);\n      children_count++;\n    }\n  }\n\n  /* reset to max natural width and/or height if NORMALIZESIZE is defined */\n  if (ih->data->normalize_size)\n    iupNormalizeSizeBoxChild(ih, ih->data->normalize_size, children_natural_maxwidth, children_natural_maxheight);\n\n  /* must be done after normalize */\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n      children_natural_height += child->naturalheight;\n  }\n\n  /* leave room at the element for the maximum natural size of the children when is_homogeneous */\n  if (ih->data->is_homogeneous)\n    children_natural_height = children_natural_maxheight*children_count;\n\n  /* compute the Vbox contents natural size */\n  total_natural_width  = children_natural_maxwidth + 2*ih->data->margin_x;\n  total_natural_height = children_natural_height + (children_count-1)*ih->data->gap + 2*ih->data->margin_y;\n\n  /* Store to be used in iVboxCalcEmptyHeight */\n  ih->data->total_natural_size = total_natural_height;\n\n  *w = total_natural_width;\n  *h = total_natural_height;\n}\n\nstatic int iHboxCalcHomogeneousHeight(Ihandle *ih)\n{\n  Ihandle* child;\n  int homogeneous_height;\n\n  int children_count=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n      children_count++;\n  }\n  if (children_count == 0)\n    return 0;\n\n  /* equal spaces for all elements */\n  homogeneous_height = (ih->currentheight - (children_count-1)*ih->data->gap - 2*ih->data->margin_y)/children_count;\n  if (homogeneous_height < 0) homogeneous_height = 0;\n  return homogeneous_height;\n}\n\nstatic int iVboxCalcEmptyHeight(Ihandle *ih, int expand)\n{\n  /* This is the space that the child can be expanded. */\n  Ihandle* child;\n  int empty_height;\n\n  int expand_count=0;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING) && child->expand & expand)\n      expand_count++;\n  }\n  if (expand_count == 0)\n    return 0;\n\n  /* equal spaces for all expandable elements */\n  empty_height = (ih->currentheight - ih->data->total_natural_size)/expand_count;  \n  if (empty_height < 0) empty_height = 0;\n  return empty_height;\n}\n\nstatic void iVboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child;\n  int empty_h0 = 0, empty_h1 = 0, client_width;\n\n  if (ih->data->is_homogeneous)\n    ih->data->homogeneous_size = iHboxCalcHomogeneousHeight(ih);\n  else\n  {\n    ih->data->homogeneous_size = 0;\n\n    /* must calculate the space left for each control to grow inside the container */\n    /* H1 means there is an EXPAND enabled inside */\n    if (ih->expand & IUP_EXPAND_H1)\n      empty_h1 = iVboxCalcEmptyHeight(ih, IUP_EXPAND_H1);\n    /* Not H1 and H0 means that EXPAND is not enabled, but there are some IupFill inside */\n    else if (ih->expand & IUP_EXPAND_H0)\n      empty_h0 = iVboxCalcEmptyHeight(ih, IUP_EXPAND_H0);\n  }\n\n  client_width = ih->currentwidth - 2*ih->data->margin_x;\n  if (client_width<0) client_width=0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      if (ih->data->homogeneous_size)\n        iupBaseSetCurrentSize(child, client_width, ih->data->homogeneous_size, shrink);\n      else\n      {\n        int empty = (child->expand & IUP_EXPAND_H1)? empty_h1: ((child->expand & IUP_EXPAND_H0)? empty_h0: 0);\n        char* weight_str = iupAttribGet(child, \"EXPANDWEIGHT\");\n        if (weight_str)\n        {\n          float weight; \n          if (iupStrToFloat(weight_str, &weight))\n            empty = iupRound(empty * weight);\n        }\n        iupBaseSetCurrentSize(child, client_width, child->naturalheight+empty, shrink);\n      }\n    }\n    else if (!(child->flags & IUP_FLOATING_IGNORE))\n    {\n      /* update children to their own natural size */\n      iupBaseSetCurrentSize(child, child->naturalwidth, child->naturalheight, shrink);\n    }\n  }\n}\n\nstatic void iVboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int dx, client_width;\n  Ihandle* child;\n\n  x += ih->data->margin_x;\n  y += ih->data->margin_y;\n\n  client_width = ih->currentwidth - 2*ih->data->margin_x;\n  if (client_width<0) client_width=0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      if (ih->data->alignment == IUP_ALIGN_ACENTER)\n        dx = (client_width - child->currentwidth)/2;\n      else if (ih->data->alignment == IUP_ALIGN_ARIGHT)\n        dx = client_width - child->currentwidth;\n      else  /* IUP_ALIGN_ALEFT */\n        dx = 0;\n      if (dx<0) dx = 0;\n                      \n      /* update child */\n      iupBaseSetPosition(child, x+dx, y);\n\n      /* calculate next */\n      if (ih->data->homogeneous_size)\n        y += ih->data->homogeneous_size + ih->data->gap;\n      else\n        y += child->currentheight + ih->data->gap;\n    }\n  }\n}\n\n\n/******************************************************************************/\n\n\nIhandle *IupVboxv(Ihandle **children)\n{\n  return IupCreatev(\"vbox\", (void**)children);\n}\n\nIhandle *IupVbox(Ihandle* child, ...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"vbox\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIclass* iupVboxNewClass(void)\n{\n  Iclass* ic = iupBoxNewClassBase();\n\n  ic->name = \"vbox\";\n\n  /* Class functions */\n  ic->New = iupVboxNewClass;\n  ic->ComputeNaturalSize = iVboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iVboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iVboxSetChildrenPositionMethod;\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"SIZE\", iupBaseGetSizeAttrib, iVboxSetSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"RASTERSIZE\", iupBaseGetRasterSizeAttrib, iVboxSetRasterSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Vbox only */\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", iVboxGetAlignmentAttrib, iVboxSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, \"ALEFT\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  return ic;\n}\n","/** \\file\n * \\brief Zbox Control.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_layout.h\"\n\n\nenum{IZBOX_ALIGN_NORTH, IZBOX_ALIGN_SOUTH, IZBOX_ALIGN_WEST, IZBOX_ALIGN_EAST,\n     IZBOX_ALIGN_NE, IZBOX_ALIGN_SE, IZBOX_ALIGN_NW, IZBOX_ALIGN_SW,\n     IZBOX_ALIGN_ACENTER};\n\nstruct _IcontrolData \n{\n  int alignment;\n  Ihandle* value_handle;\n};\n\nstatic int iZboxCreateMethod(Ihandle* ih, void** params)\n{\n  ih->data = iupALLOCCTRLDATA();\n\n  ih->data->alignment = IZBOX_ALIGN_NW;\n\n  if (params)\n  {\n    Ihandle** iparams = (Ihandle**)params;\n    while (*iparams)\n    {\n      IupAppend(ih, *iparams);\n      iparams++;\n    }\n  }\n\n  return IUP_NOERROR;\n}\n\nstatic void iZboxChildAddedMethod(Ihandle* ih, Ihandle* child)\n{\n  if (!ih->data->value_handle)\n  {\n    IupSetAttribute(child, \"VISIBLE\", IupGetAttribute(ih, \"VISIBLE\"));\n    ih->data->value_handle = child;\n  }\n  else\n    IupSetAttribute(child, \"VISIBLE\", \"NO\");\n}\n\nstatic void iZboxChildRemovedMethod(Ihandle* ih, Ihandle* child, int pos)\n{\n  (void)pos;\n\n  if (child == ih->data->value_handle)\n  {\n    /* reset to the first child, even if it is NULL */\n    if (ih->firstchild)\n      IupSetAttribute(ih->firstchild, \"VISIBLE\", IupGetAttribute(ih, \"VISIBLE\"));\n    ih->data->value_handle = ih->firstchild;\n  }\n}\n\nstatic int iZboxSetAlignmentAttrib(Ihandle* ih, const char* value)\n{\n  if (iupStrEqualNoCase(value, \"NORTH\") || iupStrEqualNoCase(value, \"ATOP\"))\n    ih->data->alignment = IZBOX_ALIGN_NORTH;\n  else if (iupStrEqualNoCase(value, \"SOUTH\") || iupStrEqualNoCase(value, \"ABOTTOM\"))\n    ih->data->alignment = IZBOX_ALIGN_SOUTH;\n  else if (iupStrEqualNoCase(value, \"WEST\") || iupStrEqualNoCase(value, \"ALEFT\"))\n    ih->data->alignment = IZBOX_ALIGN_WEST;\n  else if (iupStrEqualNoCase(value, \"EAST\") || iupStrEqualNoCase(value, \"ARIGHT\"))\n    ih->data->alignment = IZBOX_ALIGN_EAST;\n  else if (iupStrEqualNoCase(value, \"NE\"))\n    ih->data->alignment = IZBOX_ALIGN_NE;\n  else if (iupStrEqualNoCase(value, \"SE\"))\n    ih->data->alignment = IZBOX_ALIGN_SE;\n  else if (iupStrEqualNoCase(value, \"NW\"))\n    ih->data->alignment = IZBOX_ALIGN_NW;\n  else if (iupStrEqualNoCase(value, \"SW\"))\n    ih->data->alignment = IZBOX_ALIGN_SW;\n  else if (iupStrEqualNoCase(value, \"ACENTER\"))\n    ih->data->alignment = IZBOX_ALIGN_ACENTER;\n  return 0;\n}\n\nstatic char* iZboxGetAlignmentAttrib(Ihandle* ih)\n{\n  static char* align2str[9] = {\"NORTH\", \"SOUTH\", \"WEST\", \"EAST\",\n                               \"NE\", \"SE\", \"NW\", \"SW\",\n                               \"ACENTER\"};\n  return align2str[ih->data->alignment];\n}\n\nstatic int iZboxSetValueHandleAttrib(Ihandle* ih, const char* value)\n{\n  int visible;\n  Ihandle* old_handle, *new_handle, *child;\n\n  new_handle = (Ihandle*)value;\n  if (!iupObjectCheck(new_handle))\n    return 0;\n\n  old_handle = ih->data->value_handle;\n  if (!iupObjectCheck(old_handle))\n    old_handle = NULL;\n\n  if (old_handle == new_handle)\n    return 0;\n\n  visible = IupGetInt(ih, \"VISIBLE\");\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (child == new_handle) /* found child */\n    {\n      if (old_handle && old_handle != new_handle)\n        IupSetAttribute(old_handle, \"VISIBLE\", \"NO\");\n\n      IupSetAttribute(new_handle, \"VISIBLE\", visible? \"YES\": \"NO\");\n      ih->data->value_handle = new_handle;\n      return 0;\n    }\n  }\n \n  return 0;\n}\n\nstatic char* iZboxGetValueHandleAttrib(Ihandle* ih)\n{\n  return (char*)(ih->data->value_handle);\n}\n\nstatic int iZboxSetValuePosAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle* child;\n  int pos, i;\n\n  if (!iupStrToInt(value, &pos))\n    return 0;\n\n  for (i=0, child=ih->firstchild; child; child = child->brother, i++)\n  {\n    if (i == pos) /* found child */\n    {\n      iZboxSetValueHandleAttrib(ih, (char*)child);\n      return 0;\n    }\n  }\n \n  return 0;\n}\n\nstatic char* iZboxGetValuePosAttrib(Ihandle* ih)\n{\n  Ihandle* child;\n  int pos;\n\n  if (!iupObjectCheck(ih->data->value_handle))\n    return NULL;\n\n  for (pos=0, child = ih->firstchild; child; child = child->brother, pos++)\n  {\n    if (child == ih->data->value_handle) /* found child */\n      return iupStrReturnInt(pos);\n  }\n\n  return NULL;\n}\n\nstatic int iZboxSetValueAttrib(Ihandle* ih, const char* value)\n{\n  Ihandle *new_handle;\n\n  if (!value)\n    return 0;\n\n  new_handle = IupGetHandle(value);\n  if (!new_handle)\n    return 0;\n\n  iZboxSetValueHandleAttrib(ih, (char*)new_handle);\n\n  return 0;\n}\n\nstatic char* iZboxGetValueAttrib(Ihandle* ih)\n{\n  Ihandle* child;\n  int pos;\n\n  if (!iupObjectCheck(ih->data->value_handle))\n    return NULL;\n\n  for (pos=0, child = ih->firstchild; child; child = child->brother, pos++)\n  {\n    if (child == ih->data->value_handle) /* found child, just cheking */\n      return IupGetName(ih->data->value_handle);\n  }\n\n  return NULL;\n}\n\nstatic int iZboxSetVisibleAttrib(Ihandle* ih, const char* value)\n{\n  if (iupObjectCheck(ih->data->value_handle))\n    IupSetAttribute(ih->data->value_handle, \"VISIBLE\", (char*)value);\n  return 1;  /* must be 1 to mark when set at the element */\n}\n\nstatic void iZboxComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)\n{\n  Ihandle* child;\n  int children_naturalwidth, children_naturalheight;\n\n  /* calculate total children natural size (even for hidden children) */\n  children_naturalwidth = 0;\n  children_naturalheight = 0;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    /* update child natural size first */\n    if (!(child->flags & IUP_FLOATING_IGNORE))\n      iupBaseComputeNaturalSize(child);\n\n    if (!(child->flags & IUP_FLOATING))\n    {\n      *children_expand |= child->expand;\n      children_naturalwidth = iupMAX(children_naturalwidth, child->naturalwidth);\n      children_naturalheight = iupMAX(children_naturalheight, child->naturalheight);\n    }\n  }\n\n  *w = children_naturalwidth;\n  *h = children_naturalheight;\n}\n\nstatic void iZboxSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)\n{\n  Ihandle* child;\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n      iupBaseSetCurrentSize(child, ih->currentwidth, ih->currentheight, shrink);\n  }\n}\n\nstatic void iZboxSetChildrenPositionMethod(Ihandle* ih, int x, int y)\n{\n  int dx = 0, dy = 0;\n  Ihandle* child;\n\n  for (child = ih->firstchild; child; child = child->brother)\n  {\n    if (!(child->flags & IUP_FLOATING))\n    {\n      switch (ih->data->alignment)\n      {\n      case IZBOX_ALIGN_ACENTER:\n        dx=(ih->currentwidth-child->currentwidth)/2;\n        dy=(ih->currentheight-child->currentheight)/2;\n        break;\n      case IZBOX_ALIGN_NORTH:\n        dx=(ih->currentwidth-child->currentwidth)/2;\n        dy=0;\n        break;\n      case IZBOX_ALIGN_SOUTH:\n        dx=(ih->currentwidth-child->currentwidth)/2;\n        dy=ih->currentheight-child->currentheight;\n        break;\n      case IZBOX_ALIGN_WEST:\n        dx=0;\n        dy=(ih->currentheight-child->currentheight)/2;\n        break;\n      case IZBOX_ALIGN_EAST:\n        dx=ih->currentwidth-child->currentwidth;\n        dy=(ih->currentheight-child->currentheight)/2;\n        break;\n      case IZBOX_ALIGN_NE:\n        dx=ih->currentwidth-child->currentwidth;\n        dy=0;\n        break;\n      case IZBOX_ALIGN_SE:\n        dx=ih->currentwidth-child->currentwidth;\n        dy=ih->currentheight-child->currentheight;\n        break;\n      case IZBOX_ALIGN_SW:\n        dx=0;\n        dy=ih->currentheight-child->currentheight;\n        break;\n      case IZBOX_ALIGN_NW:\n      default:\n        dx=0;\n        dy=0;\n        break;\n      }\n      if (dx<0) dx = 0;\n      if (dy<0) dy = 0;\n                     \n      /* update child */\n      iupBaseSetPosition(child, x+dx, y+dy);\n    }\n  }\n}\n\n\n/******************************************************************************/\n\n\nIhandle *IupZboxv(Ihandle **children)\n{\n  return IupCreatev(\"zbox\", (void**)children);\n}\n\nIhandle *IupZbox(Ihandle* child, ...)\n{\n  Ihandle **children;\n  Ihandle *ih;\n\n  va_list arglist;\n  va_start(arglist, child);\n  children = (Ihandle **)iupObjectGetParamList(child, arglist);\n  va_end(arglist);\n\n  ih = IupCreatev(\"zbox\", (void**)children);\n  free(children);\n\n  return ih;\n}\n\nIclass* iupZboxNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"zbox\";\n  ic->format = \"g\"; /* array of Ihandle */\n  ic->nativetype = IUP_TYPEVOID;\n  ic->childtype = IUP_CHILDMANY;\n  ic->is_interactive = 0;\n\n  /* Class functions */\n  ic->New = iupZboxNewClass;\n  ic->Create = iZboxCreateMethod;\n  ic->Map = iupBaseTypeVoidMapMethod;\n  ic->ChildAdded = iZboxChildAddedMethod;\n  ic->ChildRemoved = iZboxChildRemovedMethod;\n\n  ic->ComputeNaturalSize = iZboxComputeNaturalSizeMethod;\n  ic->SetChildrenCurrentSize = iZboxSetChildrenCurrentSizeMethod;\n  ic->SetChildrenPosition = iZboxSetChildrenPositionMethod;\n\n  /* Common */\n  iupBaseRegisterCommonAttrib(ic);\n\n  /* Base Container */\n  iupClassRegisterAttribute(ic, \"EXPAND\", iupBaseContainerGetExpandAttrib, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTSIZE\", iupBaseGetCurrentSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CLIENTOFFSET\", iupBaseGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* Zbox only */\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", iZboxGetAlignmentAttrib, iZboxSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, \"NW\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE\", iZboxGetValueAttrib, iZboxSetValueAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUEPOS\", iZboxGetValuePosAttrib, iZboxSetValuePosAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE_HANDLE\", iZboxGetValueHandleAttrib, iZboxSetValueHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT | IUPAF_IHANDLE | IUPAF_NO_STRING);\n\n  /* Intercept VISIBLE since ZBOX works by showing and hidding its children */\n  iupClassRegisterAttribute(ic, \"VISIBLE\", NULL, iZboxSetVisibleAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\n  return ic;\n}\n","/** \\file\n * \\brief Button Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n#include \"iup_button.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_image.h\"\n#include \"iup_key.h\"\n\n#include \"iupemscripten_drv.h\"\n\n#include <emscripten.h>\n\n\n\n//EMSCRIPTEN_KEEPALIVE void emscriptenButtonCallbackTrampoline(int handle_id, Ihandle* ih)\n//EMSCRIPTEN_KEEPALIVE void emscriptenButtonCallbackTrampoline(int handle_id, intptr_t ih_ptr)\n//EMSCRIPTEN_KEEPALIVE void emscriptenButtonCallbackTrampoline(int handle_id, int ih_ptr)\n\n// Generate IupButton ACTION callback to feed to js\nEMSCRIPTEN_KEEPALIVE void emscriptenButtonCallbackTrampoline(int handle_id)\n{\n\tIhandle* ih = iupEmscripten_GetIhandleValueForKey(handle_id);\n  Icallback action_callback = IupGetCallback(ih, \"ACTION\");\n  if (action_callback) \n  {\n    action_callback(ih);\n\n\t\t/* if(action_callback(ih) == IUP_CLOSE) */\n\t\t/* { */\n\t\t/* \tIupExitLoop(); */\n\t\t/* } */\n  }\n\n}\n\nEMSCRIPTEN_KEEPALIVE void emscriptenButtonCallbackTrampoline_Cb(int handle_id, int but, int pressed, int x, int y, char* status) \n{\n\tIhandle* ih = iupEmscripten_GetIhandleValueForKey(handle_id);\n\n  IFniiiis button_callback = (IFniiiis)IupGetCallback(ih, \"BUTTON_CB\");\n  if (button_callback) \n  {\n    button_callback(ih, but, pressed, x, y, status);\n  }\n\n#if 0\n\tif(button_callback)\n\t{\n\t\tif(button_callback(handle_id, but, pressed, x, y, status) == IUP_CLOSE)\n\t\t{\n\t\t\tIupExitLoop();\n\t\t}\n\t}\n#endif\n}\n\nvoid iupdrvButtonAddBorders(int *x, int *y)\n{\n\n\t\n}\n\nextern int emjsButton_CreateButton(void);\nextern void emjsButton_SetTitle(int handle_id, const char* title);\n//extern void emjsButton_SetCallback(int handle_id, Ihandle* ih);\n//extern void emjsButton_SetCallback(int handle_id, intptr_t ih);\nextern void emjsButton_SetCallback(int handle_id);\n\nstatic int emscriptenButtonMapMethod(Ihandle* ih)\n{\n#if 1\n\tint button_id = 0;\n\tInativeHandle* new_handle = NULL;\n\tchar* attribute_value;\n\t// TODO: Image button\n\t// emscripten.widget.Button\n\t// emscripten.widget.ImageButton\n\tattribute_value = iupAttribGet(ih, \"IMAGE\");\n\n\tif (attribute_value && *attribute_value != 0)\n\t{\n\t\tih->data->type |= IUP_BUTTON_IMAGE;\n\t}\n\telse\n\t{\n\t\tbutton_id = emjsButton_CreateButton();\n\t\tnew_handle = (InativeHandle*)calloc(1, sizeof(InativeHandle));\n\t\tnew_handle->handleID = button_id;\n\t\tih->handle = new_handle;\n    /* emjsCommon_Alert(ih->handle); */\n\t}\n\n\t// Does ImageButton support title text?\n\tattribute_value = iupAttribGet(ih, \"TITLE\");\n\tif(attribute_value && *attribute_value!=0)  //Is the derefrenced value going to be 0 if null? \n\t{\n\t\t//TODO ask eric\n    ih->data->type |= IUP_BUTTON_TEXT;\n\t\t/*\n\t\tif(ih->data->type & IUP_BUTTON_IMAGE)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t\t*/\n\n\t\temjsButton_SetTitle(button_id, attribute_value);\n\t}\n\t\n\t//emjsButton_SetCallback(button_id, (intptr_t)ih);\n\temjsButton_SetCallback(button_id);\n\tiupEmscripten_SetIntKeyForIhandleValue(button_id, ih);\n\n\n\tiupEmscripten_AddWidgetToParent(ih);\n#endif\n\treturn IUP_NOERROR;\t\n}\n\nextern void emjsButton_DestroyButton(int handle_id);\nstatic void emscriptenButtonUnMapMethod(Ihandle* ih)\n{\n\tif(ih && ih->handle)\n\t{\n\t\tiupEmscripten_RemoveIntKeyFromIhandleMap(ih->handle->handleID);\n\t\temjsButton_DestroyButton(ih->handle->handleID);\n\t\tfree(ih->handle);\n\t\tih->handle = NULL;\n\t}\n}\n\nvoid iupdrvButtonInitClass(Iclass* ic)\n{\n\t/* Driver Dependent Class functions */\n\tic->Map = emscriptenButtonMapMethod;\n\tic->UnMap = emscriptenButtonUnMapMethod;\n\t\n\n#if 0\n\n\tic->LayoutUpdate = gtkButtonLayoutUpdateMethod;\n\t\n\t/* Driver Dependent Attribute functions */\n\t\n\t/* Overwrite Common */\n\tiupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, gtkButtonSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\t\n\t/* Overwrite Visual */\n\tiupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, gtkButtonSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n\t\n\t/* Visual */\n\tiupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkButtonSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\t\n\t/* Special */\n\tiupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkButtonSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT);\n\tiupClassRegisterAttribute(ic, \"TITLE\", NULL, gtkButtonSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\t\n\t/* IupButton only */\n\tiupClassRegisterAttribute(ic, \"ALIGNMENT\", NULL, gtkButtonSetAlignmentAttrib, \"ACENTER:ACENTER\", NULL, IUPAF_NO_INHERIT);  /* force new default value */\n\tiupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkButtonSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"IMINACTIVE\", NULL, gtkButtonSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"IMPRESS\", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\t\n\tiupClassRegisterAttribute(ic, \"PADDING\", iupButtonGetPaddingAttrib, gtkButtonSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n\tiupClassRegisterAttribute(ic, \"MARKUP\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n#endif\n\t\n}\n","/** \\file\n * \\brief Canvas Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_dialog.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_canvas.h\"\n#include \"iup_key.h\"\n\n\n\nvoid iupdrvCanvasInitClass(Iclass* ic)\n{\n#if 0\n\t/* Driver Dependent Class functions */\n\tic->Map = gtkCanvasMapMethod;\n\tic->LayoutUpdate = gtkCanvasLayoutUpdateMethod;\n\t\n\t/* Driver Dependent Attribute functions */\n\t\n\t/* Visual */\n\tiupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkCanvasSetBgColorAttrib, \"255 255 255\", NULL, IUPAF_DEFAULT);  /* force new default value */\n\t\n\t/* IupCanvas only */\n\tiupClassRegisterAttribute(ic, \"DRAWSIZE\", gtkCanvasGetDrawSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\t\n\tiupClassRegisterAttribute(ic, \"DX\", NULL, gtkCanvasSetDXAttrib, NULL, NULL, IUPAF_NO_INHERIT);  /* force new default value */\n\tiupClassRegisterAttribute(ic, \"DY\", NULL, gtkCanvasSetDYAttrib, NULL, NULL, IUPAF_NO_INHERIT);  /* force new default value */\n\tiupClassRegisterAttribute(ic, \"POSX\", iupCanvasGetPosXAttrib, gtkCanvasSetPosXAttrib, \"0\", NULL, IUPAF_NO_INHERIT);  /* force new default value */\n\tiupClassRegisterAttribute(ic, \"POSY\", iupCanvasGetPosYAttrib, gtkCanvasSetPosYAttrib, \"0\", NULL, IUPAF_NO_INHERIT);  /* force new default value */\n\t\n\tiupClassRegisterAttribute(ic, \"DRAWABLE\", gtkCanvasGetDrawableAttrib, NULL, NULL, NULL, IUPAF_NO_STRING);\n\t\n\t/* IupCanvas Windows or X only */\n#ifndef GTK_MAC\n#ifdef WIN32\n\tiupClassRegisterAttribute(ic, \"HWND\", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);\n#else\n\tiupClassRegisterAttribute(ic, \"XWINDOW\", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n\tiupClassRegisterAttribute(ic, \"XDISPLAY\", (IattribGetFunc)iupdrvGetDisplay, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n#endif\n#endif\n\t\n\t/* Not Supported */\n\tiupClassRegisterAttribute(ic, \"BACKINGSTORE\", NULL, NULL, \"YES\", NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TOUCH\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n#endif\n}\n","/** \\file\n * \\brief Clipboard for the GTK Driver.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\n/******************************************************************************/\n\nIhandle* IupClipboard(void)\n{\n  return IupCreate(\"clipboard\");\n}\n\nIclass* iupClipboardNewClass(void)\n{\n  Iclass* ic = iupClassNew(NULL);\n\n  ic->name = \"clipboard\";\n  ic->format = NULL;  /* no parameters */\n  ic->nativetype = IUP_TYPECONTROL;\n  ic->childtype = IUP_CHILDNONE;\n  ic->is_interactive = 0;\n\n  ic->New = iupClipboardNewClass;\n\n  /* Attribute functions */\n#if 0\n  iupClassRegisterAttribute(ic, \"TEXT\", gtkClipboardGetTextAttrib, gtkClipboardSetTextAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TEXTAVAILABLE\", gtkClipboardGetTextAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"NATIVEIMAGE\", gtkClipboardGetNativeImageAttrib, gtkClipboardSetNativeImageAttrib, NULL, NULL, IUPAF_NO_STRING|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkClipboardSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGEAVAILABLE\", gtkClipboardGetImageAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"ADDFORMAT\", NULL, gtkClipboardSetAddFormatAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORMAT\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORMATAVAILABLE\", gtkClipboardGetFormatAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORMATDATA\", gtkClipboardGetFormatDataAttrib, gtkClipboardSetFormatDataAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORMATDATASIZE\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n#endif\n\t\n  return ic;\n}\n","/** \\file\n * \\brief IupColorDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n\nvoid iupdrvColorDlgInitClass(Iclass* ic)\n{\n//  ic->DlgPopup = macColorDlgPopup;\n}\n","/** \\file\n * \\brief Emscripten Base Functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>              \n#include <stdlib.h>\n#include <string.h>             \n#include <limits.h>             \n#include <stdbool.h>\n#include <inttypes.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n#include \"iupkey.h\"\n\n#include \"iup_object.h\"\n#include \"iup_childtree.h\"\n#include \"iup_key.h\"\n#include \"iup_str.h\"\n#include \"iup_class.h\"\n#include \"iup_attrib.h\"\n#include \"iup_focus.h\"\n#include \"iup_key.h\"\n#include \"iup_image.h\"\n#include \"iup_drv.h\"\n\n#include \"iupemscripten_drv.h\"\n\nstatic Itable* s_integerIdToIhandleMap = NULL;\n\nvoid iupEmscripten_InitializeInternalGlobals()\n{\n\tif(!s_integerIdToIhandleMap)\n\t{\n\t\t// FIXME: Is there a place to free the memory?\n\t\ts_integerIdToIhandleMap = iupTableCreate(IUPTABLE_POINTERINDEXED);\n\t}\n} \nvoid iupEmscripten_DestroyInternalGlobals()\n{\n\n\tif(s_integerIdToIhandleMap)\n\t{\n\t\tiupTableDestroy(s_integerIdToIhandleMap);\n\t\ts_integerIdToIhandleMap = NULL;\n\t}\n}\nvoid iupEmscripten_SetIntKeyForIhandleValue(int handle_id, Ihandle* ih)\n{\n\tiupTableSet(s_integerIdToIhandleMap, (const char*)((intptr_t)handle_id), ih, IUPTABLE_POINTER);\n}\nvoid iupEmscripten_RemoveIntKeyFromIhandleMap(int handle_id)\n{\n\tiupTableRemove(s_integerIdToIhandleMap, (const char*)((intptr_t)handle_id));\n}\nIhandle* iupEmscripten_GetIhandleValueForKey(int handle_id)\n{\n\tIhandle* ih = (Ihandle*)((intptr_t)iupTableGet(s_integerIdToIhandleMap, (const char*)((intptr_t)handle_id)));\n\treturn ih;\n}\n\nextern void emjsCommon_AddWidgetToDialog(int parent_id, int child_id);\nextern void emjsCommon_AddWidgetToWidget(int parent_id, int child_id);\nvoid iupEmscripten_AddWidgetToParent(Ihandle* ih)\n{\n\tIhandle* parent_ih = iupChildTreeGetNativeParent(ih);\n\t//InativeHandle* parent_native_handle = iupChildTreeGetNativeParentHandle(ih);\n\t// No parent? Probably need to assert here.\n\tif(!parent_ih)\n\t{\n\t\treturn;\n\t}\n\n\tInativeHandle* parent_native_handle = parent_ih->handle;\n\tInativeHandle* child_handle = ih->handle;\n\n\tint parent_id = 0;\n\tint child_id = 0;\n\t_Bool parent_is_dialog = false;\n\tif(parent_native_handle)\n\t{\n\t\tparent_id = parent_native_handle->handleID;\n\t\tif(parent_ih->iclass->nativetype == IUP_TYPEDIALOG)\n\t\t{\n\t\t\tparent_is_dialog = true;\n\t\t}\n\t}\n\tif(child_handle)\n\t{\n\t\tchild_id = child_handle->handleID;\n\t}\n\t\n\tif(parent_is_dialog)\n\t{\n\t\temjsCommon_AddWidgetToDialog(parent_id, child_id);\n\t}\n\telse\n\t{\n\t\temjsCommon_AddWidgetToWidget(parent_id, child_id);\n\t}\n\n}\n\nextern void emjsCommon_SetFgColor(int handle_id, unsigned char r, unsigned char g, unsigned char b);\n  // matzy: send to JS?\n  \n\n#if 0\n  GdkRGBA rgba;\n\n  iupgdkRGBASet(&rgba, r, g, b);\n\n  gtk_widget_override_color(handle, GTK_STATE_FLAG_NORMAL, &rgba);\n  gtk_widget_override_color(handle, GTK_STATE_ACTIVE, &rgba);\n  gtk_widget_override_color(handle, GTK_STATE_PRELIGHT, &rgba);\n  \n  GtkRcStyle *rc_style;  \n  GdkColor color;\n\n  iupgdkColorSet(&color, r, g, b);\n\n  rc_style = gtk_widget_get_modifier_style(handle);  \n\n  rc_style->fg[GTK_STATE_ACTIVE] = rc_style->fg[GTK_STATE_NORMAL] = rc_style->fg[GTK_STATE_PRELIGHT] = color;\n  rc_style->text[GTK_STATE_ACTIVE] = rc_style->text[GTK_STATE_NORMAL] = rc_style->text[GTK_STATE_PRELIGHT] = color;\n\n  rc_style->color_flags[GTK_STATE_NORMAL] |= GTK_RC_TEXT | GTK_RC_FG;\n  rc_style->color_flags[GTK_STATE_ACTIVE] |= GTK_RC_TEXT | GTK_RC_FG;\n  rc_style->color_flags[GTK_STATE_PRELIGHT] |= GTK_RC_TEXT | GTK_RC_FG;\n\n  /* do not set at CHILD_CONTAINER */\n  gtk_widget_modify_style(handle, rc_style);\n#endif\n//}\n\nvoid iupdrvActivate(Ihandle* ih)\n{\n\n}\n\nvoid iupdrvReparent(Ihandle* ih)\n{\n\n\t\n}\n\n\nvoid iupdrvBaseLayoutUpdateMethod(Ihandle *ih)\n{\n\n#if 0\n\tid parent_native_handle = iupChildTreeGetNativeParentHandle(ih);\n\tNSView* parent_view = nil;\n\tif([parent_native_handle isKindOfClass:[NSWindow class]])\n\t{\n\t\tNSWindow* parent_window = (NSWindow*)parent_native_handle;\n\t\tparent_view = [parent_window contentView];\n\t}\n\telse if([parent_native_handle isKindOfClass:[NSView class]])\n\t{\n\t\tparent_view = (NSView*)parent_native_handle;\n\t}\n\telse\n\t{\n\t\tNSCAssert(1, @\"Unexpected type for parent widget\");\n\t\t@throw @\"Unexpected type for parent widget\";\n\t}\n\t\n\t\n\t\n\tid child_handle = ih->handle;\n\tNSView* the_view = nil;\n\tif([child_handle isKindOfClass:[NSView class]])\n\t{\n\t\tthe_view = (NSView*)child_handle;\n\t}\n\telse if([child_handle isKindOfClass:[CALayer class]])\n\t{\n\t\tNSCAssert(1, @\"CALayer not implemented\");\n\t\t@throw @\"CALayer not implemented\";\n\t}\n\telse\n\t{\n\t\tNSCAssert(1, @\"Unexpected type for parent widget\");\n\t\t@throw @\"Unexpected type for parent widget\";\n\t}\n\t\n\t\n//\tiupgtkNativeContainerMove((GtkWidget*)parent, widget, x, y);\n\n//\tiupgtkSetPosSize(GTK_CONTAINER(parent), widget, ih->x, ih->y, ih->currentwidth, ih->currentheight);\n\n\t/*\n\tCGSize fitting_size = [the_view fittingSize];\n\tih->currentwidth = fitting_size.width;\n\tih->currentheight = fitting_size.height;\n*/\n\t\n\tNSRect parent_rect = [parent_view frame];\n\n\tNSRect the_rect = NSMakeRect(\n\t\tih->x,\n\t\t// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.\n\t\tparent_rect.size.height - ih->y - ih->currentheight,\n\t\tih->currentwidth,\n\t\tih->currentheight\n\t);\n\t[the_view setFrame:the_rect];\n//\t[the_view setBounds:the_rect];\n\t\n\t\n#endif\n}\n\nvoid iupdrvBaseUnMapMethod(Ihandle* ih)\n{\n\t// Why do I need this when everything else has its own UnMap method?\n\t//NSLog(@\"iupdrvBaseUnMapMethod not implemented. Might be leaking\");\n}\n\nvoid iupdrvDisplayUpdate(Ihandle *ih)\n{\n\t// call ViewGroup.invalidate()\n\n}\n\nvoid iupdrvDisplayRedraw(Ihandle *ih)\n{\n\tiupdrvDisplayUpdate(ih);\n}\n\nvoid iupdrvScreenToClient(Ihandle* ih, int *x, int *y)\n{\n}\n\n\n\nint iupdrvBaseSetZorderAttrib(Ihandle* ih, const char* value)\n{\n  return 0;\n}\n\nvoid iupdrvSetVisible(Ihandle* ih, int visible)\n{\n}\n\nint iupdrvIsVisible(Ihandle* ih)\n{\n\treturn 1;\n}\n\nint iupdrvIsActive(Ihandle *ih)\n{\n  return 1;\n}\n\nvoid iupdrvSetActive(Ihandle* ih, int enable)\n{\n}\n\nchar* iupdrvBaseGetXAttrib(Ihandle *ih)\n{\n  return NULL;\n}\n\nchar* iupdrvBaseGetYAttrib(Ihandle *ih)\n{\n\n  return NULL;\n}\n\n/*\nchar* iupdrvBaseGetClientSizeAttrib(Ihandle *ih)\n{\n\n    return NULL;\n\n}\n */\n\nint iupdrvBaseSetBgColorAttrib(Ihandle* ih, const char* value)\n{\n\n\t\n\n  /* DO NOT NEED TO UPDATE GTK IMAGES SINCE THEY DO NOT DEPEND ON BGCOLOR */\n\n  return 1;\n}\n\n\nint iupdrvBaseSetFgColorAttrib(Ihandle* ih, const char* value)\n{\n  unsigned char r, g, b;\n  if (!iupStrToRGB(value, &r, &g, &b))\n    return 0;\n  emjsCommon_SetFgColor(ih->handle->handleID, r, g, b);\n\n  return 1;\n}\n\nint iupdrvBaseSetCursorAttrib(Ihandle* ih, const char* value)\n{\n\n  return 0;\n}\n\n\nint iupdrvGetScrollbarSize(void)\n{\n\n  return 0;\n}\n\nvoid iupdrvDrawFocusRect(Ihandle* ih, void* _gc, int x, int y, int w, int h)\n{\n\n}\n\nvoid iupdrvBaseRegisterCommonAttrib(Iclass* ic)\n{\n\t/*\n#ifndef GTK_MAC\n  #ifdef WIN32                                 \n    iupClassRegisterAttribute(ic, \"HFONT\", iupgtkGetFontIdAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  #else\n    iupClassRegisterAttribute(ic, \"XFONTID\", iupgtkGetFontIdAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n  #endif\n#endif\n  iupClassRegisterAttribute(ic, \"PANGOFONTDESC\", iupgtkGetPangoFontDescAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n*/\n}\n\nvoid iupdrvBaseRegisterVisualAttrib(Iclass* ic)\n{\n\t\n}\n\nvoid iupdrvClientToScreen(Ihandle* ih, int *x, int *y)\n{\n\t\n}\n\nvoid iupdrvPostRedraw(Ihandle *ih)\n{\n\n}\n\nvoid iupdrvRedrawNow(Ihandle *ih)\n{\n\n}\nvoid iupdrvSendKey(int key, int press)\n{\n\t\n}\nvoid iupdrvSendMouse(int x, int y, int bt, int status)\n{\n\t\n}\nvoid iupdrvSleep(int time)\n{\n\t\n}\nvoid iupdrvWarpPointer(int x, int y)\n{\n\t\n}\n","/** \\file\n * \\brief IupDialog class\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <time.h>\n#include <stdint.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_class.h\"\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_dlglist.h\"\n#include \"iup_attrib.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_focus.h\"\n#include \"iup_str.h\"\n#define _IUPDLG_PRIVATE\n#include \"iup_dialog.h\"\n#include \"iup_image.h\"\n#include \"iup_assert.h\"\n\n#include \"iupemscripten_drv.h\"\n#include <emscripten.h>\n\n\n/****************************************************************\n Utilities\n ****************************************************************/\n\nint iupdrvDialogIsVisible(Ihandle* ih)\n{\n//\treturn iupdrvIsVisible(ih);\n\treturn 1;\n}\n\n\nvoid iupdrvDialogGetSize(Ihandle* ih, InativeHandle* handle, int *w, int *h)\n{\n\t\n\tif (w) *w = 1280;\n\tif (h) *h = 720;\n}\n\nvoid iupdrvDialogSetVisible(Ihandle* ih, int visible)\n{\n\n\tif(visible)\n\t{\n\n\t}\n\telse\n\t{\n\n\t}\n}\n\nvoid iupdrvDialogGetPosition(Ihandle *ih, InativeHandle* handle, int *x, int *y)\n{\n\t\n\tif (x) *x = 0;\n\t//if (y) *y = iupEmscriptenComputeIupScreenHeightFromCartesian(the_rect.origin.y);\n\tif (y) *y = 0;\n}\n\nvoid iupdrvDialogSetPosition(Ihandle *ih, int x, int y)\n{\n}\n\n\nvoid iupdrvDialogGetDecoration(Ihandle* ih, int *border, int *caption, int *menu)\n{\n}\n\nint iupdrvDialogSetPlacement(Ihandle* ih)\n{\n\t\n#if 0\n\tchar* placement;\n\t\n\tNSWindow* the_window = (NSWindow*)ih->handle;\n\tNSRect the_rect = [the_window frame];\n\t\n\t\n\tint old_state = ih->data->show_state;\n\tih->data->show_state = IUP_SHOW;\n\t\n\tif (iupAttribGetBoolean(ih, \"FULLSCREEN\"))\n\t{\n\n\t\tNSUInteger masks = [the_window styleMask];\n\t\tif ( masks & NSFullScreenWindowMask)\n\t\t{\n\t\t\t// Do something\n\t\t}\n\t\telse\n\t\t{\n\t\t\t[the_window toggleFullScreen:nil];\n\t\t}\n\t\t\n\t\t\n\t\treturn 1;\n\t}\n\t\n\tplacement = iupAttribGet(ih, \"PLACEMENT\");\n\tif (!placement)\n\t{\n\t\tif (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)\n\t\t\tih->data->show_state = IUP_RESTORE;\n\t\t\n//\t\tgtk_window_unmaximize((GtkWindow*)ih->handle);\n//\t\tgtk_window_deiconify((GtkWindow*)ih->handle);\n\t\treturn 0;\n\t}\n\t\n\tif (iupStrEqualNoCase(placement, \"MINIMIZED\"))\n\t{\n//\t\tih->data->show_state = IUP_MINIMIZE;\n//\t\tgtk_window_iconify((GtkWindow*)ih->handle);\n\t}\n\telse if (iupStrEqualNoCase(placement, \"MAXIMIZED\"))\n\t{\n//\t\tih->data->show_state = IUP_MAXIMIZE;\n//\t\tgtk_window_maximize((GtkWindow*)ih->handle);\n\t}\n\telse if (iupStrEqualNoCase(placement, \"FULL\"))\n\t{\n#if 0\n\t\tint width, height, x, y;\n\t\tint border, caption, menu;\n\t\tiupdrvDialogGetDecoration(ih, &border, &caption, &menu);\n\t\t\n\t\t/* position the decoration outside the screen */\n\t\tx = -(border);\n\t\ty = -(border+caption+menu);\n\t\t\n\t\t/* the dialog client area will cover the task bar */\n\t\tiupdrvGetFullSize(&width, &height);\n\t\t\n\t\theight += menu; /* menu is inside the client area. */\n\t\t\n\t\t/* set the new size and position */\n\t\t/* The resize evt will update the layout */\n\t\tgtk_window_move((GtkWindow*)ih->handle, x, y);\n\t\tgtk_window_resize((GtkWindow*)ih->handle, width, height);\n\t\t\n\t\tif (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)\n\t\t\tih->data->show_state = IUP_RESTORE;\n#endif\n\t}\n\t\n\tiupAttribSet(ih, \"PLACEMENT\", NULL); /* reset to NORMAL */\n\t\n#endif\n\n\n\treturn 1;\n}\n\n\n/****************************************************************\n Callbacks and Events\n ****************************************************************/\n\nstatic int emscriptenDialogSetTitleAttrib(Ihandle* ih, const char* value)\n{\n\t\n\treturn 1;\n}\n\nextern int emjsDialog_CreateDialog(char* window_name, int width, int height);\nstatic int emscriptenDialogMapMethod(Ihandle* ih)\n{\n\n\tchar* window_title = NULL;\n\tint width = 0;\n\tint height = 0;\n\t\n\twindow_title = iupAttribGet(ih, \"TITLE\");\n\n\tint dialog_id = emjsDialog_CreateDialog(window_title, width, height);\n\tInativeHandle* new_handle = (InativeHandle*)calloc(1, sizeof(InativeHandle));\n\tnew_handle->handleID = dialog_id;\n\tih->handle = new_handle;\n\t\n//\tiupAttribSet(ih, \"RASTERSIZE\", \"500x400\");\n\t\n\n//\tih->currentwidth = 200;\n//\tih->currentheight = 200;\n\n\treturn IUP_NOERROR;\n\n}\n\nextern void emjsDialog_DestroyDialog(int handle_id);\nstatic void emscriptenDialogUnMapMethod(Ihandle* ih)\n{\n\tif(ih && ih->handle)\n\t{\n\t\temjsDialog_DestroyDialog(ih->handle->handleID);\n\t\tfree(ih->handle);\n\t\tih->handle = NULL;\n\t}\n}\n\nstatic void emscriptenDialogLayoutUpdateMethod(Ihandle* ih)\n{\n#if 0\n\tif (ih->data->ignore_resize)\n\t\treturn;\n\t\n\tih->data->ignore_resize = 1;\n\t\n\t/* for dialogs the position is not updated here */\n\tSetWindowPos(ih->handle, 0, 0, 0, ih->currentwidth, ih->currentheight,\n\t\t\t\t SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOSENDCHANGING);\n\t\n\tih->data->ignore_resize = 0;\n#endif\n\t\n\n}\n\n\n\nvoid iupdrvDialogInitClass(Iclass* ic)\n{\n\t/* Driver Dependent Class methods */\n\tic->Map = emscriptenDialogMapMethod;\n\tic->UnMap = emscriptenDialogUnMapMethod;\n\tic->LayoutUpdate = emscriptenDialogLayoutUpdateMethod;\n\n#if 0\n\tic->LayoutUpdate = gtkDialogLayoutUpdateMethod;\n\tic->GetInnerNativeContainerHandle = gtkDialogGetInnerNativeContainerHandleMethod;\n\tic->SetChildrenPosition = gtkDialogSetChildrenPositionMethod;\n\t\n\t/* Callback Windows and GTK Only */\n\tiupClassRegisterCallback(ic, \"TRAYCLICK_CB\", \"iii\");\n\t\n\t/* Driver Dependent Attribute functions */\n#ifndef GTK_MAC\n#ifdef WIN32\n\tiupClassRegisterAttribute(ic, \"HWND\", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);\n#else\n\tiupClassRegisterAttribute(ic, \"XWINDOW\", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_NO_STRING);\n#endif\n#endif\n\t\n\t/* Visual */\n\tiupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, \"DLGBGCOLOR\", NULL, IUPAF_DEFAULT);  /* force new default value */\n\t\n\t/* Base Container */\n\tiupClassRegisterAttribute(ic, \"CLIENTSIZE\", gtkDialogGetClientSizeAttrib, iupDialogSetClientSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);  /* dialog is the only not read-only */\n\tiupClassRegisterAttribute(ic, \"CLIENTOFFSET\", gtkDialogGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);\n#endif\n\t\n\t\n\t/* Special */\n\tiupClassRegisterAttribute(ic, \"TITLE\", NULL, emscriptenDialogSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\t\n\t\n#if 0\n\t/* IupDialog only */\n\tiupClassRegisterAttribute(ic, \"BACKGROUND\", NULL, gtkDialogSetBackgroundAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"ICON\", NULL, gtkDialogSetIconAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"FULLSCREEN\", NULL, gtkDialogSetFullScreenAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MINSIZE\", NULL, gtkDialogSetMinSizeAttrib, IUPAF_SAMEASSYSTEM, \"1x1\", IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MAXSIZE\", NULL, gtkDialogSetMaxSizeAttrib, IUPAF_SAMEASSYSTEM, \"65535x65535\", IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"SAVEUNDER\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);  /* saveunder not supported in GTK */\n\t\n\t/* IupDialog Windows and GTK Only */\n\tiupClassRegisterAttribute(ic, \"ACTIVEWINDOW\", gtkDialogGetActiveWindowAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TOPMOST\", NULL, gtkDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"DIALOGHINT\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n#if GTK_CHECK_VERSION(2, 12, 0)\n\tiupClassRegisterAttribute(ic, \"OPACITY\", NULL, gtkDialogSetOpacityAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"OPACITYIMAGE\", NULL, gtkDialogSetOpacityImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n#endif\n#if GTK_CHECK_VERSION(2, 10, 0)\n\tiupClassRegisterAttribute(ic, \"TRAY\", NULL, gtkDialogSetTrayAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TRAYIMAGE\", NULL, gtkDialogSetTrayImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TRAYTIP\", NULL, gtkDialogSetTrayTipAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TRAYTIPMARKUP\", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_MAPPED);\n#endif\n\t\n\t/* Not Supported */\n\tiupClassRegisterAttribute(ic, \"BRINGFRONT\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"COMPOSITED\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NOT_MAPPED);\n\tiupClassRegisterAttribute(ic, \"CONTROL\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"HELPBUTTON\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"TOOLBOX\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MDIFRAME\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MDICLIENT\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MDIMENU\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"MDICHILD\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n#endif\n\t\n}\n","/** \\file\n * \\brief GTK Drag&Drop Functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>              \n#include <stdlib.h>\n#include <string.h>             \n#include <limits.h>             \n\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_str.h\"\n#include \"iup_class.h\"\n#include \"iup_attrib.h\"\n#include \"iup_drv.h\"\n#include \"iup_key.h\"\n#include \"iup_image.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\nvoid iupdrvRegisterDragDropAttrib(Iclass* ic)\n{\n#if 0\n  iupClassRegisterCallback(ic, \"DROPFILES_CB\", \"siii\");\n\n  iupClassRegisterCallback(ic, \"DRAGBEGIN_CB\", \"ii\");\n  iupClassRegisterCallback(ic, \"DRAGDATASIZE_CB\", \"s\");\n  iupClassRegisterCallback(ic, \"DRAGDATA_CB\", \"sCi\");\n  iupClassRegisterCallback(ic, \"DRAGEND_CB\", \"i\");\n  iupClassRegisterCallback(ic, \"DROPDATA_CB\", \"sCiii\");\n  iupClassRegisterCallback(ic, \"DROPMOTION_CB\", \"iis\");\n\n  iupClassRegisterAttribute(ic, \"DRAGTYPES\",  NULL, gtkSetDragTypesAttrib,  NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DROPTYPES\",  NULL, gtkSetDropTypesAttrib,  NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DRAGSOURCE\", NULL, gtkSetDragSourceAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DROPTARGET\", NULL, gtkSetDropTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DRAGSOURCEMOVE\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"DRAGDROP\", NULL, gtkSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DROPFILESTARGET\", NULL, gtkSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n#endif\n\t\n}\n\n","/** \\file\n * \\brief Draw Functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n\n\n#include \"iup.h\"\n\n#include \"iup_attrib.h\"\n#include \"iup_class.h\"\n#include \"iup_str.h\"\n#include \"iup_object.h\"\n#include \"iup_image.h\"\n#include \"iup_draw.h\"\n\n\n\nIdrawCanvas* iupDrawCreateCanvas(Ihandle* ih)\n{\n\n\treturn NULL;\n}\n\nvoid iupDrawKillCanvas(IdrawCanvas* dc)\n{\n\n\t\n}\n\nvoid iupDrawUpdateSize(IdrawCanvas* dc)\n{\n\n}\n\n//void iupdrvDrawFocusRect(Ihandle* ih, void* _gc, int x, int y, int w, int h);\n\nvoid iupDrawFlush(IdrawCanvas* dc)\n{\n\n}\n\nvoid iupDrawGetSize(IdrawCanvas* dc, int *w, int *h)\n{\n//\tif (w) *w = dc->w;\n//\tif (h) *h = dc->h;\n}\n\nvoid iupDrawParentBackground(IdrawCanvas* dc)\n{\n\n}\n\nvoid iupDrawRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, unsigned char r, unsigned char g, unsigned char b, int style)\n{\n\n}\n\nvoid iupDrawLine(IdrawCanvas* dc, int x1, int y1, int x2, int y2, unsigned char r, unsigned char g, unsigned char b, int style)\n{\n}\n\nvoid iupDrawArc(IdrawCanvas* dc, int x1, int y1, int x2, int y2, double a1, double a2, unsigned char r, unsigned char g, unsigned char b, int style)\n{\n\n}\n\nvoid iupDrawPolygon(IdrawCanvas* dc, int* points, int count, unsigned char r, unsigned char g, unsigned char b, int style)\n{\n\n}\n\nvoid iupDrawSetClipRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)\n{\n\n}\n\nvoid iupDrawResetClip(IdrawCanvas* dc)\n{\n}\n\nvoid iupDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, unsigned char r, unsigned char g, unsigned char b, const char* font)\n{\n\n}\n\nvoid iupDrawImage(IdrawCanvas* dc, const char* name, int make_inactive, int x, int y, int *img_w, int *img_h)\n{\n}\n\nvoid iupDrawSelectRect(IdrawCanvas* dc, int x, int y, int w, int h)\n{\n\n}\n\nvoid iupDrawFocusRect(IdrawCanvas* dc, int x, int y, int w, int h)\n{\n}\n\n\n","/** \\file\n * \\brief IupFileDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_dialog.h\"\n#include \"iup_strmessage.h\"\n#include \"iup_array.h\"\n#include \"iup_drvinfo.h\"\n\n#include \"iupemscripten_drv.h\"\n\n#define MAX_FILENAME_SIZE PATH_MAX\n#define IUP_PREVIEWCANVAS 3000\n\nenum {IUP_DIALOGOPEN, IUP_DIALOGSAVE, IUP_DIALOGDIR};\n                           \n\n\n\nvoid iupdrvFileDlgInitClass(Iclass* ic)\n{\n//  ic->DlgPopup = emscriptenFileDlgPopup;\n\n  iupClassRegisterAttribute(ic, \"EXTFILTER\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FILTERINFO\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FILTERUSED\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MULTIPLEFILES\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n}\n","/** \\file\n * \\brief MAC Focus\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdio.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_focus.h\"\n#include \"iup_attrib.h\"\n#include \"iup_drv.h\"\n#include \"iup_assert.h\" \n#include \"iup_drv.h\" \n\n#include \"iupemscripten_drv.h\"\n\n\nvoid iupdrvSetFocus(Ihandle *ih)\n{               \n\t\n}\n\nvoid iupmacFocusInOutEvent(Ihandle *ih)\n{\n}\n\n","/** \\file\n * \\brief MAC Font mapping\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n\n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_array.h\"\n#include \"iup_attrib.h\"\n#include \"iup_object.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_assert.h\"\n\n//#include \"iupmac_info.h\"\n\n\n\nchar* iupdrvGetSystemFont(void)\n{\n  static char systemfont[200] = \"\";\n#if 0\n  NSFont *font = [NSFont systemFontOfSize:0];\n\tNSLog(@\"systemfont: %@\", font);\n  char *name = [[font familyName] UTF8String];\n  if(*name)\n    strcpy(systemfont,name);\n  else\n    strcpy(systemfont, \"Tahoma, 10\");\n#endif\n  return systemfont;\n}\n\n\nint iupdrvSetStandardFontAttrib(Ihandle* ih, const char* value)\n{\n#if 0 // iupBaseUpdateSizeFromFont missing\n  ImacFont* macfont = macFontCreateNativeFont(ih, value);\n  if (!macfont)\n    return 1;\n\n\t/* If FONT is changed, must update the SIZE attribute */\n\tiupBaseUpdateAttribFromFont(ih);\n\n  /* FONT attribute must be able to be set before mapping, \n      so the font is enable for size calculation. */\n  if (ih->handle && (ih->iclass->nativetype != IUP_TYPEVOID)) {\n\t\n  }\n#endif\n  return 1;\n}\n\nvoid iupdrvFontGetMultiLineStringSize(Ihandle* ih, const char* str, int *w, int *h)\n{\n\t   return;\n\n//  if (w) *w = max_w;\n//\tif (h) *h = max_h;\n}\n\nint iupdrvFontGetStringWidth(Ihandle* ih, const char* str)\n{\n\t\n\treturn 40;\n\t\n}\n\nvoid iupdrvFontGetCharSize(Ihandle* ih, int *charwidth, int *charheight)\n{\n\n//  if (charwidth)  *charwidth = macfont->charwidth; \n//  if (charheight) *charheight = macfont->charheight;\n}\n\nvoid iupdrvFontInit(void)\n{\n}\n\nvoid iupdrvFontFinish(void)\n{\n}\n","/** \\file\n * \\brief IupFontDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <string.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_dialog.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\nvoid iupdrvFontDlgInitClass(Iclass* ic)\n{\n//  ic->DlgPopup = macFontDlgPopup;\n}\n","/** \\file\n * \\brief Frame Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_dialog.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_frame.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\nstatic int emscriptenFrameMapMethod(Ihandle* ih)\n{\n\n#if 0\n//\tNSBox* the_frame = [[NSBox alloc] initWithFrame:NSZeroRect];\n\tNSBox* the_frame = [[NSBox alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];\n\n\t{\n\t\tchar* title;\n\t\ttitle = iupAttribGet(ih, \"TITLE\");\n\t\tif(title && *title!=0)\n\t\t{\n\t\t\tNSString* ns_string = [NSString stringWithUTF8String:title];\n\t\t\t[the_frame setTitle:ns_string];\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tih->handle = the_frame;\n\t\n\t\n\t\n\tiupemscriptenAddToParent(ih);\n\t\n#endif\n\n\t\n\treturn IUP_NOERROR;\n}\n\n\nstatic void emscriptenFrameUnMapMethod(Ihandle* ih)\n{\n#if 0\n\tid the_frame = ih->handle;\n\t[the_frame release];\n\tih->handle = nil;\n#endif\n\t\n}\n\n\n\nvoid iupdrvFrameGetDecorOffset(int *x, int *y)\n{\n\t*x = 2;\n\t*y = 2;\n}\n\nint iupdrvFrameHasClientOffset(void)\n{\n\treturn 0;\n}\n\n\n\nvoid iupdrvFrameInitClass(Iclass* ic)\n{\n\t/* Driver Dependent Class functions */\n\tic->Map = emscriptenFrameMapMethod;\n\tic->UnMap = emscriptenFrameUnMapMethod;\n#if 0\n\tic->GetInnerNativeContainerHandle = gtkFrameGetInnerNativeContainerHandleMethod;\n\t\n\t/* Driver Dependent Attribute functions */\n\t\n\t/* Overwrite Common */\n\tiupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, gtkFrameSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\t\n\t/* Visual */\n\tiupClassRegisterAttribute(ic, \"BGCOLOR\", iupFrameGetBgColorAttrib, gtkFrameSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\tiupClassRegisterAttribute(ic, \"SUNKEN\", NULL, gtkFrameSetSunkenAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n\t\n\t/* Special */\n\tiupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkFrameSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT);\n\tiupClassRegisterAttribute(ic, \"TITLE\", NULL, gtkFrameSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n#endif\n}\n","/** \\file\n * \\brief MAC Driver iupdrvSetGlobal\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_strmessage.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\nint iupdrvSetGlobal(const char *name, const char *value)\n{\n  if (iupStrEqual(name, \"LANGUAGE\"))\n  {\n    iupStrMessageUpdateLanguage(value);\n    return 1;\n  }\n  if (iupStrEqual(name, \"CURSORPOS\"))\n  {\n/*\t  \n    int x, y;\n    if (iupStrToIntInt(value, &x, &y, 'x') == 2) {\n\t  CGEventRef event=CGEventCreateMouseEvent(NULL,kCGEventMouseMoved,CGPointMake(x,y),0);\n\t  CGEventPost(kCGSessionEventTap, event);\n\t  CFRelease(event);\n\t}\n*/\t\n    return 0;\n  }\n  if (iupStrEqual(name, \"UTF8AUTOCONVERT\"))\n  {\n/*\n    if (!value || iupStrBoolean(value))\n      iupmac_utf8autoconvert = 1;\n    else\n      iupmac_utf8autoconvert = 0;\n*/\n  \t  return 0;\n  }\n  if (iupStrEqual(name, \"KEYPRESS\"))\n  {\n/*\t  \n    int key;\n    if (iupStrToInt(value, &key))\n      macGlobalSendKey(key, 0x01);\n*/\n    return 0;\n  }\n  if (iupStrEqual(name, \"KEYRELEASE\"))\n  {\n/*\n    int key;\n    if (iupStrToInt(value, &key))\n      macGlobalSendKey(key, 0x02);\n*/\n    return 0;\n  }\n  if (iupStrEqual(name, \"KEY\"))\n  {\n/*\n    int key;\n    if (iupStrToInt(value, &key))\n      macGlobalSendKey(key, 0x03);\n*/\n    return 0;\n  }\n  return 1;\n}\n\nchar *iupdrvGetGlobal(const char *name)\n{\n#if 0\n  if (iupStrEqual(name, \"CURSORPOS\"))\n  {\n    char *str = iupStrGetMemory(50);\n    int x, y;\n    iupdrvGetCursorPos(&x, &y);\n    sprintf(str, \"%dx%d\", (int)x, (int)y);\n    return str;\n  }\n  if (iupStrEqual(name, \"SHIFTKEY\"))\n  {\n    char key[5];\n    iupdrvGetKeyState(key);\n    if (key[0] == 'S')\n      return \"ON\";\n    else\n      return \"OFF\";\n  }\n  if (iupStrEqual(name, \"CONTROLKEY\"))\n  {\n    char key[5];\n    iupdrvGetKeyState(key);\n    if (key[1] == 'C')\n      return \"ON\";\n    else\n      return \"OFF\";\n  }\n  if (iupStrEqual(name, \"MODKEYSTATE\"))\n  {\n    char *str = iupStrGetMemory(5);\n    iupdrvGetKeyState(str);\n    return str;\n  }\n  if (iupStrEqual(name, \"SCREENSIZE\"))\n  {\n    char *str = iupStrGetMemory(50);\n    int w, h;\n    iupdrvGetScreenSize(&w, &h);\n    sprintf(str, \"%dx%d\", w, h);\n    return str;\n  }\n  if (iupStrEqual(name, \"FULLSIZE\"))\n  {\n    char *str = iupStrGetMemory(50);\n    int w, h;\n    iupdrvGetFullSize(&w, &h);\n    sprintf(str, \"%dx%d\", w, h);\n    return str;\n  }\n  if (iupStrEqual(name, \"SCREENDEPTH\"))\n  {\n    char *str = iupStrGetMemory(50);\n    int bpp = iupdrvGetScreenDepth();\n    sprintf(str, \"%d\", bpp);\n    return str;\n  }\n  if (iupStrEqual(name, \"VIRTUALSCREEN\"))\n  {\n    char *str = iupStrGetMemory(50);\n\tint x=0,y=0,w,h;\n    iupdrvGetFullSize(&w, &h);\n    sprintf(str, \"%d %d %d %d\", x, y, w, h);\n    return str;\n  }\n  if (iupStrEqual(name, \"MONITORSINFO\"))\n  {\n    int i;\n\tNSArray* arr = [NSScreen screens];\n\tint monitors_count = [arr count];\n    char *str = iupStrGetMemory(monitors_count*50);\n    char* pstr = str;\n\tNSRect frame;\n\n\t  for(NSScreen* screen in arr)\n\t  {\n      frame = [screen frame];\n      pstr += sprintf(pstr, \"%d %d %d %d\\n\", frame.origin.x, frame.origin.y, frame.size.width, frame.size.height);\n    }\n\n    return str;\n  }\n  if (iupStrEqual(name, \"TRUECOLORCANVAS\"))\n  {\n    if (iupdrvGetScreenDepth() > 8)\n      return \"YES\";\n    else\n      return \"NO\";\n  }\n  if (iupStrEqual(name, \"UTF8AUTOCONVERT\"))\n  {\n    if (iupmac_utf8autoconvert)\n      return \"YES\";\n    else\n      return \"NO\";\n  }\n#endif\n  return NULL;\n}\n","/** \\file\n * \\brief MAC Driver IupHelp\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n\nint IupHelp(const char *url)\n{\n#if 0\n  char *cmd;\n  int ret;\n  char *browser = getenv(\"IUP_HELPAPP\");\n  if (!browser) \n    browser = IupGetGlobal(\"HELPAPP\");\n    \n  if (!browser) \n  { \n    char* system = IupGetGlobal(\"SYSTEM\"); \n    if (iupStrEqualNoCase(system, \"Snow Leopard\") ||\n        iupStrEqualNoCase(system, \"Leopard\") ||\n        iupStrEqualNoCase(system, \"Tiger\") ||\n        iupStrEqualNoCase(system, \"Panther\"))\n      browser = \"safari\";\n    else if (iupStrEqualNoCase(system, \"Jaguar\") ||\n        iupStrEqualNoCase(system, \"Puma\") ||\n        iupStrEqualNoCase(system, \"Cheetah\"))\n      browser = \"iexplore\";\t  \n    else  /* MacOS */\n      browser = \"netscape\";\n  }\n  \n  cmd = (char*)malloc(sizeof(char)*(strlen(url)+strlen(browser)+3));\n  sprintf(cmd, \"open -a %s %s &\", browser, url);\n  ret = system(cmd); \n  free(cmd);\n  if (ret == -1)\n    return -1;\n#endif\n  return 1;\n}\n","/** \\file\n * \\brief Image Resource.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n/* Adapted from SDL (zlib)\n * Calculate the pad-aligned scanline width of a surface\n */\nstatic int CalculateBytesPerRow(int width, int bytes_per_pixel)\n{\n\tint pitch;\n\tint bits_per_pixel = bytes_per_pixel * 8;\n\t/* Surface should be 4-byte aligned for speed */\n\tpitch = width * bytes_per_pixel;\n\tswitch (bits_per_pixel) {\n\t\tcase 1:\n\t\t\tpitch = (pitch + 7) / 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpitch = (pitch + 1) / 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tpitch = (pitch + 3) & ~3;   /* 4-byte aligning */\n\treturn (pitch);\n}\n\nstatic int CalculateRowLength(int width, int bytes_per_pixel)\n{\n\tint pitch = CalculateBytesPerRow(width, bytes_per_pixel);\n\treturn pitch/bytes_per_pixel;\n}\n\n\n// FIXME: Carried over implementation. Probably wrong. Untested, don't know what calls this, don't know how to test.\nvoid iupdrvImageGetRawData(void* handle, unsigned char* imgdata)\n{\n#if 0\n  int x,y;\n  unsigned char *red,*green,*blue,*alpha;\n  NSImage *image = (__bridge NSImage*)handle;\n  NSBitmapImageRep *bitmap = nil;\n  if([[image representations] count]>0) bitmap = [[image representations] objectAtIndex:0];\n  if(bitmap==nil) return;\n\tNSInteger w = [bitmap pixelsWide];\n  NSInteger h = [bitmap pixelsHigh];\n  NSInteger bpp = [bitmap bitsPerPixel];\n  NSInteger planesize = w*h;\n  unsigned char *bits = [bitmap bitmapData]; \n  red = imgdata;\n  green = imgdata+planesize;\n  blue = imgdata+2*planesize;\n  alpha = imgdata+3*planesize;\n  for(y=0;y<h;y++) {\n    for(x=0;x<w;x++) {\n      if(bpp>=24) {\n        *red++ = *bits++;\n        *green++ = *bits++;\n        *blue++ = *bits++;\n      }\n      if(bpp==32) {\n        *alpha++ = *bits++;\n      }\n    }\n  }\n#endif\n}\n\n// FIXME: Carried over implementation. Probably wrong. Untested, don't know what calls this, don't know how to test.\nvoid* iupdrvImageCreateImageRaw(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)\n{\n#if 0\n  int x,y;\n  unsigned char *red,*green,*blue,*alpha;\n  void *theArray[1];\n  unsigned char *pixels = malloc(width*height*bpp);\n  theArray[0] = (void*)pixels;\n  int planesize = width*height;\n  red = imgdata;\n  green = imgdata+planesize;\n  blue = imgdata+2*planesize;\n  alpha = imgdata+3*planesize;\n  for(y=0;y<height;y++){\n    for(x=0;x<width;x++) {\n      *pixels++ = *red++;\n      *pixels++ = *green++;\n      *pixels++ = *blue++;\n      if(bpp==32)\n        *pixels++ = *alpha;\n    }\n  }\n\tNSBitmapImageRep* theRep;\n\t\nif(bpp==32)\n{\n theRep=[[NSBitmapImageRep alloc] initWithBitmapDataPlanes:(unsigned char **)&theArray\n\t\t\tpixelsWide:width pixelsHigh:height bitsPerSample:8\n\t\t\t\tsamplesPerPixel:4 hasAlpha:YES isPlanar:NO\n\t\t\t\tcolorSpaceName:NSDeviceRGBColorSpace bytesPerRow:0\n\t\t\t\tbitsPerPixel:bpp];\n}\nelse\n{\n\ttheRep=[[NSBitmapImageRep alloc] initWithBitmapDataPlanes:(unsigned char **)&theArray\n\t\t\t\t\t\t\t\t\t\t\t\t   pixelsWide:width pixelsHigh:height bitsPerSample:8\n\t\t\t\t\t\t\t\t\t\t\t  samplesPerPixel:3 hasAlpha:NO isPlanar:NO\n\t\t\t\t\t\t\t\t\t\t\t   colorSpaceName:NSDeviceRGBColorSpace bytesPerRow:0\n\t\t\t\t\t\t\t\t\t\t\t\t bitsPerPixel:bpp];\n}\n  NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize(width,height)];\n  [image addRepresentation:theRep];\n  return (void*)CFBridgingRetain(image);\n#endif\n  return NULL;\n}\n\nint iupdrvImageGetRawInfo(void* handle, int *w, int *h, int *bpp, iupColor* colors, int *colors_count)\n{\n  /* How to get the pallete? */\n  (void)colors;\n  (void)colors_count;\n  return iupdrvImageGetInfo(handle, w, h, bpp);\n}\n\n\n// NOTE: Returns an autoreleased NSImage.\nvoid* iupdrvImageCreateImage(Ihandle *ih, const char* bgcolor, int make_inactive)\n{\n#if 0\n  int y, x, bpp, bgcolor_depend = 0,\n      width = ih->currentwidth,\n      height = ih->currentheight;\n  unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, \"WID\");\n  unsigned char bg_r=0, bg_g=0, bg_b=0;\n  bpp = iupAttribGetInt(ih, \"BPP\");\n  iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);\n\n  NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize(width,height)];\n  if (!image)\n  {\n    return NULL;\n  }\n\t\n\tNSBitmapImageRep* bitmap_image = nil;\n\n\t\n\tif(32 == bpp)\n\t{\n\t\tbitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t pixelsWide:width pixelsHigh:height bitsPerSample:8\n\t\t\t\t\t\t\t\t\t\t\t\t\tsamplesPerPixel:4 hasAlpha:YES isPlanar:NO\n\t\t\t\t\t\t\t\t\t\t\t\t\t colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// I thought this should be 0 because I thought I want pre-multipled alpha, but some png's I'm testing render better with this flag.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitmapFormat:NSAlphaNonpremultipliedBitmapFormat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbytesPerRow:CalculateBytesPerRow(width, 4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   bitsPerPixel:32\n\t\t\t\t\t\t];\n\t}\n\telse if(24 == bpp)\n\t{\n\t\tbitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   pixelsWide:width pixelsHigh:height bitsPerSample:8\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  samplesPerPixel:3 hasAlpha:NO isPlanar:NO\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// untested\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitmapFormat:NSAlphaNonpremultipliedBitmapFormat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  bytesPerRow:CalculateBytesPerRow(width, 3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   bitsPerPixel:24\n\t\t\t\t\t\t];\n\t}\n\telse if(8 == bpp)\n\t{\n\t\t\n\t\t// We'll make a full 32-bit image for this case\n\t\tbitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   pixelsWide:width pixelsHigh:height bitsPerSample:8\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  samplesPerPixel:4 hasAlpha:YES isPlanar:NO\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   colorSpaceName:NSDeviceRGBColorSpace\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// untested\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbitmapFormat:NSAlphaNonpremultipliedBitmapFormat\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  bytesPerRow:CalculateBytesPerRow(width, 4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   bitsPerPixel:32\n\t\t\t\t\t\t];\n\t\t\n\t}\n\telse\n\t{\n\t\t[image release];\n\t\treturn NULL;\n\t}\n\t\n\t\n\t\n\tif(32 == bpp)\n\t{\n\t\t//  unsigned char *red,*green,*blue,*alpha;\n\t\tunsigned char* source_pixel;\n\n\t\t//  unsigned char *pixels = malloc(width*height*bpp);\n\t\tunsigned char *pixels = [bitmap_image bitmapData];\n\t\tint row_length = CalculateRowLength(width, 4);\n\n\n\t\t\n\t\tsource_pixel = imgdata;\n\n\t\t\n\t\t  for(y=0;y<height;y++){\n\t\t\t  for(x=0;x<row_length;x++) {\n\t\t\t\t  /*\n\t\t\t\t   *pixels++ = *red++;\n\t\t\t\t   *pixels++ = *green++;\n\t\t\t\t   *pixels++ = *blue++;\n\t\t\t\t   */\n\t\t\t\t  *pixels = *source_pixel;\n\t\t\t\t  pixels++;\n\t\t\t\t  source_pixel++;\n\t\t\t\t  \n\t\t\t\t  *pixels = *source_pixel;\n\t\t\t\t  pixels++;\n\t\t\t\t  source_pixel++;\n\t\t\t\t  \n\t\t\t\t  *pixels = *source_pixel;\n\t\t\t\t  pixels++;\n\t\t\t\t  source_pixel++;\n\t\t\t\t  \n\t\t\t\t  if(make_inactive) {\n\t\t\t\t\t  unsigned char r = *(pixels-3),\n\t\t\t\t\t  g = *(pixels-2),\n\t\t\t\t\t  b = *(pixels-1);\n\t\t\t\t\t  iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n\t\t\t\t  }\n\t\t\t\t  if(bpp==32)\n\t\t\t\t  {\n\t\t\t //   *pixels++ = *alpha++;\n\t\t\t\t\t  \n\t\t\t\t\t  *pixels = *source_pixel;\n\t\t\t\t\t  pixels++;\n\t\t\t\t\t  source_pixel++;\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t\t  //      *pixels++ = 255;\n\t\t\t\t\t  \n\t\t\t\t\t  *pixels = 255;\n\t\t\t\t\t  pixels++;\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\telse if(24 == bpp)\n\t{\n\t\t//  unsigned char *red,*green,*blue,*alpha;\n\t\tunsigned char* source_pixel;\n\t\t\n\t\t//  unsigned char *pixels = malloc(width*height*bpp);\n\t\tunsigned char *pixels = [bitmap_image bitmapData];\n\t\t\n\t\tint row_length = CalculateRowLength(width, 3);\n\t\t\n\t\tsource_pixel = imgdata;\n\t\t\n\t\t\n  for(y=0;y<height;y++){\n\t  for(x=0;x<row_length;x++) {\n\t\t  /*\n\t\t   *pixels++ = *red++;\n\t\t   *pixels++ = *green++;\n\t\t   *pixels++ = *blue++;\n\t\t   */\n\t\t  *pixels = *source_pixel;\n\t\t  pixels++;\n\t\t  source_pixel++;\n\t\t  \n\t\t  *pixels = *source_pixel;\n\t\t  pixels++;\n\t\t  source_pixel++;\n\t\t  \n\t\t  *pixels = *source_pixel;\n\t\t  pixels++;\n\t\t  source_pixel++;\n\t\t  \n\t\t  \n\t\t  if(make_inactive) {\n\t\t\t  unsigned char r = *(pixels-3),\n\t\t\t  g = *(pixels-2),\n\t\t\t  b = *(pixels-1);\n\t\t\t  iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n\t\t  }\n\n\t\t  \n\t  }\n  }\n\t\t\n\t\t\n\n\t}\n\telse if(8 == bpp)\n\t{\n#if 1\n\t\t//  unsigned char *red,*green,*blue,*alpha;\n\t\tunsigned char* source_pixel;\n\t\t\n\t\t//  unsigned char *pixels = malloc(width*height*bpp);\n\t\tunsigned char *pixels = [bitmap_image bitmapData];\n\t\t\n\t\tint row_length = CalculateRowLength(width, 4);\n\n\t\tint colors_count = 0;\n\t\tiupColor colors[256];\n\t\t\n\t\tint has_alpha = iupImageInitColorTable(ih, colors, &colors_count);\n\n\t\t\n\n\t\t\n\t\t\n\t\t\n\t\tsource_pixel = imgdata;\n\t\t\n\t\t\n\t\t  for(y=0;y<height;y++){\n\t\t\t  for(x=0;x<row_length;x++) {\n\n\t\t\t\t  unsigned char index = *source_pixel;\n\t\t\t\t  iupColor* c = &colors[index];\n\n\t\t\t\t  *pixels = c->r;\n\t\t\t\t  pixels++;\n\t\t\t\t  *pixels = c->g;\n\t\t\t\t  pixels++;\n\t\t\t\t  *pixels = c->b;\n\t\t\t\t  pixels++;\n\t\t\t\t  \n\t\t\t\t  if (has_alpha)\n\t\t\t\t  {\n\t\t\t\t\t  *pixels = c->a;\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t\t  *pixels = 255;\n\t\t\t\t  }\n\t\t\t\t  pixels++;\n\t\t\t\t  source_pixel++;\n\n\t\t\t\t  \n\t\t\t\t  \n\t\t\t\t  if(make_inactive) {\n\t\t\t\t\t  unsigned char r = *(pixels-3),\n\t\t\t\t\t  g = *(pixels-2),\n\t\t\t\t\t  b = *(pixels-1);\n\t\t\t\t\t  iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n\t\t\t\t  }\n\n\t\t\t\t  \n\t\t\t\t  \n\t\t\t\t  /*\n\t\t\t\t  if(make_inactive) {\n\t\t\t\t\t  unsigned char r = *(pixels-3),\n\t\t\t\t\t  g = *(pixels-2),\n\t\t\t\t\t  b = *(pixels-1);\n\t\t\t\t\t  iupImageColorMakeInactive(&r, &g, &b, bg_r, bg_g, bg_b);\n\t\t\t\t  }\n\t\t\t\t   */\n\t\t\t  }\n\t\t  }\n\t\t\n\n\t\t\n#endif\n\t\t\n\t}\n\telse\n\t{\n\n\t\t\n\t}\n\t\n\n\t\n\t\n  [image addRepresentation:bitmap_image];\n  if (bgcolor_depend || make_inactive)\n    iupAttribSetStr(ih, \"_IUP_BGCOLOR_DEPEND\", \"1\");\n\n//  return (void*)CFBridgingRetain(image);\n\n\t// Doing an autorelease because the typical pattern is to call image = iupImageGetImage(),\n\t// and then call [foo setImage:image];\n\t// It is easy to forget to release the image for emscripten because the API doesn't use new/create/alloc in the name.\n\treturn [image autorelease];\n#endif\n\treturn NULL;\n}\n\nvoid* iupdrvImageCreateIcon(Ihandle *ih)\n{\n  return iupdrvImageCreateImage(ih, NULL, 0);\n}\n\nvoid* iupdrvImageCreateCursor(Ihandle *ih)\n{\n#if 0\n  int bpp,y,x,hx,hy,\n      width = ih->currentwidth,\n      height = ih->currentheight,\n      line_size = (width+7)/8,\n      size_bytes = line_size*height;\n  unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, \"WID\");\n  char *sbits, *mbits, *sb, *mb;\n  unsigned char r, g, b;\n\n  bpp = iupAttribGetInt(ih, \"BPP\");\n  if (bpp > 8)\n    return NULL;\n\n  sbits = (char*)malloc(2*size_bytes);\n  if (!sbits) return NULL;\n  memset(sbits, 0, 2*size_bytes);\n  mbits = sbits + size_bytes;\n\n  sb = sbits;\n  mb = mbits;\n  for (y=0; y<height; y++)\n  {\n    for (x=0; x<width; x++)\n    {\n      int byte = x/8;\n      int bit = x%8;\n      int index = (int)imgdata[y*width+x];\n      /* index==0 is transparent */\n      if (index == 1)\n        sb[byte] = (char)(sb[byte] | (1<<bit));\n      if (index != 0)\n        mb[byte] = (char)(mb[byte] | (1<<bit));\n    }\n\n    sb += line_size;\n    mb += line_size;\n  }\n\n  hx=0; hy=0;\n  iupStrToIntInt(iupAttribGet(ih, \"HOTSPOT\"), &hx, &hy, ':');\n\n  NSData *tiffData = [NSData dataWithBytes:imgdata length:(width*height*(bpp/8))];\n  NSImage *source = [[NSImage alloc] initWithData:tiffData];\n  NSSize size = {width,height};\n  [source setSize:size]; \n\n  NSPoint point = {hx,hy};\n\n  NSCursor *cursor = [[NSCursor alloc] initWithImage:source hotSpot:point];\n\n  free(sbits);\n  return (void*)CFBridgingRetain(cursor);\n#endif\n  return NULL;\n}\n\nvoid* iupdrvImageCreateMask(Ihandle *ih)\n{\n#if 0\n  int bpp,y,x,\n      width = ih->currentwidth,\n      height = ih->currentheight,\n      line_size = (width+7)/8,\n      size_bytes = line_size*height;\n  unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, \"WID\");\n  char *bits, *sb;\n  unsigned char colors[256];\n\n  bpp = iupAttribGetInt(ih, \"BPP\");\n  if (bpp > 8)\n    return NULL;\n\n  bits = (char*)malloc(size_bytes);\n  if (!bits) return NULL;\n  memset(bits, 0, size_bytes);\n\n  iupImageInitNonBgColors(ih, colors);\n\n  sb = bits;\n  for (y=0; y<height; y++)\n  {\n    for (x=0; x<width; x++)\n    {\n      int byte = x/8;\n      int bit = x%8;\n      int index = (int)imgdata[y*width+x];\n      if (colors[index])\n        sb[byte] = (char)(sb[byte] | (1<<bit));\n    }\n\n    sb += line_size;\n  }\n\n  NSData *tiffData = [NSData dataWithBytes:imgdata length:(width*height*(bpp/8))];\n  NSImage *mask = [[NSImage alloc] initWithData:tiffData];\n  NSSize size = {width,height};\n  [mask setSize:size]; \n  free(bits);\n  return (void*)CFBridgingRetain(mask);\n#endif\n  return NULL;\n}\n\nvoid* iupdrvImageLoad(const char* name, int type)\n{\n#if 0\n  //int iup2mac[3] = {IMAGE_BITMAP, IMAGE_ICON, IMAGE_CURSOR};\n  NSImage *image;\n  NSString *path = [[NSString alloc] initWithUTF8String:name];\n  image = [[NSImage alloc] initWithContentsOfFile: path];\n  NSBitmapImageRep *rep = [[image representations] objectAtIndex: 0];\n  // If you think you might get something other than a bitmap image representation,\n  // check for it here.\n\n  NSSize size = NSMakeSize ([rep pixelsWide], [rep pixelsHigh]);\n  [image setSize: size];\n  \n  return (void*)CFBridgingRetain(image);\n#endif\n  return NULL;\n}\n\nint iupdrvImageGetInfo(void* handle, int *w, int *h, int *bpp)\n{\n#if 0\n  NSImage *image = (__bridge NSImage*)handle;\n  NSBitmapImageRep *bitmap = nil;\n  if([[image representations] count]>0) bitmap = [[image representations] objectAtIndex:0];\n  if(bitmap==nil) return 0;\n  if(w) *w = [bitmap pixelsWide];\n  if(h) *h = [bitmap pixelsHigh];\n  if(bpp) *bpp = [bitmap bitsPerPixel];\n#endif\n  return 1;\n}\n\n// [NSApp setApplicationIconImage: [NSImage imageNamed: @\"Icon_name.icns\"]]\n\nvoid iupdrvImageDestroy(void* handle, int type)\n{\n}\n\n","/** \\file\n * \\brief MAC OS System Information\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n#include <unistd.h>\n#include <limits.h>\n#include <errno.h>\n\n//#include <gtk/gtk.h>\n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n\nvoid iupdrvAddScreenOffset(int *x, int *y, int add)\n{\n\t/* ?????? */\n}\n\n// How is this different than iupdrvGetFullSize? Is this supposed to subtract the menu and dock?\nvoid iupdrvGetScreenSize(int *width, int *height)\n{\n\n//\tNSRect screen_rect = [[NSScreen mainScreen] visibleFrame];\n\t\n\t// dp and sp in Emscripten\n\n\t//  int w_size = CGDisplayPixelsWide(kCGDirectMainDisplay);\n\t//  int h_size = CGDisplayPixelsHigh(kCGDirectMainDisplay);\n//\tif (width) *width = screen_rect.size.width;\n//\tif (height) *height = screen_rect.size.height;\n\t\n}\n\nvoid iupdrvGetFullSize(int *width, int *height)\n{\n#if 0\n\tNSRect screen_rect = [[NSScreen mainScreen] frame];\n\t\n\t// Points vs. Pixels in emscripten\n\t//  int w_size = CGDisplayPixelsWide(kCGDirectMainDisplay);\n\t//  int h_size = CGDisplayPixelsHigh(kCGDirectMainDisplay);\n\tif (width) *width = screen_rect.size.width;\n\tif (height) *height = screen_rect.size.height;\n#endif\n}\n\nint iupdrvGetScreenDepth(void)\n{\n//\treturn CGDisplayBitsPerPixel(kCGDirectMainDisplay);  /* Deprecated in Mac OS X v10.6 */\n\treturn 32;\n}\n\nfloat iupdrvGetScreenDpi(void)\n{\n#if 0\n\tCGRect rect = CGDisplayBounds(kCGDirectMainDisplay);\n\tint height = (int)CGRectGetHeight(rect);   /* pixels */\n\tCGSize size = CGDisplayScreenSize(kCGDirectMainDisplay);  /* millimeters */\n\treturn ((float)height / size.height) * 25.4f;  /* mm to inch */\n#endif\n}\n\nvoid iupdrvGetCursorPos(int *x, int *y)\n{\n#if 0\n\tCGPoint point;\n#ifdef OLD_MAC_INFO\n\tPoint pnt;\n\tGetMouse(&pnt);\n\tpoint = CGPointMake(pnt.h, pnt.v);\n#else\n\tHIGetMousePosition(kHICoordSpaceScreenPixel, NULL, &point);\n#endif\n\t\n\t*x = (int)point.x;\n\t*y = (int)point.y;\n#endif\n}\n\nvoid iupdrvGetKeyState(char* key)\n{\n#if 0\n\tif (GetCurrentEventKeyModifiers() & shiftKey)\n\t\tkey[0] = 'S';\n\telse\n\t\tkey[0] = ' ';\n\tif (GetCurrentEventKeyModifiers() & controlKey)\n\t\tkey[1] = 'C';\n\telse\n\t\tkey[1] = ' ';\n\tif (GetCurrentEventKeyModifiers() & optionKey)\n\t\tkey[2] = 'A';\n\telse\n\t\tkey[2] = ' ';\n\tif (GetCurrentEventKeyModifiers() & cmdKey)\n\t\tkey[3] = 'Y';\n\telse\n\t\tkey[3] = ' ';\n\t\n\tkey[4] = 0;\n#endif\n\t\n}\n\nchar *iupdrvGetSystemName(void)\n{\n\n\treturn \"Emscripten\";\n}\n\nchar *iupdrvGetSystemVersion(void)\n{\n\t\n#if 0\n\tchar* str = iupStrGetMemory(100);\n\tSInt32 systemVersion, versionMajor, versionMinor, versionBugFix, systemArchitecture;\n\t\n\tif (Gestalt(gestaltSystemVersion, &systemVersion) != noErr)\n\t\treturn NULL;\n\t\n\tif (systemVersion < 0x1040)\n\t{\n\t\t/* Major, Minor, Bug fix */\n\t\tsprintf(str, \"%ld.%ld.%ld\", (((long)systemVersion & 0xF000) >> 12) * 10 + (((long)systemVersion & 0x0F00) >> 8),\n\t\t\t\t(((long)systemVersion & 0x00F0) >> 4), ((long)systemVersion & 0x000F));\n\t}\n\telse  /* MAC_OS_X_VERSION_10_4 or later */\n\t{\n\t\tGestalt(gestaltSystemVersionMajor,  &versionMajor);\n\t\tGestalt(gestaltSystemVersionMinor,  &versionMinor);\n\t\tGestalt(gestaltSystemVersionBugFix, &versionBugFix);\n\t\t\n\t\tsprintf(str, \"%ld.%ld.%ld\", (long)versionMajor, (long)versionMinor, (long)versionBugFix);\n\t}\n\t\n\tif (Gestalt(gestaltSysArchitecture, &systemArchitecture) == noErr)\n\t{\n\t\tif (systemArchitecture == gestalt68k)\n\t\t\tstrcat(str, \" (Motorola 68k)\");\n\t\telse if (systemArchitecture == gestaltPowerPC)\n\t\t\tstrcat(str, \" (Power PC)\");\n\t\telse /* gestaltIntel */\n\t\t\tstrcat(str, \" (Intel)\");\n\t}\n\t\n\treturn str;\n#else\n\t\n/*\n\tNSString* version_string = nil;\n\tversion_string = [[NSProcessInfo processInfo] operatingSystemVersionString];\n\t\n\tconst char* c_str = [version_string UTF8String];\n\t// don't use [version_string length]...counts characters, not bytes\n\tsize_t str_len = strlen(c_str);\n\t\n\tchar* iup_str = iupStrGetMemory((int)str_len);\n\tstrlcpy(iup_str, c_str, str_len+1);\n\t\n\treturn iup_str;\n*/\n\treturn NULL;\n#endif\n\n}\n\nchar *iupdrvGetComputerName(void)\n{\n\t// Emscripten doesn't give a computer name. This is also a problem for protocols like Zeroconf.\n\t// TODO: Use my solution for Zeroconf here.\n\t\n\treturn NULL;\n}\n\nchar *iupdrvGetUserName(void)\n{\n\n\treturn NULL;\n\n\t\n}\n\nchar* iupdrvLocaleInfo(void)\n{\n\t//return iupStrReturnStr(nl_langinfo(CODESET));\n\treturn NULL;\n}\n\nchar* iupdrvGetCurrentDirectory(void)\n{\n\treturn NULL;\n}\n\nint iupdrvSetCurrentDirectory(const char* dir)\n{\n\treturn 0;\n}\n\nint iupdrvMakeDirectory(const char* name) \n{\n\treturn 0;\n}\n\nint iupdrvIsFile(const char* name)\n{\n\treturn 0;\n}\n\nint iupdrvIsDirectory(const char* name)\n{\n\treturn 0;\n}\n\nint iupdrvGetWindowDecor(void* wnd, int *border, int *caption)\n{\n\t*border = 0;\n\t*caption = 0;\n\treturn 0;\n}\n\n\n\n","/**\n * IupLabel module, C source\n * Please see accompanying JS file for external functions\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n#include \"iup_label.h\"\n#include \"iup_drv.h\"\n#include \"iup_image.h\"\n#include \"iup_focus.h\"\n\n#include \"iup_childtree.h\"\n\n#include \"iupemscripten_drv.h\"\n\n#include \"iup_key.h\"\n#include <emscripten.h>\n\nextern int emjsLabel_CreateLabel(void);\nextern void emjsLabel_SetTitle(int handle_id, const char* title);\n\nextern void emjsLabel_CreateSeparator(int handle_id, char* type);\n\nextern void emjsLabel_SetFGColor(int handle_id, const char* color); /* should it be constant char*? */\nextern void emjsLabel_SetBGColor(int handle_id, char* color); \nextern int emjsLabel_SetAlignmentAttrib(int handle_id, const char* value);\n\nstatic int emscriptenLabelSetTitleAttrib(Ihandle* ih, const char* value)\n{\n  // do we need this check? (it was in gtk)\n  if (ih->data->type == IUP_LABEL_TEXT) {\n    emjsLabel_SetTitle(ih->handle->handleID, value); \n  }\n\n\treturn 1;\n\n}\n\nstatic int emscriptenLabelSetFgColorAttrib(Ihandle* ih, const char* value)\n{\n  // call helper func from common; func will parse string and apply color to widget\n  // can this be refactored into some other function? doesn't do much..\n  iupdrvBaseSetFgColorAttrib(ih, value);\n\n  return 1;\n}\n\nstatic int emscriptenLabelSetBgColorAttrib(Ihandle* ih, const char* value)\n{\n  emjsLabel_SetBGColor(7, \"red\");\n  return 1;\n}\n/* { */\n\n/*   GtkWidget* eventbox = (GtkWidget*)iupAttribGet(ih, \"_IUP_EXTRAPARENT\"); */\n/*   unsigned char r, g, b; */\n\n/*   /1* ignore given value, must use only from parent for the scrollbars *1/ */\n/*   char* parent_value = iupBaseNativeParentGetBgColor(ih); */\n\n/*   if (iupStrToRGB(parent_value, &r, &g, &b)) */\n/*     iupgtkSetBgColor(eventbox, r, g, b); */\n\n/*   (void)value; */\n/*   return iupdrvBaseSetBgColorAttrib(ih, parent_value); */\n/* } */\n\n\nstatic int emscriptenLabelMapMethod(Ihandle* ih)\n{\n  int label_id = 0;\n  InativeHandle* new_handle = NULL;\n\n  label_id = emjsLabel_CreateLabel();\n  new_handle = (InativeHandle*)calloc(1, sizeof(InativeHandle));\n\n  new_handle->handleID = label_id;\n  ih->handle = new_handle;\n\n  iupEmscripten_SetIntKeyForIhandleValue(label_id, ih);\n\n  // Set text inside label (uses title attribute)\n\tchar* attrib_title = iupAttribGet(ih, \"TITLE\");\n\tif(attrib_title && *attrib_title != 0)\n\t{\n\t\tih->data->type |= IUP_LABEL_TEXT;\n\t\t/*\n\t\tif(ih->data->type & IUP_BUTTON_IMAGE)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t\t*/\n\n\t\temjsLabel_SetTitle(label_id, attrib_title);\n\t}\n#if 0\n\tchar* value;\n\tvalue = iupAttribGet(ih, \"SEPARATOR\");\n\n\tif (value)\n\t{\n\t\tif (iupStrEqualNoCase(value, \"HORIZONTAL\"))\n\t\t{\n\t\t\tih->data->type = IUP_LABEL_SEP_HORIZ;\n\n      // create horizontal separater in js\n      emjsLabel_CreateSeparator(\"horizontal\");\n\t\t}\n\t\telse /* \"VERTICAL\" */\n\t\t{\n\t\t\tih->data->type = IUP_LABEL_SEP_VERT;\n\n      ih->data->type = IUP_LABEL_SEP_VERT;\n#if GTK_CHECK_VERSION(3, 0, 0)\n      label = gtk_separator_new(GTK_ORIENTATION_VERTICAL);\n#else\n      label = gtk_vseparator_new();\n#endif\n//\t\t\tNSBox* vertical_separator=[[NSBox alloc] initWithFrame:NSMakeRect(20.0, 20.0, 1.0, 250.0)];\n\t\t\tNSBox* vertical_separator=[[NSBox alloc] initWithFrame:NSMakeRect(0.0, 0.0, 1.0, 250.0)];\n\t\t\t[vertical_separator setBoxType:NSBoxSeparator];\n\t\t\tthe_label = vertical_separator;\n\n\t\t}\n\t}\n\telse\n\t{\n    // does this mean the label needs to be created here? need to find where the label should be made\n    label_id = emjsButton_CreateLabel();\n\n\t\tvalue = iupAttribGet(ih, \"IMAGE\");\n\t\tif (value)\n\t\t{\n\t\t\tih->data->type = IUP_LABEL_IMAGE;\n\t\t\t\n\t\t\tchar *name;\n\t\t\tint make_inactive = 0;\n\t\t\t\n\t\t\tif (iupdrvIsActive(ih))\n    name = iupAttribGet(ih, \"IMAGE\");\n\t\t\telse\n\t\t\t{\n    name = iupAttribGet(ih, \"IMINACTIVE\");\n    if (!name)\n\t  {\n\t\tname = iupAttribGet(ih, \"IMAGE\");\n\t\tmake_inactive = 1;\n\t  }\n\t}\n\t\t\t\n\t\t\tid the_bitmap;\n\t\t\tthe_bitmap = iupImageGetImage(name, ih, make_inactive);\n\t\t\tint width;\n\t\t\tint height;\n\t\t\tint bpp;\n\t\t\t\n\t\t\tiupdrvImageGetInfo(the_bitmap, &width, &height, &bpp);\n\n//\t\t\tstatic int woffset = 0;\n//\t\t\tstatic int hoffset = 0;\n\t\t\t\n\t\t\tNSImageView* image_view = [[NSImageView alloc] initWithFrame:NSMakeRect(0, 0, width, height)];\n//\t\t\tNSImageView* image_view = [[NSImageView alloc] initWithFrame:NSMakeRect(woffset, hoffset, width, height)];\n\t\t\t[image_view setImage:the_bitmap];\n\t\t\t\n//\t\t\twoffset += 30;\n//\t\t\thoffset += 30;\n\t\t\t\n\t\t\tthe_label = image_view;\n\t\t\t\n\t\t\tif (!the_bitmap)\n\t\t\t\t\treturn;\n\t\t\t\n\t\t\t/* must use this info, since image can be a driver image loaded from resources */\n\t\t\tiupdrvImageGetInfo(hBitmap, &width, &height, &bpp);\n\t\t\t\n\t\t\tNSBitmapImageRep* bitmap_image = [[NSBitmapImageRep alloc]\n\t\t\t\t\t\t\t\t\t initWithBitmapDataPlanes:NULL\n\t\t\t\t\t\t\t\t\t pixelsWide: width\n\t\t\t\t\t\t\t\t\t pixelsHigh: height\n\t\t\t\t\t\t\t\t\t bitsPerSample: 8\n\t\t\t\t\t\t\t\t\t samplesPerPixel: 4\n\t\t\t\t\t\t\t\t\t hasAlpha: YES\n\t\t\t\t\t\t\t\t\t isPlanar: NO\n\t\t\t\t\t\t\t\t\t colorSpaceName: NSCalibratedRGBColorSpace\n\t\t\t\t\t\t\t\t\t bytesPerRow: width * 4\n\t\t\t\t\t\t\t\t\t bitsPerPixel: 32]\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tih->data->type = IUP_LABEL_TEXT;\n\n\t\t\tthe_label = [[NSTextField alloc] initWithFrame:NSZeroRect];\n//\t\t\tthe_label = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];\n\n\t\t\t[the_label setBezeled:NO];\n\t\t\t[the_label setDrawsBackground:NO];\n\t\t\t[the_label setEditable:NO];\n//\t\t\t[the_label setSelectable:NO];\n\t\t\t// TODO: FEATURE: I think this is really convenient for users so it should be the default\n\t\t\t[the_label setSelectable:YES];\n\t\t\t\n\t\t\tNSFont* the_font = [the_label font];\n\t\t\tNSLog(@\"font %@\", the_font);\n\t\t\n\t\t}\n\t}\n\t\n\n\tif (!the_label)\n\t{\n\t\treturn IUP_ERROR;\n\t}\n\t\n\t\n\tih->handle = the_label;\n\n#endif\n\t\n\t/* add to the parent, all GTK controls must call this. */\n//\tiupgtkAddToParent(ih);\n\t\n\t\n//\tIhandle* ih_parent = ih->parent;\n//\tid parent_native_handle = ih_parent->handle;\n\t\n\tiupEmscripten_AddWidgetToParent(ih);\n\t\n\t\n\t/* configure for DRAG&DROP of files */\n\tif (IupGetCallback(ih, \"DROPFILES_CB\"))\n\t{\n\t\tiupAttribSet(ih, \"DROPFILESTARGET\", \"YES\");\n\t}\n\treturn IUP_NOERROR;\n}\n\n\nstatic void emscriptenLabelUnMapMethod(Ihandle* ih)\n{\n\t/*\n\tid the_label = ih->handle;\n\t[the_label release];\n\tih->handle = nil;\n\t*/\n\n}\n\nvoid iupdrvLabelInitClass(Iclass* ic)\n{\n  /* Driver Dependent Class functions */\n  ic->Map = emscriptenLabelMapMethod;\n//\tic->UnMap = emscriptenLabelUnMapMethod;\n\n\n  /* Driver Dependent Attribute functions */\n\n  /* Overwrite Visual */\n  /* iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, gtkLabelSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT); */\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", iupBaseNativeParentGetBgColorAttrib, emscriptenLabelSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\n  /* Special */\n  /* iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, iupdrvBaseSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT); */\n\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, emscriptenLabelSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT);\n\t\n\t\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, emscriptenLabelSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n\n#if 0\n  /* IupLabel only */\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", NULL, gtkLabelSetAlignmentAttrib, \"ALEFT:ACENTER\", NULL, IUPAF_NO_INHERIT);  /* force new default value */\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkLabelSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PADDING\", iupLabelGetPaddingAttrib, gtkLabelSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n\n  /* IupLabel GTK and Motif only */\n  iupClassRegisterAttribute(ic, \"IMINACTIVE\", NULL, gtkLabelSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n  /* IupLabel Windows and GTK only */\n  iupClassRegisterAttribute(ic, \"WORDWRAP\", NULL, gtkLabelSetWordWrapAttrib, NULL, NULL, IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"ELLIPSIS\", NULL, gtkLabelSetEllipsisAttrib, NULL, NULL, IUPAF_DEFAULT);\n\n  /* IupLabel GTK only */\n  iupClassRegisterAttribute(ic, \"MARKUP\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n#endif\n}\n","/** \\file\n * \\brief List Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_mask.h\"\n#include \"iup_key.h\"\n#include \"iup_image.h\"\n#include \"iup_list.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\n\nvoid iupdrvListAddItemSpace(Ihandle* ih, int *h)\n{\n  (void)ih;\n  /* FROM:\n    gtk_tree_view_column_cell_get_size\n      height = text_height + 2*focus_line_width;\n    gtk_widget_style_get(ih->handle, \"focus-line-width\", &focus_line_width, NULL);\n      returns always 1\n  */\n  *h += 2;\n}\n\nvoid iupdrvListAddBorders(Ihandle* ih, int *x, int *y)\n{\n  int border_size = 2*5;\n  (*x) += border_size;\n  (*y) += border_size;\n\n  if (ih->data->is_dropdown)\n  {\n#ifdef HILDON\n    (*x) += 9; /* extra space for the dropdown button */\n#else\n    (*x) += 5; /* extra space for the dropdown button */\n#endif\n\n    if (ih->data->has_editbox)\n      (*x) += 5; /* another extra space for the dropdown button */\n    else\n    {\n      (*y) += 4; /* extra padding space */\n      (*x) += 4; /* extra padding space */\n    }\n  }\n  else\n  {\n    if (ih->data->has_editbox)\n      (*y) += 2*3; /* internal border between editbox and list */\n  }\n}\n\nint iupdrvListGetCount(Ihandle* ih)\n{\n\treturn 0;\n\t\n}\n\nvoid iupdrvListAppendItem(Ihandle* ih, const char* value)\n{\n\n\t\n}\n\nvoid iupdrvListInsertItem(Ihandle* ih, int pos, const char* value)\n{\n\n\t\n}\n\nvoid iupdrvListRemoveItem(Ihandle* ih, int pos)\n{\n\n}\n\nvoid iupdrvListRemoveAllItems(Ihandle* ih)\n{\n\n\t\n}\n\n\nvoid* iupdrvListGetImageHandle(Ihandle* ih, int id)\n{\n\n\t\n    return NULL;\n\n}\n\nint iupdrvListSetImageHandle(Ihandle* ih, int id, void* hImage)\n{\n\n\t\n  return 0;\n}\n\n\n\n\nstatic int emscriptenListMapMethod(Ihandle* ih)\n{\n\n#if 0\n\tNSView* the_view;\n\tNSPopUpButton* popup_button = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(30, 30, 190, 40)];\n\tthe_view = popup_button;\n\t\n\tif (ih->data->is_dropdown)\n\t{\n\t\tif (ih->data->has_editbox)\n\t\t{\n\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n//\t\t\tih->handle = gtk_combo_box_new_with_model(GTK_TREE_MODEL(store));\n\t\t}\n\t\t\n\n\n\t\t\n\t\t\n\t\tif(ih->data->show_image)\n\t\t{\n\n\t\t\t\n\t\t}\n\t\t\n\t\tif (ih->data->has_editbox)\n\t\t{\n\n\t\t\t\n\t\t\tif (!iupAttribGetBoolean(ih, \"CANFOCUS\"))\n\t\t\t{\n//\t\t\t\tiupgtkSetCanFocus(ih->handle, 0);\n\t\t\t}\n\t\t\t\n\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\t\n\n\t\t\t\n\t\t\t\n\t\t\tif (!iupAttribGetBoolean(ih, \"CANFOCUS\"))\n\t\t\t{\n\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t}\n\telse\n\t{\n\n\t\t\n\t\t\n\t\tif (ih->data->has_editbox)\n\t\t{\n\n\t\t\t\n//\t\t\tiupgtkSetCanFocus(ih->handle, 0);  /* focus goes only to the edit box */\n\t\t\tif (!iupAttribGetBoolean(ih, \"CANFOCUS\"))\n\t\t\t{\n//\t\t\t\tiupgtkSetCanFocus(entry, 0);\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tif (!iupAttribGetBoolean(ih, \"CANFOCUS\"))\n\t\t\t{\n//\t\t\t\tiupgtkSetCanFocus(ih->handle, 0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ih->data->show_image)\n\t\t{\n\n\t\t}\n\t\t\n\t\t\n\t\tif (ih->data->sb)\n\t\t{\n\t\t\tif (iupAttribGetBoolean(ih, \"AUTOHIDE\"))\n\t\t\t{\n//\t\t\t\tscrollbar_policy = GTK_POLICY_AUTOMATIC;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n//\t\t\t\tscrollbar_policy = GTK_POLICY_ALWAYS;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n//\t\t\tscrollbar_policy = GTK_POLICY_NEVER;\n\t\t}\n\n\t\t\n\t\t\n\t\tif (!ih->data->has_editbox && ih->data->is_multiple)\n\t\t{\n\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\n\t}\n\t\n\t/* Enable internal drag and drop support */\n\tif(ih->data->show_dragdrop && !ih->data->is_dropdown && !ih->data->is_multiple)\n\t{\n\n\t}\n\t\n\tif (iupAttribGetBoolean(ih, \"SORT\"))\n\t{\n//\t\tgtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), IUPGTK_LIST_TEXT, GTK_SORT_ASCENDING);\n\t}\n\t/* add to the parent, all GTK controls must call this. */\n//\tiupgtkAddToParent(ih);\n\t\n\t\n\tih->handle = the_view;\n\t\n#if 0\n\t// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.\n\tobjc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);\n\t// I also need to track the memory of the buttion action receiver.\n\t// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).\n\t// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.\n\t// This is generally not good emscripten as Toggles don't retain their receivers, but this seems like the best option.\n\t// Be careful of retain cycles.\n\tIupemscriptenToggleReceiver* toggle_receiver = [[IupemscriptenToggleReceiver alloc] init];\n\t[the_toggle setTarget:toggle_receiver];\n\t[the_toggle setAction:@selector(myToggleClickAction:)];\n\t// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.\n\t// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)\n\t// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.\n\tobjc_setAssociatedObject(the_toggle, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_ASSIGN);\n\t\n#endif\n\t// All emscripten views shoud call this to add the new view to the parent view.\n\tiupemscriptenAddToParent(ih);\n\n\t\n\n\t/* configure for DRAG&DROP */\n\tif (IupGetCallback(ih, \"DROPFILES_CB\"))\n\t{\n//\t\tiupAttribSet(ih, \"DROPFILESTARGET\", \"YES\");\n\t}\n\t\n//\tIupSetCallback(ih, \"_IUP_XY2POS_CB\", (Icallback)gtkListConvertXYToPos);\n\t\n//\tiupListSetInitialItems(ih);\n\t\n\t/* update a mnemonic in a label if necessary */\n//\tiupgtkUpdateMnemonic(ih);\n\t\n#endif\n\treturn IUP_NOERROR;\n}\n\n\nstatic void emscriptenListUnMapMethod(Ihandle* ih)\n{\n#if 0\n\tid the_view = ih->handle;\n\t/*\n\t id text_receiver = objc_getAssociatedObject(the_view, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY);\n\t objc_setAssociatedObject(the_view, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);\n\t [text_receiver release];\n\t */\n\t[the_view release];\n\tih->handle = NULL;\n#endif\n\t\n}\n\n\nvoid iupdrvListInitClass(Iclass* ic)\n{\n  /* Driver Dependent Class functions */\n//\tic->Map = emscriptenListMapMethod;\n//\tic->UnMap = emscriptenListUnMapMethod;\n#if 0\n\n  /* Driver Dependent Attribute functions */\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, gtkListSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkListSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTBGCOLOR\", IUPAF_DEFAULT);\n\n  /* Special */\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkListSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTFGCOLOR\", IUPAF_DEFAULT);\n\n  /* IupList only */\n  iupClassRegisterAttributeId(ic, \"IDVALUE\", gtkListGetIdValueAttrib, iupListSetIdValueAttrib, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE\", gtkListGetValueAttrib, gtkListSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWDROPDOWN\", NULL, gtkListSetShowDropdownAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TOPITEM\", NULL, gtkListSetTopItemAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPACING\", iupListGetSpacingAttrib, gtkListSetSpacingAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n\n  iupClassRegisterAttribute(ic, \"PADDING\", iupListGetPaddingAttrib, gtkListSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"SELECTEDTEXT\", gtkListGetSelectedTextAttrib, gtkListSetSelectedTextAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SELECTION\", gtkListGetSelectionAttrib, gtkListSetSelectionAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SELECTIONPOS\", gtkListGetSelectionPosAttrib, gtkListSetSelectionPosAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CARET\", gtkListGetCaretAttrib, gtkListSetCaretAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CARETPOS\", gtkListGetCaretPosAttrib, gtkListSetCaretPosAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"INSERT\", NULL, gtkListSetInsertAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"APPEND\", NULL, gtkListSetAppendAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"READONLY\", gtkListGetReadOnlyAttrib, gtkListSetReadOnlyAttrib, NULL, NULL, IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"NC\", iupListGetNCAttrib, gtkListSetNCAttrib, NULL, NULL, IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CLIPBOARD\", NULL, gtkListSetClipboardAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCROLLTO\", NULL, gtkListSetScrollToAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCROLLTOPOS\", NULL, gtkListSetScrollToPosAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttributeId(ic, \"IMAGE\", NULL, gtkListSetImageAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\n  /* Not Supported */\n  iupClassRegisterAttribute(ic, \"VISIBLE_ITEMS\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"5\", IUPAF_NOT_SUPPORTED);\n  iupClassRegisterAttribute(ic, \"DROPEXPAND\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"Yes\", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"AUTOREDRAW\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"Yes\", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n#endif\n}\n","/** \\file\n * \\brief Emscripten Message Loop\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>    \n#include <string.h>    \n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n\nstatic IFidle emscripten_idle_cb = NULL;\n\n\nvoid iupdrvSetIdleFunction(Icallback f)\n{\n  emscripten_idle_cb = (IFidle)f;\n}\n\nvoid IupExitLoop(void)\n{\n}\n\n\nint IupMainLoopLevel(void)\n{\n  return 0;\n}\n\n/* I don't see any possible way of supporting this. \n   Emscripten/Java controls the main loop and users don't have access to it.\n*/\nint IupMainLoop(void)\n{\n\tIcallback entry_callback = (Icallback)IupGetFunction(\"ENTRY_POINT\");\n\n\tif(entry_callback)\n\t{\n\t\tentry_callback(NULL);\n\t}\n\n\treturn IUP_NOERROR;\n\n}\n\nint IupLoopStepWait(void)\n{\n  return IUP_DEFAULT;\n}\n\nint IupLoopStep(void)\n{\n  return IUP_DEFAULT;\n}\n\nvoid IupFlush(void)\n{\n}\n\n","/** \\file\n * \\brief Menu Resources\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_childtree.h\"\n#include \"iup_attrib.h\"\n#include \"iup_dialog.h\"\n#include \"iup_str.h\"\n#include \"iup_label.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_image.h\"\n#include \"iup_menu.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\nint iupdrvMenuPopup(Ihandle* ih, int x, int y)\n{\n \n\treturn IUP_NOERROR;\n}\n\nint iupdrvMenuGetMenuBarSize(Ihandle* ih)\n{\n  int ch;\n  iupdrvFontGetCharSize(ih, NULL, &ch);\n#ifdef WIN32\n  return 3 + ch + 3;\n#else\n  return 4 + ch + 4;\n#endif\n}\n\n\nstatic void emscriptenReleaseMenuClass(Iclass* ic)\n{\n\t// Not sure if I should tear this down. Typically apps just quit and leave all this stuff.\n//\t[NSApp setMainMenu:nil];\n\n}\n\n\nvoid iupdrvMenuInitClass(Iclass* ic)\n{\n#if 0\n\tid menubar = [[NSMenu new] autorelease];\n\tid appMenuItem = [[NSMenuItem new] autorelease];\n\t[menubar addItem:appMenuItem];\n\t[NSApp setMainMenu:menubar];\n\tid appMenu = [[NSMenu new] autorelease];\n\tid appName = [[NSProcessInfo processInfo] processName];\n\tid quitTitle = [@\"Quit \" stringByAppendingString:appName];\n\tid quitMenuItem = [[[NSMenuItem alloc] initWithTitle:quitTitle\n\t\t\t\t\t\t\t\t\t\t\t\t  action:@selector(terminate:) keyEquivalent:@\"q\"] autorelease];\n\t[appMenu addItem:quitMenuItem];\n\t[appMenuItem setSubmenu:appMenu];\n\n\tic->Release = emscriptenReleaseMenuClass;\n  /* Driver Dependent Class functions */\n  ic->Map = gtkMenuMapMethod;\n  ic->UnMap = gtkMenuUnMapMethod;\n\n  /* Used by iupdrvMenuGetMenuBarSize */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_DEFAULT);  /* use inheritance to retrieve standard fonts */\n\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, NULL, NULL, IUPAF_DEFAULT);\n#endif\n}\n\nvoid iupdrvItemInitClass(Iclass* ic)\n{\n#if 0\n  /* Driver Dependent Class functions */\n  ic->Map = gtkItemMapMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, iupdrvSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);  /* use inheritance to retrieve standard fonts */\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\n  /* IupItem only */\n  iupClassRegisterAttribute(ic, \"VALUE\", gtkItemGetValueAttrib, gtkItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, gtkItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TITLEIMAGE\", NULL, gtkItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkItemSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMPRESS\", NULL, gtkItemSetImpressAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n  /* IupItem GTK and Motif only */\n  iupClassRegisterAttribute(ic, \"HIDEMARK\", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);\n#endif\n}\n\n\n\nvoid iupdrvSubmenuInitClass(Iclass* ic)\n{\n#if 0\n  /* Driver Dependent Class functions */\n  ic->Map = gtkSubmenuMapMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, iupdrvSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);  /* use inheritance to retrieve standard fonts */\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\n  /* IupSubmenu only */\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, gtkItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n#endif\n}\n\n\n\nvoid iupdrvSeparatorInitClass(Iclass* ic)\n{\n#if 0\n  /* Driver Dependent Class functions */\n  ic->Map = gtkSeparatorMapMethod;\n  ic->UnMap = iupdrvBaseUnMapMethod;\n#endif\n\t\n}\n","/** \\file\n * \\brief MAC IupMessageDlg pre-defined dialog\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include \"iup.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_dialog.h\"       \n#include \"iup_strmessage.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\nvoid iupdrvMessageDlgInitClass(Iclass* ic)\n{\n//  ic->DlgPopup = macMessageDlgPopup;\n}\n","/** \\file\n * \\brief Emscripten Driver Core\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>          \n#include <stdlib.h>\n#include <string.h>          \n\n#include \"iup.h\"\n\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvinfo.h\"\n#include \"iup_object.h\"\n#include \"iup_globalattrib.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n#if 0\nchar* iupEmscriptenGetNativeWindowHandle(Ihandle* ih)\n{\n  id window = ih->handle->window;\n  if (window)\n    return (char*)window;\n  else\n    return NULL;\n}\n#endif\n\nvoid* iupdrvGetDisplay(void)\n{\n  return NULL;\n}\n\n\nvoid iupEmscriptenUpdateGlobalColors(void)\n{\n  iupGlobalSetDefaultColorAttrib(\"DLGBGCOLOR\", 237,237,237);\n\n  iupGlobalSetDefaultColorAttrib(\"DLGFGCOLOR\", 0,0,0);\n\n  iupGlobalSetDefaultColorAttrib(\"TXTBGCOLOR\", 255,255,255);\n\n  iupGlobalSetDefaultColorAttrib(\"TXTFGCOLOR\", 0,0,0);\n\n  iupGlobalSetDefaultColorAttrib(\"MENUBGCOLOR\", 183,183,183);\n\n  iupGlobalSetDefaultColorAttrib(\"MENUFGCOLOR\", 0,0,0);\n}\n\nint iupdrvOpen(int *argc, char ***argv)\n{                        \n  (void)argc; /* unused in the Emscripten driver */\n  (void)argv;\n\n\t// Assuming we're always on the main thread.\n\n  // TODO: Use this to reinitialize static/global variables???\n\tiupEmscripten_InitializeInternalGlobals();\n  \n  IupSetGlobal(\"DRIVER\", \"Emscripten\");\n\n//  IupSetGlobal(\"SYSTEMLANGUAGE\", iupEmscriptenGetSystemLanguage());\n\n  iupEmscriptenUpdateGlobalColors();\n\n  IupSetGlobal(\"_IUP_RESET_GLOBALCOLORS\", \"YES\");  /* will update the global colors when the first dialog is mapped */\n\n  return IUP_NOERROR;\n}\n\nvoid iupdrvClose(void)\n{\n\n\tiupEmscripten_DestroyInternalGlobals();\n\t\n}\n","/** \\file\n* \\brief Progress bar Control\n*\n* See Copyright Notice in \"iup.h\"\n*/\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_progressbar.h\"\n#include \"iup_drv.h\"\n\n#include \"iupemscripten_drv.h\"\n\n// TODO: API: I think we're going to need a separate start/stop key.\n// emscripten Indeterminate is for progresses you don't know the range for, but are still animated when in progress.\n\n// TODO: FEATURE: emscripten provides spinner style\n\n\n\n\nvoid iupdrvProgressBarInitClass(Iclass* ic)\n{\n  /* Driver Dependent Class functions */\n//\tic->Map = emscriptenProgressBarMapMethod;\n//\tic->UnMap = emscriptenProgressBarUnMapMethod;\n\n  /* Driver Dependent Attribute functions */\n  \n  /* Visual */\n//  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n  \n  /* Special */\n//  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n#if 0\n\n  /* IupProgressBar only */\n  iupClassRegisterAttribute(ic, \"VALUE\",  iProgressBarGetValueAttrib,  emscriptenProgressBarSetValueAttrib,  NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n\t\n  iupClassRegisterAttribute(ic, \"ORIENTATION\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"MARQUEE\",     NULL, emscriptenProgressBarSetMarqueeAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"DASHED\",      NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n#endif\n\t\n}\n","/** \\file\n* \\brief Tabs Control\n*\n* See Copyright Notice in \"iup.h\"\n*/\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_dialog.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_image.h\"\n#include \"iup_tabs.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\nint iupdrvTabsExtraDecor(Ihandle* ih)\n{\n  (void)ih;\n  return 0;\n}\n\nint iupdrvTabsGetLineCountAttrib(Ihandle* ih)\n{\n  (void)ih;\n  return 1;\n}\n\nvoid iupdrvTabsSetCurrentTab(Ihandle* ih, int pos)\n{\n}\n\nint iupdrvTabsGetCurrentTab(Ihandle* ih)\n{\n\treturn 0;\n}\n\n\n\nint iupdrvTabsIsTabVisible(Ihandle* child, int pos)\n{\n\treturn 0;\n\t\n}\n\n\nvoid iupdrvTabsInitClass(Iclass* ic)\n{\n#if 0\n  /* Driver Dependent Class functions */\n  ic->Map = gtkTabsMapMethod;\n  ic->ChildAdded     = gtkTabsChildAddedMethod;\n  ic->ChildRemoved   = gtkTabsChildRemovedMethod;\n\n  /* Driver Dependent Attribute functions */\n\n  iupClassRegisterCallback(ic, \"TABCLOSE_CB\", \"i\");\n\n  /* Common */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, gtkTabsSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkTabsSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkTabsSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT);\n\n  /* IupTabs only */\n  iupClassRegisterAttribute(ic, \"TABTYPE\", iupTabsGetTabTypeAttrib, gtkTabsSetTabTypeAttrib, IUPAF_SAMEASSYSTEM, \"TOP\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TABORIENTATION\", iupTabsGetTabOrientationAttrib, gtkTabsSetTabOrientationAttrib, IUPAF_SAMEASSYSTEM, \"HORIZONTAL\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"TABTITLE\", iupTabsGetTitleAttrib, gtkTabsSetTabTitleAttrib, IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"TABIMAGE\", NULL, gtkTabsSetTabImageAttrib, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n  iupClassRegisterAttributeId(ic, \"TABVISIBLE\", iupTabsGetTabVisibleAttrib, gtkTabsSetTabVisibleAttrib, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PADDING\", iupTabsGetPaddingAttrib, gtkTabsSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n\n  /* NOT supported */\n  iupClassRegisterAttribute(ic, \"MULTILINE\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_DEFAULT);\n#endif\n\t\n}\n\n","/** \\file\n * \\brief Text Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n#include \"iup_mask.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_image.h\"\n#include \"iup_key.h\"\n#include \"iup_array.h\"\n#include \"iup_text.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n\n\nvoid iupdrvTextAddSpin(int *w, int h)\n{\n\n\t\n}\n\nvoid iupdrvTextAddBorders(int *x, int *y)\n{\n\n\t\n}\n\n\nvoid iupdrvTextConvertLinColToPos(Ihandle* ih, int lin, int col, int *pos)\n{\n \n}\n\nvoid iupdrvTextConvertPosToLinCol(Ihandle* ih, int pos, int *lin, int *col)\n{\n\n\t\n}\n\n\n\nvoid* iupdrvTextAddFormatTagStartBulk(Ihandle* ih)\n{\n\t\n\t\n  return NULL;\n}\n\nvoid iupdrvTextAddFormatTagStopBulk(Ihandle* ih, void* state)\n{\n\n\t\n}\n\nvoid iupdrvTextAddFormatTag(Ihandle* ih, Ihandle* formattag, int bulk)\n{\n\n\t\n}\n\n\n\n\nstatic int emscriptenTextMapMethod(Ihandle* ih)\n{\n#if 0\n\tNSView* the_view;\n\t\n\n\t\n\tif (ih->data->is_multiline)\n\t{\n//\t\tNSTextView* text_view = [[NSTextView alloc] initWithFrame:NSZeroRect];\n\t\tNSTextView* text_view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, 400, 400)];\n\t\tthe_view = text_view;\n\t\t\n\n\t\tint wordwrap = 0;\n\t\t\n\n\n\t\t\n\t\t/* formatting is always supported when MULTILINE=YES */\n\t\tih->data->has_formatting = 1;\n\t\t\n\t\tif (iupAttribGetBoolean(ih, \"WORDWRAP\"))\n\t\t{\n\t\t\twordwrap = 1;\n\t\t\tih->data->sb &= ~IUP_SB_HORIZ;  /* must remove the horizontal scroolbar */\n\t\t\t\n\t\t\t\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNSSize layout_size = [text_view maxSize];\n\t\t\tlayout_size.width = layout_size.height;\n\t\t\t[text_view setMaxSize:layout_size];\n\t\t\t[[text_view textContainer] setWidthTracksTextView:NO];\n\t\t\t[[text_view textContainer] setContainerSize:layout_size];\n\t\t\t\n\t\t}\n\t\t\n\t}\n\telse\n\t{\n\t\tNSTextField* text_field;\n\t\t\n\t\t\n\t\t// IMPORTANT: Secure text fields are not togglable in emscripten\n\t\t// It might be fakeable, however, since this is security related, mucking with it is ill-advised.\n\t\t// Also Mac App Store may reject ill-advised things.\n\t\tif(iupAttribGetBoolean(ih, \"PASSWORD\"))\n\t\t{\n\n\t\t\t//text_field = [[NSSecureTextField alloc] initWithFrame:NSZeroRect];\n\t\t\ttext_field = [[NSSecureTextField alloc] initWithFrame:NSMakeRect(0, 0, 140, 40)];\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\t//text_field = [[NSTextField alloc] initWithFrame:NSZeroRect];\n\t\t\ttext_field = [[NSTextField alloc] initWithFrame:NSMakeRect(50, 50, 140, 40)];\n\t\t\t\n\t\t\t\n\t\t}\n\t\tthe_view = text_field;\n\n\n\t\t[text_field setPlaceholderString:@\"Placeholder Text\"];\n\t\t\n\t\tif(iupAttribGetBoolean(ih, \"SPIN\"))\n\t\t{\n\t\t\t// TODO: NSStepper\n\t\t\t\n\t\t\t/*\n\t\t\tgtk_spin_button_set_numeric((GtkSpinButton*)ih->handle, FALSE);\n\t\t\tgtk_spin_button_set_digits((GtkSpinButton*)ih->handle, 0);\n\t\t\t\n\t\t\tgtk_spin_button_set_wrap((GtkSpinButton*)ih->handle, iupAttribGetBoolean(ih, \"SPINWRAP\"));\n\t\t\t\n\t\t\tg_signal_connect(G_OBJECT(ih->handle), \"value-changed\", G_CALLBACK(gtkTextSpinValueChanged), ih);\n\t\t\tg_signal_connect(G_OBJECT(ih->handle), \"output\", G_CALLBACK(gtkTextSpinOutput), ih);\n\t\t\t\n\t\t\tif (!iupAttribGetBoolean(ih, \"SPINAUTO\"))\n\t\t\t{\n\t\t\t\tg_signal_connect(G_OBJECT(ih->handle), \"input\", G_CALLBACK(gtkTextSpinInput), ih);\n\t\t\t\tiupAttribSet(ih, \"_IUPGTK_SPIN_NOAUTO\", \"1\");\n\t\t\t}\n\t\t\t */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\n\t\t/* formatting is never supported when MULTILINE=NO */\n\t\tih->data->has_formatting = 0;\n\t\t\n\t\t\n//\t\t[text_field sizeToFit];\n\n\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\tih->handle = the_view;\n\t\n#if 0\n\t// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.\n\tobjc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);\n\t// I also need to track the memory of the buttion action receiver.\n\t// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).\n\t// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.\n\t// This is generally not good emscripten as Toggles don't retain their receivers, but this seems like the best option.\n\t// Be careful of retain cycles.\n\tIupemscriptenToggleReceiver* toggle_receiver = [[IupemscriptenToggleReceiver alloc] init];\n\t[the_toggle setTarget:toggle_receiver];\n\t[the_toggle setAction:@selector(myToggleClickAction:)];\n\t// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.\n\t// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)\n\t// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.\n\tobjc_setAssociatedObject(the_toggle, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_ASSIGN);\n\t\n#endif\n\t// All emscripten views shoud call this to add the new view to the parent view.\n\tiupemscriptenAddToParent(ih);\n\t\n\t\n\n\n#if 0\n\t/* configure for DRAG&DROP */\n\tif (IupGetCallback(ih, \"DROPFILES_CB\"))\n\t\tiupAttribSet(ih, \"DROPFILESTARGET\", \"YES\");\n\t\n\t/* update a mnemonic in a label if necessary */\n\tiupgtkUpdateMnemonic(ih);\n\t\n\tif (ih->data->formattags)\n\t\tiupTextUpdateFormatTags(ih);\n#endif\n\n#endif\n\t\t\n\t\n\treturn IUP_NOERROR;\n}\n\n\nstatic void emscriptenTextUnMapMethod(Ihandle* ih)\n{\n#if 0\n\tid the_view = ih->handle;\n\t/*\n\tid text_receiver = objc_getAssociatedObject(the_view, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY);\n\tobjc_setAssociatedObject(the_view, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);\n\t[text_receiver release];\n\t*/\n\t[the_view release];\n\tih->handle = NULL;\n#endif\n\t\n}\n\n\nvoid iupdrvTextInitClass(Iclass* ic)\n{\n  /* Driver Dependent Class functions */\n  ic->Map = emscriptenTextMapMethod;\n\tic->UnMap = emscriptenTextUnMapMethod;\n\n#if 0\n\n  /* Driver Dependent Attribute functions */\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkTextSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTBGCOLOR\", IUPAF_DEFAULT);\n\n  /* Special */\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, iupdrvBaseSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTFGCOLOR\", IUPAF_DEFAULT);\n\n  /* IupText only */\n  iupClassRegisterAttribute(ic, \"PADDING\", iupTextGetPaddingAttrib, gtkTextSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"VALUE\", gtkTextGetValueAttrib, gtkTextSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LINEVALUE\", gtkTextGetLineValueAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SELECTEDTEXT\", gtkTextGetSelectedTextAttrib, gtkTextSetSelectedTextAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SELECTION\", gtkTextGetSelectionAttrib, gtkTextSetSelectionAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SELECTIONPOS\", gtkTextGetSelectionPosAttrib, gtkTextSetSelectionPosAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CARET\", gtkTextGetCaretAttrib, gtkTextSetCaretAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"CARETPOS\", gtkTextGetCaretPosAttrib, gtkTextSetCaretPosAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_SAVE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"INSERT\", NULL, gtkTextSetInsertAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"APPEND\", NULL, gtkTextSetAppendAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"READONLY\", gtkTextGetReadOnlyAttrib, gtkTextSetReadOnlyAttrib, NULL, NULL, IUPAF_DEFAULT);\n  iupClassRegisterAttribute(ic, \"NC\", iupTextGetNCAttrib, gtkTextSetNCAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"CLIPBOARD\", NULL, gtkTextSetClipboardAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCROLLTO\", NULL, gtkTextSetScrollToAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SCROLLTOPOS\", NULL, gtkTextSetScrollToPosAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINMIN\", NULL, gtkTextSetSpinMinAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINMAX\", NULL, gtkTextSetSpinMaxAttrib, IUPAF_SAMEASSYSTEM, \"100\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPININC\", NULL, gtkTextSetSpinIncAttrib, IUPAF_SAMEASSYSTEM, \"1\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SPINVALUE\", gtkTextGetSpinValueAttrib, gtkTextSetSpinValueAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"COUNT\", gtkTextGetCountAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"LINECOUNT\", gtkTextGetLineCountAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\n  /* IupText Windows and GTK only */\n  iupClassRegisterAttribute(ic, \"ADDFORMATTAG\", NULL, iupTextSetAddFormatTagAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ADDFORMATTAG_HANDLE\", NULL, iupTextSetAddFormatTagHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", NULL, gtkTextSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, \"ALEFT\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FORMATTING\", iupTextGetFormattingAttrib, iupTextSetFormattingAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"OVERWRITE\", gtkTextGetOverwriteAttrib, gtkTextSetOverwriteAttrib, NULL, NULL, IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"REMOVEFORMATTING\", NULL, gtkTextSetRemoveFormattingAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"TABSIZE\", NULL, gtkTextSetTabSizeAttrib, \"8\", NULL, IUPAF_DEFAULT);  /* force new default value */\n  iupClassRegisterAttribute(ic, \"PASSWORD\", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);\n\n  /* Not Supported */\n  iupClassRegisterAttribute(ic, \"CUEBANNER\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"FILTER\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);\n#endif\n\t\n}\n","/** \\file\n * \\brief Timer for the Mac Driver.\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_assert.h\"\n#include \"iup_timer.h\"\n\n\n#if 0\n- (void) onTimerCallback:(NSTimer*)theTimer\n{\n  Icallback callback_function;\n  Ihandle* ih = (Ihandle*)[[[self theTimer] userInfo] pointerValue];\n  callback_function = IupGetCallback(ih, \"ACTION_CB\");\n\t\n  if(callback_function)\n  {\n\t  CFTimeInterval start_time = [self startTime];\n\t  double current_time = CACurrentMediaTime();\n\t  NSUInteger elapsed_time = (NSUInteger)(((current_time - start_time) * 1000.0) + 0.5);\n\t  iupAttribSetInt(ih, \"ELAPSEDTIME\", (int)elapsed_time);\n\t  \n    if(callback_function(ih) == IUP_CLOSE)\n\t{\n\t\tIupExitLoop();\n\t}\n  }\n}\n\n#endif\n\n\nvoid iupdrvTimerRun(Ihandle* ih)\n{\n#if 0\n  unsigned int time_ms;\n\n  if (ih->handle != nil) /* timer already started */\n  {\n\t  return;\n  }\n  time_ms = iupAttribGetInt(ih, \"TIME\");\n  if(time_ms > 0)\n  {\n\t  IupCocoaTimerController* timer_controller = [[IupCocoaTimerController alloc] init];\n\t  // CACurrentMediaTime is tied to a real time clock. It uses mach_absolute_time() under the hood.\n\t  // GNUStep: Neither of these is likely directly portable (CACurrentMediaTime more likely), so we may need an #ifdef here.\n\t  // [[NSDate date] timeIntervalSince1970]; isn't so great because it is affected by network clock changes and so forth.\n\t  double start_time = CACurrentMediaTime();\n\n\t  NSTimer* the_timer = [NSTimer scheduledTimerWithTimeInterval:(time_ms/1000.0)\n\t\ttarget:timer_controller\n        selector:@selector(onTimerCallback:)\n        userInfo:(id)[NSValue valueWithPointer:ih]\n\t\trepeats:YES\n\t];\n\t  \n\n\n\t  // Cocoa seems to block timers or events sometimes. This can be seen\n\t  // when I'm animating (via a timer) and you open an popup box or move a slider.\n\t  // Apparently, sheets and dialogs can also block (try printing).\n\t  // To work around this, Cocoa provides different run-loop modes. I need to\n\t  // specify the modes to avoid the blockage.\n\t  // NSDefaultRunLoopMode seems to be the default. I don't think I need to explicitly\n\t  // set this one, but just in case, I will set it anyway.\n\t  [[NSRunLoop currentRunLoop] addTimer:the_timer forMode:NSRunLoopCommonModes];\n\n\n\t[timer_controller setTheTimer:the_timer];\n\t  [timer_controller setStartTime:start_time];\n\n\t  ih->handle = (__unsafe_unretained void*)timer_controller;\n  }\n\t\n#endif\n}\n\nstatic void cocoaTimerDestroy(Ihandle* ih)\n{\n#if 0\n\tif(nil != ih->handle)\n\t{\n\t\tIupCocoaTimerController* timer_controller = (IupCocoaTimerController*)ih->handle;\n\t\tNSTimer* the_timer = [timer_controller theTimer];\n\t\t\n\t\t[the_timer invalidate];\n\t\t\n\t\t// This will also release the timer instance via the dealloc\n\t\t[timer_controller release];\n\t\t\n\t\tih->handle = nil;\n\t}\n#endif\n}\n\nvoid iupdrvTimerStop(Ihandle* ih)\n{\n\n//\tcocoaTimerDestroy(ih);\n\n}\n\nvoid iupdrvTimerInitClass(Iclass* ic)\n{\n\t(void)ic;\n\t// This must be UnMap and not Destroy because we're using the ih->handle and UnMap will clear the pointer to NULL before we reach Destroy.\n\tic->UnMap = cocoaTimerDestroy;\n\n\t\n}\n\n\n","/** \\file\n * \\brief MAC Driver TIPS management\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n#include <stdio.h>\n\n\n#include \"iup.h\" \n\n#include \"iup_object.h\" \n#include \"iup_str.h\" \n#include \"iup_attrib.h\" \n#include \"iup_image.h\" \n\n#include \"iupemscripten_drv.h\"\n\nint iupdrvBaseSetTipAttrib(Ihandle* ih, const char* value)\n{\n#if 0\n  id tmpTip = (id)iupAttribGet(ih, \"_IUPMAC_TIPSWIN\");\n  if (!tmpTip)\n  {\n    NSRect tipFrame;\n    id theTipString = [NSString stringWithUTF8String:value];\n    BOOL animate = NO;\n\n    tipFrame.origin = [NSEvent mouseLocation];\n    tipFrame.size = [TooltipWindow suggestedSizeForTooltip:theTipString];\n    [TooltipWindow setDefaultDuration:5];\n\n    tmpTip = [TooltipWindow tipWithAttributedString:theTipString frame:tipFrame display:NO];\n    iupAttribSetStr(ih, \"_IUPMAC_TIPSWIN\", (char*)tmpTip);\n  }\n\n  if (value==NULL)\n    [tmpTip release];\n#endif\n  return 1;\n}\n\nint iupdrvBaseSetTipVisibleAttrib(Ihandle* ih, const char* value)\n{\n#if 0\n  id tmpTip = (id)iupAttribGet(ih, \"_IUPMAC_TIPSWIN\");\n  if (!tmpTip)\n    return 0;\n\n  /* must use IupGetAttribute to use inheritance */\n  if (!IupGetAttribute(ih, \"TIP\"))\n    return 0;\n\n  NSRect tipFrame = [tmpTip frame];\n  if (iupStrBoolean(value)) {\n    unsigned char r, g, b;\n    if (iupStrToRGB(IupGetAttribute(ih, \"TIPBGCOLOR\"), &r, &g, &b))\n    {\n      [tmpTip setDefaultBackgroundColor:[NSColor colorWithDeviceRed:(r/255.0) green:(g/255.0) blue:(g/255.0) alpha:1.0]];\n    }\n    tipFrame.origin = [NSEvent mouseLocation];\n    [tmpTip frame:tipFrame display:YES];\n  } else\n    [tmpTip frame:tipFrame display:NO];\n#endif\n  return 0;\n}\n\nchar* iupdrvBaseGetTipVisibleAttrib(Ihandle* ih)\n{\n\treturn NULL;\n}\n","/** \\file\n * \\brief Toggle Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_image.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_image.h\"\n#include \"iup_key.h\"\n#include \"iup_toggle.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\n/** \\file\n * \\brief Toggle Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n\n\nstatic int emscriptenToggleMapMethod(Ihandle* ih)\n{\n#if 0\n\tchar* value;\n\n\t\n\t\n\tstatic int woffset = 0;\n\tstatic int hoffset = 0;\n\t\n\twoffset += 30;\n\thoffset += 30;\n\t//\tih->data->type = 0;\n\t\n\t//\tNSToggle* the_toggle = [[NSToggle alloc] initWithFrame:NSZeroRect];\n\tNSButton* the_toggle = [[NSButton alloc] initWithFrame:NSMakeRect(woffset, hoffset, 0, 0)];\n\t\n\t[the_toggle setButtonType:NSSwitchButton];\n\n\t\n\t\n\t\n\n\tvalue = iupAttribGet(ih, \"IMAGE\");\n\tif(value && *value!=0)\n\t{\n\t\tih->data->type = IUP_TOGGLE_IMAGE;\n\t\t\n\t\t[the_toggle setButtonType:NSSwitchButton];\n\t\t\n\t\t// I don't know what the style should be for images\n\t\t// https://mackuba.eu/2014/10/06/a-guide-to-nsToggle-styles/\n\t\t//\t\t[the_toggle setBezelStyle:NSRoundedBezelStyle];\n//\t\t[the_toggle setBezelStyle:NSThickSquareBezelStyle];\n\t\t//\t\t[the_toggle setBezelStyle:NSShadowlessSquareBezelStyle];\n\t\t//\t\t[the_toggle setBezelStyle:NSTexturedSquareBezelStyle];\n\t\t//\t\t[the_toggle setBezelStyle:NSThickerSquareBezelStyle];\n\t\t\n\t\t\n\t\tNSImage* the_bitmap;\n\t\tint make_inactive = 0;\n\t\t\n\t\t\n\t\tif(!iupAttribGet(ih, \"IMINACTIVE\"))\n\t\t{\n\t\t\tmake_inactive = 1;\n\t\t}\n\t\t\n\t\tthe_bitmap = iupImageGetImage(value, ih, make_inactive);\n\t\t[the_toggle setImage:the_bitmap];\n\t\t\n\t\t\n\t\tvalue = iupAttribGet(ih, \"IMPRESS\");\n\t\tif(value && *value!=0)\n\t\t{\n\t\t\tthe_bitmap = iupImageGetImage(value, ih, make_inactive);\n\t\t\t[the_toggle setAlternateImage:the_bitmap];\n\t\t}\n\t}\n\telse\n\t{\n\t\t[the_toggle setButtonType:NSSwitchButton];\n//\t\t[the_toggle setBezelStyle:NSRoundedBezelStyle];\n\t\t\n\t\t\n\t\t\n\t}\n\n\t//\t[the_toggle setToggleType:NSMomentaryLightButton];\n\t\n\n\tvalue = iupAttribGet(ih, \"TITLE\");\n\tif(value && *value!=0)\n\t{\n\t\tih->data->type |= IUP_TOGGLE_TEXT;\n\t\tNSString* ns_string = [NSString stringWithUTF8String:value];\n\t\t[the_toggle setTitle:ns_string];\n\t\t/*\n\t\tif(ih->data->type == IUP_TOGGLE_IMAGE)\n\t\t{\n\t\t\t// TODO: FEATURE: emscripten allows text to be placed in different positions\n\t\t\t// https://developer.apple.com/library/mac/documentation/emscripten/Conceptual/Toggle/Tasks/SettingToggleImage.html\n\t\t\t[the_toggle setImagePosition:NSImageLeft];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//\t\t\t[the_toggle setImagePosition:NSNoImage];\n\t\t\t\n\t\t}\n\t\t*/\n\t}\n\n\t\n\t[the_toggle sizeToFit];\n\t\n\t\n\t\n\tih->handle = the_toggle;\n\t\n\t// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.\n\tobjc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);\n\t// I also need to track the memory of the buttion action receiver.\n\t// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).\n\t// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.\n\t// This is generally not good emscripten as Toggles don't retain their receivers, but this seems like the best option.\n\t// Be careful of retain cycles.\n\tIupemscriptenToggleReceiver* toggle_receiver = [[IupemscriptenToggleReceiver alloc] init];\n\t[the_toggle setTarget:toggle_receiver];\n\t[the_toggle setAction:@selector(myToggleClickAction:)];\n\t// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.\n\t// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)\n\t// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.\n\tobjc_setAssociatedObject(the_toggle, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_ASSIGN);\n\t\n\t\n\t// All emscripten views shoud call this to add the new view to the parent view.\n\tiupemscriptenAddToParent(ih);\n\t\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t//\tgtk_widget_realize(ih->handle);\n\t\n\t/* update a mnemonic in a label if necessary */\n\t//\tiupgtkUpdateMnemonic(ih);\n\t\n#endif\n\treturn IUP_NOERROR;\n}\n\nstatic void emscriptenToggleUnMapMethod(Ihandle* ih)\n{\n#if 0\n\tid the_toggle = ih->handle;\n\t\n\tid butten_receiver = objc_getAssociatedObject(the_toggle, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY);\n\tobjc_setAssociatedObject(the_toggle, IUP_emscripten_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);\n\t[butten_receiver release];\n\t\n\t[the_toggle release];\n\tih->handle = NULL;\n#endif\n}\n\nvoid iupdrvToggleAddBorders(int *x, int *y)\n{\n\t\n\t\n}\n\n\n\nvoid iupdrvToggleAddCheckBox(int *x, int *y, const char* str)\n{\n\n\t\n}\n\n\nvoid iupdrvToggleInitClass(Iclass* ic)\n{\n\t/* Driver Dependent Class functions */\n\tic->Map = emscriptenToggleMapMethod;\n\tic->UnMap = emscriptenToggleUnMapMethod;\n\t\n#if 0\n\n\t\n  /* Driver Dependent Attribute functions */\n\n  /* Overwrite Common */\n  iupClassRegisterAttribute(ic, \"STANDARDFONT\", NULL, gtkToggleSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, \"DEFAULTFONT\", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);\n\n  /* Overwrite Visual */\n  iupClassRegisterAttribute(ic, \"ACTIVE\", iupBaseGetActiveAttrib, gtkToggleSetActiveAttrib, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_DEFAULT);\n\n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT);\n\n  /* Special */\n  iupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkToggleSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGFGCOLOR\", IUPAF_DEFAULT);  /* black */\n  iupClassRegisterAttribute(ic, \"TITLE\", NULL, gtkToggleSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n  /* IupToggle only */\n  iupClassRegisterAttribute(ic, \"ALIGNMENT\", NULL, gtkToggleSetAlignmentAttrib, \"ACENTER:ACENTER\", NULL, IUPAF_NO_INHERIT); /* force new default value */\n  iupClassRegisterAttribute(ic, \"IMAGE\", NULL, gtkToggleSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMINACTIVE\", NULL, gtkToggleSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"IMPRESS\", NULL, gtkToggleSetImPressAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"VALUE\", gtkToggleGetValueAttrib, gtkToggleSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\n  iupClassRegisterAttribute(ic, \"PADDING\", iupToggleGetPaddingAttrib, gtkToggleSetPaddingAttrib, IUPAF_SAMEASSYSTEM, \"0x0\", IUPAF_NOT_MAPPED);\n  iupClassRegisterAttribute(ic, \"MARKUP\", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);\n\n  /* NOT supported */\n  iupClassRegisterAttribute(ic, \"RIGHTToggle\", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_DEFAULT);\n#endif\n\t\n}\n","/** \\file\n * \\brief Tree Control\n *\n * See Copyright Notice in iup.h\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_stdcontrols.h\"\n#include \"iup_key.h\"\n#include \"iup_image.h\"\n#include \"iup_array.h\"\n#include \"iup_tree.h\"\n\n#include \"iup_drvinfo.h\"\n//#include \"iupgtk_drv.h\"\n\n\n/*****************************************************************************/\n/* ADDING ITEMS                                                              */\n/*****************************************************************************/\nvoid iupdrvTreeAddNode(Ihandle* ih, int id, int kind, const char* title, int add)\n{\n\n}\n\n\n/*****************************************************************************/\n/* AUXILIAR FUNCTIONS                                                        */\n/*****************************************************************************/\n\n\n\nint iupdrvTreeTotalChildCount(Ihandle* ih, InodeHandle* node_handle)\n{\n\n\treturn 0;\n}\n\nInodeHandle* iupdrvTreeGetFocusNode(Ihandle* ih)\n{\n\n\t\n\t\n\treturn NULL;\n}\n\n\nvoid iupdrvTreeUpdateMarkMode(Ihandle *ih)\n{\n\n}\n\n\n\nvoid iupdrvTreeDragDropCopyNode(Ihandle* src, Ihandle* dst, InodeHandle *itemSrc, InodeHandle *itemDst)\n{\n\n}\n\n\n\nvoid iupdrvTreeInitClass(Iclass* ic)\n{\n#if 0\n\t/* Driver Dependent Class functions */\n\tic->Map = gtkTreeMapMethod;\n\tic->UnMap = gtkTreeUnMapMethod;\n\t\n\t/* Visual */\n\tiupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, gtkTreeSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTBGCOLOR\", IUPAF_DEFAULT);\n\tiupClassRegisterAttribute(ic, \"FGCOLOR\", NULL, gtkTreeSetFgColorAttrib, IUPAF_SAMEASSYSTEM, \"TXTFGCOLOR\", IUPAF_DEFAULT);\n\t\n\t/* IupTree Attributes - GENERAL */\n\tiupClassRegisterAttribute(ic, \"EXPANDALL\", NULL, gtkTreeSetExpandAllAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"INDENTATION\", gtkTreeGetIndentationAttrib, gtkTreeSetIndentationAttrib, NULL, NULL, IUPAF_DEFAULT);\n\tiupClassRegisterAttribute(ic, \"SPACING\", iupTreeGetSpacingAttrib, gtkTreeSetSpacingAttrib, IUPAF_SAMEASSYSTEM, \"0\", IUPAF_NOT_MAPPED);\n\tiupClassRegisterAttribute(ic, \"TOPITEM\", NULL, gtkTreeSetTopItemAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\t\n\t/* IupTree Attributes - IMAGES */\n\tiupClassRegisterAttributeId(ic, \"IMAGE\", NULL, gtkTreeSetImageAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"IMAGEEXPANDED\", NULL, gtkTreeSetImageExpandedAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\t\n\tiupClassRegisterAttribute(ic, \"IMAGELEAF\",            NULL, gtkTreeSetImageLeafAttrib, IUPAF_SAMEASSYSTEM, \"IMGLEAF\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"IMAGEBRANCHCOLLAPSED\", NULL, gtkTreeSetImageBranchCollapsedAttrib, IUPAF_SAMEASSYSTEM, \"IMGCOLLAPSED\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"IMAGEBRANCHEXPANDED\",  NULL, gtkTreeSetImageBranchExpandedAttrib, IUPAF_SAMEASSYSTEM, \"IMGEXPANDED\", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);\n\t\n\t/* IupTree Attributes - NODES */\n\tiupClassRegisterAttributeId(ic, \"STATE\",  gtkTreeGetStateAttrib,  gtkTreeSetStateAttrib, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"DEPTH\",  gtkTreeGetDepthAttrib,  NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"KIND\",   gtkTreeGetKindAttrib,   NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"PARENT\", gtkTreeGetParentAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"COLOR\",  gtkTreeGetColorAttrib,  gtkTreeSetColorAttrib, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"NAME\",   gtkTreeGetTitleAttrib,  gtkTreeSetTitleAttrib, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"TITLE\",  gtkTreeGetTitleAttrib,  gtkTreeSetTitleAttrib, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"TOGGLEVALUE\", gtkTreeGetToggleValueAttrib, gtkTreeSetToggleValueAttrib, IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"TOGGLEVISIBLE\", gtkTreeGetToggleVisibleAttrib, gtkTreeSetToggleVisibleAttrib, IUPAF_NO_INHERIT);\n\t\n\t/* Change the set method for GTK */\n\tiupClassRegisterReplaceAttribFunc(ic, \"SHOWRENAME\", NULL, gtkTreeSetShowRenameAttrib);\n\t\n\tiupClassRegisterAttributeId(ic, \"CHILDCOUNT\", gtkTreeGetChildCountAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"TITLEFONT\",  gtkTreeGetTitleFontAttrib,  gtkTreeSetTitleFontAttrib, IUPAF_NO_INHERIT);\n\t\n\t/* IupTree Attributes - MARKS */\n\tiupClassRegisterAttributeId(ic, \"MARKED\", gtkTreeGetMarkedAttrib, gtkTreeSetMarkedAttrib, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute  (ic, \"MARK\",      NULL, gtkTreeSetMarkAttrib,      NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute  (ic, \"STARTING\",  NULL, gtkTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute  (ic, \"MARKSTART\", NULL, gtkTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute  (ic, \"MARKEDNODES\", gtkTreeGetMarkedNodesAttrib, gtkTreeSetMarkedNodesAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\t\n\tiupClassRegisterAttribute  (ic, \"VALUE\", gtkTreeGetValueAttrib, gtkTreeSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n\t\n\t/* IupTree Attributes - ACTION */\n\tiupClassRegisterAttributeId(ic, \"DELNODE\", NULL, gtkTreeSetDelNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttribute(ic, \"RENAME\", NULL, gtkTreeSetRenameAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"MOVENODE\", NULL, gtkTreeSetMoveNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\tiupClassRegisterAttributeId(ic, \"COPYNODE\", NULL, gtkTreeSetCopyNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);\n\t\n\t/* IupTree Attributes - GTK Only */\n\tiupClassRegisterAttribute  (ic, \"RUBBERBAND\", NULL, NULL, IUPAF_SAMEASSYSTEM, \"YES\", IUPAF_NO_INHERIT);\n#endif\n}\n","/** \\file\n * \\brief Valuator Control\n *\n * See Copyright Notice in \"iup.h\"\n */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include <stdarg.h>\n\n#include \"iup.h\"\n#include \"iupcbs.h\"\n\n#include \"iup_object.h\"\n#include \"iup_layout.h\"\n#include \"iup_attrib.h\"\n#include \"iup_str.h\"\n#include \"iup_val.h\"\n#include \"iup_drv.h\"\n#include \"iup_drvfont.h\"\n#include \"iup_key.h\"\n\n#include \"iupemscripten_drv.h\"\n\n\nvoid iupdrvValGetMinSize(Ihandle* ih, int *w, int *h)\n{\n#if 0\n  if (ih->data->type == IVAL_HORIZONTAL)\n  {\n    *w = 20;\n    *h = 35;\n  }\n  else\n  {\n    *w = 35;\n    *h = 20;\n  }\n#endif\n}\n\n\nvoid iupdrvValInitClass(Iclass* ic)\n{\n#if 0\n  /* Driver Dependent Class functions */\n  ic->Map = macValMapMethod;\n\n  /* Driver Dependent Attribute functions */\n  \n  /* Visual */\n  iupClassRegisterAttribute(ic, \"BGCOLOR\", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, \"DLGBGCOLOR\", IUPAF_DEFAULT); \n\n  /* Special */\n\n  /* IupVal only */\n  iupClassRegisterAttribute(ic, \"VALUE\", iupValGetValueAttrib, macValSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"PAGESTEP\", iupValGetPageStepAttrib, macValSetPageStepAttrib, IUPAF_SAMEASSYSTEM, \"0.1\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"STEP\", iupValGetStepAttrib, macValSetStepAttrib, IUPAF_SAMEASSYSTEM, \"0.01\", IUPAF_NO_INHERIT);\n  iupClassRegisterAttribute(ic, \"SHOWTICKS\", NULL, NULL, NULL, NULL, IUPAF_WRITEONLY|IUPAF_READONLY);  /* showticks is not supported in GTK */\n#endif\n}\n","#include \"iup.h\"\n#include <stddef.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#if __ANDROID__\n#include <android/log.h>\n\nvoid MyPrintf(const char* fmt, ...)\n{\n\tva_list ap;\t\n\tva_start(ap, fmt);\n\t__android_log_vprint(ANDROID_LOG_INFO, \"IupTest\", fmt, ap);\n\tva_end(ap);\n}\n#else\nvoid MyPrintf(const char* fmt, ...)\n{\n\tva_list ap;\t\n\tva_start(ap, fmt);\n\tfprintf(stderr, fmt, ap);\n\tva_end(ap);\n}\n#endif\nint OnButtonCallback(Ihandle* ih)\n{\n\tMyPrintf(\"OnButtonCallback()\\n\");\n\n\tchar temp_string[1024];\n\tstatic int button_count = 0;\n  // Stores button text in string with updated count\n\tsnprintf(temp_string, 1024, \"Iup Button %d\", button_count);\n  // Create button element\n\tIhandle* button = IupButton(temp_string, \"\");\n\n  // Set recursive callback so a new window with button opens\n\tIupSetCallback(button, \"ACTION\", (Icallback)OnButtonCallback);\n\tIhandle* dialog = IupDialog(button);\n\tsnprintf(temp_string, 1024, \"Iup Activity Title %d\", button_count);\n\n\tIupSetStrAttribute(dialog, \"TITLE\", temp_string);\n\t\n\tIupShow(dialog);\n\n\tbutton_count++;\n\n\treturn IUP_DEFAULT;\n}\n\nint testCallback(Ihandle* ih, int but, int pressed, int x, int y, char* status) {\n\tchar temp_string[1024];\n\tIhandle* button = IupButton(\"CB Test\", \"\");\n\n  // Attach recursive callback\n\tIupSetCallback(button, \"BUTTON_CB\", (Icallback)testCallback);\n\tIhandle* dialog = IupDialog(button);\n\tsnprintf(temp_string, 1024, \"Iup Activity Title\");\n\n\tIupSetStrAttribute(dialog, \"TITLE\", temp_string);\n\t\n  // ?? why does this not open a new window like OnButtonCallback? ?? \n\tIupShow(dialog);\n\n\treturn IUP_DEFAULT;\n}\n\nint IupEntryPoint(Ihandle* noop)\n{\n//\tIupOpen(0, NULL);\n  // create test buttons\n\tIhandle* button = IupButton(\"Iup Button\", \"\");\n  Ihandle* button2 = IupButton(\"Callback\", \"\");\n  // create test labels\n  Ihandle* testLabel = IupLabel(\"TestLabel\");\n  Ihandle* testLabel2 = IupLabel(\"TestLabel---2\");\n  Ihandle* testLabel3 = IupLabel(\"TestLabel----3\");\n\n  // test bg and fg color with labels\n  IupSetAttribute(testLabel, \"FGCOLOR\", \"20 200 111\");\n  //IupSetAttribute(testLabel, \"BGCOLOR\", \"20 129 115\");\n\n  // attach callbacks to test buttons\n\tIupSetCallback(button, \"ACTION\", (Icallback)OnButtonCallback);\n  IupSetCallback(button2, \"BUTTON_CB\", (Icallback)testCallback);\n\n  // more label-attrib setting, testing in different places (i know its dumb, c is synchronous..)\n  IupSetAttribute(testLabel2, \"FGCOLOR\", \"100 255 100\");\n  IupSetAttribute(testLabel3, \"FGCOLOR\", \"70 70 0\");\n  IupSetAttribute(testLabel, \"TITLE\", \"OVERWRITE\");\n\n\n\tIhandle* vb=IupVbox(button, button2, testLabel, testLabel2, testLabel3, NULL);\n\tIupSetAttribute(vb, \"GAP\", \"10\");\n\tIupSetAttribute(vb, \"MARGIN\", \"10x10\");\n\tIupSetAttribute(vb, \"ALIGNMENT\", \"ACENTER\");\n\n\tIhandle* dialog = IupDialog(vb);\n\t//\tIupMap(dialog);\n\tIupSetAttribute(dialog, \"TITLE\", \"Iup Activity Title\");\n\n\tIupShow(dialog);\n\treturn 0;\n}\n\n\nint main(int argc, char* argv[])\n{\n\tIupOpen(NULL, NULL);\n\tIupSetFunction(\"ENTRY_POINT\", IupEntryPoint);\n\tIupMainLoop();\n\treturn 0;\n}\n"]}